
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Warehouse
 * 
 */
export type Warehouse = $Result.DefaultSelection<Prisma.$WarehousePayload>
/**
 * Model WarehouseZone
 * 
 */
export type WarehouseZone = $Result.DefaultSelection<Prisma.$WarehouseZonePayload>
/**
 * Model WarehouseAisle
 * 
 */
export type WarehouseAisle = $Result.DefaultSelection<Prisma.$WarehouseAislePayload>
/**
 * Model WarehouseShelf
 * 
 */
export type WarehouseShelf = $Result.DefaultSelection<Prisma.$WarehouseShelfPayload>
/**
 * Model WarehouseBin
 * 
 */
export type WarehouseBin = $Result.DefaultSelection<Prisma.$WarehouseBinPayload>
/**
 * Model WarehouseStaff
 * 
 */
export type WarehouseStaff = $Result.DefaultSelection<Prisma.$WarehouseStaffPayload>
/**
 * Model Store
 * 
 */
export type Store = $Result.DefaultSelection<Prisma.$StorePayload>
/**
 * Model StoreStaff
 * 
 */
export type StoreStaff = $Result.DefaultSelection<Prisma.$StoreStaffPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model SupplierContract
 * 
 */
export type SupplierContract = $Result.DefaultSelection<Prisma.$SupplierContractPayload>
/**
 * Model SupplierPerformanceMetric
 * 
 */
export type SupplierPerformanceMetric = $Result.DefaultSelection<Prisma.$SupplierPerformanceMetricPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model PurchaseOrderItem
 * 
 */
export type PurchaseOrderItem = $Result.DefaultSelection<Prisma.$PurchaseOrderItemPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model CategoryPriceRule
 * 
 */
export type CategoryPriceRule = $Result.DefaultSelection<Prisma.$CategoryPriceRulePayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model Sale
 * 
 */
export type Sale = $Result.DefaultSelection<Prisma.$SalePayload>
/**
 * Model SaleItem
 * 
 */
export type SaleItem = $Result.DefaultSelection<Prisma.$SaleItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Return
 * 
 */
export type Return = $Result.DefaultSelection<Prisma.$ReturnPayload>
/**
 * Model ReturnItem
 * 
 */
export type ReturnItem = $Result.DefaultSelection<Prisma.$ReturnItemPayload>
/**
 * Model QualityControl
 * 
 */
export type QualityControl = $Result.DefaultSelection<Prisma.$QualityControlPayload>
/**
 * Model QualityControlItem
 * 
 */
export type QualityControlItem = $Result.DefaultSelection<Prisma.$QualityControlItemPayload>
/**
 * Model Transfer
 * 
 */
export type Transfer = $Result.DefaultSelection<Prisma.$TransferPayload>
/**
 * Model TransferDocument
 * 
 */
export type TransferDocument = $Result.DefaultSelection<Prisma.$TransferDocumentPayload>
/**
 * Model TransferItem
 * 
 */
export type TransferItem = $Result.DefaultSelection<Prisma.$TransferItemPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model LoyaltyProgram
 * 
 */
export type LoyaltyProgram = $Result.DefaultSelection<Prisma.$LoyaltyProgramPayload>
/**
 * Model LoyaltyProgramTier
 * 
 */
export type LoyaltyProgramTier = $Result.DefaultSelection<Prisma.$LoyaltyProgramTierPayload>
/**
 * Model LoyaltyTransaction
 * 
 */
export type LoyaltyTransaction = $Result.DefaultSelection<Prisma.$LoyaltyTransactionPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Audit
 * 
 */
export type Audit = $Result.DefaultSelection<Prisma.$AuditPayload>
/**
 * Model AuditItem
 * 
 */
export type AuditItem = $Result.DefaultSelection<Prisma.$AuditItemPayload>
/**
 * Model AuditAssignment
 * 
 */
export type AuditAssignment = $Result.DefaultSelection<Prisma.$AuditAssignmentPayload>
/**
 * Model TaxRate
 * 
 */
export type TaxRate = $Result.DefaultSelection<Prisma.$TaxRatePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  STAFF: 'STAFF',
  WAREHOUSE_MANAGER: 'WAREHOUSE_MANAGER',
  WAREHOUSE_STAFF: 'WAREHOUSE_STAFF',
  STORE_MANAGER: 'STORE_MANAGER',
  STORE_STAFF: 'STORE_STAFF'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ContractStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  TERMINATED: 'TERMINATED',
  RENEWAL_PENDING: 'RENEWAL_PENDING'
};

export type ContractStatus = (typeof ContractStatus)[keyof typeof ContractStatus]


export const PerformanceMetricType: {
  ON_TIME_DELIVERY: 'ON_TIME_DELIVERY',
  QUALITY: 'QUALITY',
  PRICE_COMPETITIVENESS: 'PRICE_COMPETITIVENESS',
  RESPONSIVENESS: 'RESPONSIVENESS',
  LEAD_TIME: 'LEAD_TIME'
};

export type PerformanceMetricType = (typeof PerformanceMetricType)[keyof typeof PerformanceMetricType]


export const PurchaseOrderStatus: {
  DRAFT: 'DRAFT',
  PENDING_APPROVAL: 'PENDING_APPROVAL',
  APPROVED: 'APPROVED',
  SENT: 'SENT',
  PARTIALLY_RECEIVED: 'PARTIALLY_RECEIVED',
  RECEIVED: 'RECEIVED',
  CANCELLED: 'CANCELLED'
};

export type PurchaseOrderStatus = (typeof PurchaseOrderStatus)[keyof typeof PurchaseOrderStatus]


export const InventoryStatus: {
  AVAILABLE: 'AVAILABLE',
  RESERVED: 'RESERVED',
  DAMAGED: 'DAMAGED',
  EXPIRED: 'EXPIRED',
  IN_TRANSIT: 'IN_TRANSIT',
  QUARANTINE: 'QUARANTINE',
  RETURNED: 'RETURNED'
};

export type InventoryStatus = (typeof InventoryStatus)[keyof typeof InventoryStatus]


export const InventoryMethod: {
  FIFO: 'FIFO',
  LIFO: 'LIFO',
  FEFO: 'FEFO',
  AVERAGE_COST: 'AVERAGE_COST'
};

export type InventoryMethod = (typeof InventoryMethod)[keyof typeof InventoryMethod]


export const PaymentMethod: {
  CASH: 'CASH',
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD',
  MOBILE_PAYMENT: 'MOBILE_PAYMENT',
  BANK_TRANSFER: 'BANK_TRANSFER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  PARTIALLY_PAID: 'PARTIALLY_PAID',
  REFUNDED: 'REFUNDED',
  FAILED: 'FAILED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const ReturnStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ReturnStatus = (typeof ReturnStatus)[keyof typeof ReturnStatus]


export const RefundMethod: {
  ORIGINAL_PAYMENT: 'ORIGINAL_PAYMENT',
  STORE_CREDIT: 'STORE_CREDIT',
  CASH: 'CASH',
  BANK_TRANSFER: 'BANK_TRANSFER'
};

export type RefundMethod = (typeof RefundMethod)[keyof typeof RefundMethod]


export const RefundStatus: {
  PENDING: 'PENDING',
  PROCESSED: 'PROCESSED',
  REJECTED: 'REJECTED'
};

export type RefundStatus = (typeof RefundStatus)[keyof typeof RefundStatus]


export const ReturnReason: {
  DEFECTIVE: 'DEFECTIVE',
  DAMAGED: 'DAMAGED',
  WRONG_ITEM: 'WRONG_ITEM',
  NOT_AS_DESCRIBED: 'NOT_AS_DESCRIBED',
  CHANGED_MIND: 'CHANGED_MIND',
  OTHER: 'OTHER'
};

export type ReturnReason = (typeof ReturnReason)[keyof typeof ReturnReason]


export const ItemCondition: {
  GOOD: 'GOOD',
  DAMAGED: 'DAMAGED',
  OPENED: 'OPENED',
  USED: 'USED'
};

export type ItemCondition = (typeof ItemCondition)[keyof typeof ItemCondition]


export const QCType: {
  RECEIVING: 'RECEIVING',
  RETURN: 'RETURN',
  RANDOM: 'RANDOM',
  COMPLAINT: 'COMPLAINT'
};

export type QCType = (typeof QCType)[keyof typeof QCType]


export const QCStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type QCStatus = (typeof QCStatus)[keyof typeof QCStatus]


export const QCItemStatus: {
  PENDING: 'PENDING',
  PASSED: 'PASSED',
  FAILED: 'FAILED',
  PARTIALLY_PASSED: 'PARTIALLY_PASSED'
};

export type QCItemStatus = (typeof QCItemStatus)[keyof typeof QCItemStatus]


export const QCAction: {
  ACCEPT: 'ACCEPT',
  REJECT: 'REJECT',
  REWORK: 'REWORK',
  RETURN_TO_SUPPLIER: 'RETURN_TO_SUPPLIER',
  DISPOSE: 'DISPOSE'
};

export type QCAction = (typeof QCAction)[keyof typeof QCAction]


export const TransferType: {
  RESTOCK: 'RESTOCK',
  RETURN: 'RETURN',
  RELOCATION: 'RELOCATION',
  ADJUSTMENT: 'ADJUSTMENT',
  INITIAL_STOCK: 'INITIAL_STOCK'
};

export type TransferType = (typeof TransferType)[keyof typeof TransferType]


export const TransferPriority: {
  LOW: 'LOW',
  NORMAL: 'NORMAL',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type TransferPriority = (typeof TransferPriority)[keyof typeof TransferPriority]


export const TransferStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  IN_TRANSIT: 'IN_TRANSIT',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type TransferStatus = (typeof TransferStatus)[keyof typeof TransferStatus]


export const LoyaltyTransactionType: {
  EARN: 'EARN',
  REDEEM: 'REDEEM',
  ADJUSTMENT: 'ADJUSTMENT',
  EXPIRY: 'EXPIRY'
};

export type LoyaltyTransactionType = (typeof LoyaltyTransactionType)[keyof typeof LoyaltyTransactionType]


export const LoyaltyTier: {
  STANDARD: 'STANDARD',
  SILVER: 'SILVER',
  GOLD: 'GOLD',
  PLATINUM: 'PLATINUM'
};

export type LoyaltyTier = (typeof LoyaltyTier)[keyof typeof LoyaltyTier]


export const AuditAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  TRANSFER: 'TRANSFER',
  ADJUSTMENT: 'ADJUSTMENT',
  SALE: 'SALE',
  RETURN: 'RETURN',
  APPROVAL: 'APPROVAL',
  REJECTION: 'REJECTION'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


export const AuditStatus: {
  PLANNED: 'PLANNED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type AuditStatus = (typeof AuditStatus)[keyof typeof AuditStatus]


export const AuditItemStatus: {
  PENDING: 'PENDING',
  COUNTED: 'COUNTED',
  RECONCILED: 'RECONCILED',
  DISCREPANCY: 'DISCREPANCY'
};

export type AuditItemStatus = (typeof AuditItemStatus)[keyof typeof AuditItemStatus]


export const AssignmentStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type AssignmentStatus = (typeof AssignmentStatus)[keyof typeof AssignmentStatus]


export const ProductCondition: {
  NEW: 'NEW',
  DAMAGED: 'DAMAGED'
};

export type ProductCondition = (typeof ProductCondition)[keyof typeof ProductCondition]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ContractStatus = $Enums.ContractStatus

export const ContractStatus: typeof $Enums.ContractStatus

export type PerformanceMetricType = $Enums.PerformanceMetricType

export const PerformanceMetricType: typeof $Enums.PerformanceMetricType

export type PurchaseOrderStatus = $Enums.PurchaseOrderStatus

export const PurchaseOrderStatus: typeof $Enums.PurchaseOrderStatus

export type InventoryStatus = $Enums.InventoryStatus

export const InventoryStatus: typeof $Enums.InventoryStatus

export type InventoryMethod = $Enums.InventoryMethod

export const InventoryMethod: typeof $Enums.InventoryMethod

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type ReturnStatus = $Enums.ReturnStatus

export const ReturnStatus: typeof $Enums.ReturnStatus

export type RefundMethod = $Enums.RefundMethod

export const RefundMethod: typeof $Enums.RefundMethod

export type RefundStatus = $Enums.RefundStatus

export const RefundStatus: typeof $Enums.RefundStatus

export type ReturnReason = $Enums.ReturnReason

export const ReturnReason: typeof $Enums.ReturnReason

export type ItemCondition = $Enums.ItemCondition

export const ItemCondition: typeof $Enums.ItemCondition

export type QCType = $Enums.QCType

export const QCType: typeof $Enums.QCType

export type QCStatus = $Enums.QCStatus

export const QCStatus: typeof $Enums.QCStatus

export type QCItemStatus = $Enums.QCItemStatus

export const QCItemStatus: typeof $Enums.QCItemStatus

export type QCAction = $Enums.QCAction

export const QCAction: typeof $Enums.QCAction

export type TransferType = $Enums.TransferType

export const TransferType: typeof $Enums.TransferType

export type TransferPriority = $Enums.TransferPriority

export const TransferPriority: typeof $Enums.TransferPriority

export type TransferStatus = $Enums.TransferStatus

export const TransferStatus: typeof $Enums.TransferStatus

export type LoyaltyTransactionType = $Enums.LoyaltyTransactionType

export const LoyaltyTransactionType: typeof $Enums.LoyaltyTransactionType

export type LoyaltyTier = $Enums.LoyaltyTier

export const LoyaltyTier: typeof $Enums.LoyaltyTier

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

export type AuditStatus = $Enums.AuditStatus

export const AuditStatus: typeof $Enums.AuditStatus

export type AuditItemStatus = $Enums.AuditItemStatus

export const AuditItemStatus: typeof $Enums.AuditItemStatus

export type AssignmentStatus = $Enums.AssignmentStatus

export const AssignmentStatus: typeof $Enums.AssignmentStatus

export type ProductCondition = $Enums.ProductCondition

export const ProductCondition: typeof $Enums.ProductCondition

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouse`: Exposes CRUD operations for the **Warehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouse.findMany()
    * ```
    */
  get warehouse(): Prisma.WarehouseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouseZone`: Exposes CRUD operations for the **WarehouseZone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarehouseZones
    * const warehouseZones = await prisma.warehouseZone.findMany()
    * ```
    */
  get warehouseZone(): Prisma.WarehouseZoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouseAisle`: Exposes CRUD operations for the **WarehouseAisle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarehouseAisles
    * const warehouseAisles = await prisma.warehouseAisle.findMany()
    * ```
    */
  get warehouseAisle(): Prisma.WarehouseAisleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouseShelf`: Exposes CRUD operations for the **WarehouseShelf** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarehouseShelves
    * const warehouseShelves = await prisma.warehouseShelf.findMany()
    * ```
    */
  get warehouseShelf(): Prisma.WarehouseShelfDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouseBin`: Exposes CRUD operations for the **WarehouseBin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarehouseBins
    * const warehouseBins = await prisma.warehouseBin.findMany()
    * ```
    */
  get warehouseBin(): Prisma.WarehouseBinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouseStaff`: Exposes CRUD operations for the **WarehouseStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarehouseStaffs
    * const warehouseStaffs = await prisma.warehouseStaff.findMany()
    * ```
    */
  get warehouseStaff(): Prisma.WarehouseStaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.store`: Exposes CRUD operations for the **Store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.StoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storeStaff`: Exposes CRUD operations for the **StoreStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreStaffs
    * const storeStaffs = await prisma.storeStaff.findMany()
    * ```
    */
  get storeStaff(): Prisma.StoreStaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplierContract`: Exposes CRUD operations for the **SupplierContract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierContracts
    * const supplierContracts = await prisma.supplierContract.findMany()
    * ```
    */
  get supplierContract(): Prisma.SupplierContractDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplierPerformanceMetric`: Exposes CRUD operations for the **SupplierPerformanceMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierPerformanceMetrics
    * const supplierPerformanceMetrics = await prisma.supplierPerformanceMetric.findMany()
    * ```
    */
  get supplierPerformanceMetric(): Prisma.SupplierPerformanceMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrderItem`: Exposes CRUD operations for the **PurchaseOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrderItems
    * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
    * ```
    */
  get purchaseOrderItem(): Prisma.PurchaseOrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoryPriceRule`: Exposes CRUD operations for the **CategoryPriceRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoryPriceRules
    * const categoryPriceRules = await prisma.categoryPriceRule.findMany()
    * ```
    */
  get categoryPriceRule(): Prisma.CategoryPriceRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sale`: Exposes CRUD operations for the **Sale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sale.findMany()
    * ```
    */
  get sale(): Prisma.SaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleItem`: Exposes CRUD operations for the **SaleItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleItems
    * const saleItems = await prisma.saleItem.findMany()
    * ```
    */
  get saleItem(): Prisma.SaleItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.return`: Exposes CRUD operations for the **Return** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Returns
    * const returns = await prisma.return.findMany()
    * ```
    */
  get return(): Prisma.ReturnDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.returnItem`: Exposes CRUD operations for the **ReturnItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReturnItems
    * const returnItems = await prisma.returnItem.findMany()
    * ```
    */
  get returnItem(): Prisma.ReturnItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qualityControl`: Exposes CRUD operations for the **QualityControl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QualityControls
    * const qualityControls = await prisma.qualityControl.findMany()
    * ```
    */
  get qualityControl(): Prisma.QualityControlDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qualityControlItem`: Exposes CRUD operations for the **QualityControlItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QualityControlItems
    * const qualityControlItems = await prisma.qualityControlItem.findMany()
    * ```
    */
  get qualityControlItem(): Prisma.QualityControlItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transfer`: Exposes CRUD operations for the **Transfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transfers
    * const transfers = await prisma.transfer.findMany()
    * ```
    */
  get transfer(): Prisma.TransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transferDocument`: Exposes CRUD operations for the **TransferDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransferDocuments
    * const transferDocuments = await prisma.transferDocument.findMany()
    * ```
    */
  get transferDocument(): Prisma.TransferDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transferItem`: Exposes CRUD operations for the **TransferItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransferItems
    * const transferItems = await prisma.transferItem.findMany()
    * ```
    */
  get transferItem(): Prisma.TransferItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loyaltyProgram`: Exposes CRUD operations for the **LoyaltyProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoyaltyPrograms
    * const loyaltyPrograms = await prisma.loyaltyProgram.findMany()
    * ```
    */
  get loyaltyProgram(): Prisma.LoyaltyProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loyaltyProgramTier`: Exposes CRUD operations for the **LoyaltyProgramTier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoyaltyProgramTiers
    * const loyaltyProgramTiers = await prisma.loyaltyProgramTier.findMany()
    * ```
    */
  get loyaltyProgramTier(): Prisma.LoyaltyProgramTierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loyaltyTransaction`: Exposes CRUD operations for the **LoyaltyTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoyaltyTransactions
    * const loyaltyTransactions = await prisma.loyaltyTransaction.findMany()
    * ```
    */
  get loyaltyTransaction(): Prisma.LoyaltyTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audit`: Exposes CRUD operations for the **Audit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audits
    * const audits = await prisma.audit.findMany()
    * ```
    */
  get audit(): Prisma.AuditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditItem`: Exposes CRUD operations for the **AuditItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditItems
    * const auditItems = await prisma.auditItem.findMany()
    * ```
    */
  get auditItem(): Prisma.AuditItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditAssignment`: Exposes CRUD operations for the **AuditAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditAssignments
    * const auditAssignments = await prisma.auditAssignment.findMany()
    * ```
    */
  get auditAssignment(): Prisma.AuditAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxRate`: Exposes CRUD operations for the **TaxRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxRates
    * const taxRates = await prisma.taxRate.findMany()
    * ```
    */
  get taxRate(): Prisma.TaxRateDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Warehouse: 'Warehouse',
    WarehouseZone: 'WarehouseZone',
    WarehouseAisle: 'WarehouseAisle',
    WarehouseShelf: 'WarehouseShelf',
    WarehouseBin: 'WarehouseBin',
    WarehouseStaff: 'WarehouseStaff',
    Store: 'Store',
    StoreStaff: 'StoreStaff',
    Supplier: 'Supplier',
    SupplierContract: 'SupplierContract',
    SupplierPerformanceMetric: 'SupplierPerformanceMetric',
    PurchaseOrder: 'PurchaseOrder',
    PurchaseOrderItem: 'PurchaseOrderItem',
    Product: 'Product',
    Category: 'Category',
    CategoryPriceRule: 'CategoryPriceRule',
    InventoryItem: 'InventoryItem',
    Sale: 'Sale',
    SaleItem: 'SaleItem',
    Payment: 'Payment',
    Return: 'Return',
    ReturnItem: 'ReturnItem',
    QualityControl: 'QualityControl',
    QualityControlItem: 'QualityControlItem',
    Transfer: 'Transfer',
    TransferDocument: 'TransferDocument',
    TransferItem: 'TransferItem',
    Customer: 'Customer',
    Address: 'Address',
    LoyaltyProgram: 'LoyaltyProgram',
    LoyaltyProgramTier: 'LoyaltyProgramTier',
    LoyaltyTransaction: 'LoyaltyTransaction',
    AuditLog: 'AuditLog',
    Audit: 'Audit',
    AuditItem: 'AuditItem',
    AuditAssignment: 'AuditAssignment',
    TaxRate: 'TaxRate'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "warehouse" | "warehouseZone" | "warehouseAisle" | "warehouseShelf" | "warehouseBin" | "warehouseStaff" | "store" | "storeStaff" | "supplier" | "supplierContract" | "supplierPerformanceMetric" | "purchaseOrder" | "purchaseOrderItem" | "product" | "category" | "categoryPriceRule" | "inventoryItem" | "sale" | "saleItem" | "payment" | "return" | "returnItem" | "qualityControl" | "qualityControlItem" | "transfer" | "transferDocument" | "transferItem" | "customer" | "address" | "loyaltyProgram" | "loyaltyProgramTier" | "loyaltyTransaction" | "auditLog" | "audit" | "auditItem" | "auditAssignment" | "taxRate"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Warehouse: {
        payload: Prisma.$WarehousePayload<ExtArgs>
        fields: Prisma.WarehouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findFirst: {
            args: Prisma.WarehouseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findMany: {
            args: Prisma.WarehouseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          create: {
            args: Prisma.WarehouseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          createMany: {
            args: Prisma.WarehouseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          delete: {
            args: Prisma.WarehouseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          update: {
            args: Prisma.WarehouseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          upsert: {
            args: Prisma.WarehouseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouse>
          }
          groupBy: {
            args: Prisma.WarehouseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseCountAggregateOutputType> | number
          }
        }
      }
      WarehouseZone: {
        payload: Prisma.$WarehouseZonePayload<ExtArgs>
        fields: Prisma.WarehouseZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>
          }
          findFirst: {
            args: Prisma.WarehouseZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>
          }
          findMany: {
            args: Prisma.WarehouseZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>[]
          }
          create: {
            args: Prisma.WarehouseZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>
          }
          createMany: {
            args: Prisma.WarehouseZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>[]
          }
          delete: {
            args: Prisma.WarehouseZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>
          }
          update: {
            args: Prisma.WarehouseZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseZoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>[]
          }
          upsert: {
            args: Prisma.WarehouseZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseZonePayload>
          }
          aggregate: {
            args: Prisma.WarehouseZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouseZone>
          }
          groupBy: {
            args: Prisma.WarehouseZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseZoneCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseZoneCountAggregateOutputType> | number
          }
        }
      }
      WarehouseAisle: {
        payload: Prisma.$WarehouseAislePayload<ExtArgs>
        fields: Prisma.WarehouseAisleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseAisleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseAisleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>
          }
          findFirst: {
            args: Prisma.WarehouseAisleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseAisleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>
          }
          findMany: {
            args: Prisma.WarehouseAisleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>[]
          }
          create: {
            args: Prisma.WarehouseAisleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>
          }
          createMany: {
            args: Prisma.WarehouseAisleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseAisleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>[]
          }
          delete: {
            args: Prisma.WarehouseAisleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>
          }
          update: {
            args: Prisma.WarehouseAisleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseAisleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseAisleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseAisleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>[]
          }
          upsert: {
            args: Prisma.WarehouseAisleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseAislePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAisleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouseAisle>
          }
          groupBy: {
            args: Prisma.WarehouseAisleGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseAisleGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseAisleCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseAisleCountAggregateOutputType> | number
          }
        }
      }
      WarehouseShelf: {
        payload: Prisma.$WarehouseShelfPayload<ExtArgs>
        fields: Prisma.WarehouseShelfFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseShelfFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseShelfFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>
          }
          findFirst: {
            args: Prisma.WarehouseShelfFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseShelfFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>
          }
          findMany: {
            args: Prisma.WarehouseShelfFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>[]
          }
          create: {
            args: Prisma.WarehouseShelfCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>
          }
          createMany: {
            args: Prisma.WarehouseShelfCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseShelfCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>[]
          }
          delete: {
            args: Prisma.WarehouseShelfDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>
          }
          update: {
            args: Prisma.WarehouseShelfUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>
          }
          deleteMany: {
            args: Prisma.WarehouseShelfDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseShelfUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseShelfUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>[]
          }
          upsert: {
            args: Prisma.WarehouseShelfUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseShelfPayload>
          }
          aggregate: {
            args: Prisma.WarehouseShelfAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouseShelf>
          }
          groupBy: {
            args: Prisma.WarehouseShelfGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseShelfGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseShelfCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseShelfCountAggregateOutputType> | number
          }
        }
      }
      WarehouseBin: {
        payload: Prisma.$WarehouseBinPayload<ExtArgs>
        fields: Prisma.WarehouseBinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseBinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseBinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>
          }
          findFirst: {
            args: Prisma.WarehouseBinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseBinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>
          }
          findMany: {
            args: Prisma.WarehouseBinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>[]
          }
          create: {
            args: Prisma.WarehouseBinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>
          }
          createMany: {
            args: Prisma.WarehouseBinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseBinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>[]
          }
          delete: {
            args: Prisma.WarehouseBinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>
          }
          update: {
            args: Prisma.WarehouseBinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>
          }
          deleteMany: {
            args: Prisma.WarehouseBinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseBinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseBinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>[]
          }
          upsert: {
            args: Prisma.WarehouseBinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseBinPayload>
          }
          aggregate: {
            args: Prisma.WarehouseBinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouseBin>
          }
          groupBy: {
            args: Prisma.WarehouseBinGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseBinGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseBinCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseBinCountAggregateOutputType> | number
          }
        }
      }
      WarehouseStaff: {
        payload: Prisma.$WarehouseStaffPayload<ExtArgs>
        fields: Prisma.WarehouseStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>
          }
          findFirst: {
            args: Prisma.WarehouseStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>
          }
          findMany: {
            args: Prisma.WarehouseStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>[]
          }
          create: {
            args: Prisma.WarehouseStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>
          }
          createMany: {
            args: Prisma.WarehouseStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseStaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>[]
          }
          delete: {
            args: Prisma.WarehouseStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>
          }
          update: {
            args: Prisma.WarehouseStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>
          }
          deleteMany: {
            args: Prisma.WarehouseStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseStaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>[]
          }
          upsert: {
            args: Prisma.WarehouseStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehouseStaffPayload>
          }
          aggregate: {
            args: Prisma.WarehouseStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouseStaff>
          }
          groupBy: {
            args: Prisma.WarehouseStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseStaffCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseStaffCountAggregateOutputType> | number
          }
        }
      }
      Store: {
        payload: Prisma.$StorePayload<ExtArgs>
        fields: Prisma.StoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findFirst: {
            args: Prisma.StoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findMany: {
            args: Prisma.StoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          create: {
            args: Prisma.StoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          createMany: {
            args: Prisma.StoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          delete: {
            args: Prisma.StoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          update: {
            args: Prisma.StoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          deleteMany: {
            args: Prisma.StoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          upsert: {
            args: Prisma.StoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          aggregate: {
            args: Prisma.StoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStore>
          }
          groupBy: {
            args: Prisma.StoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreCountArgs<ExtArgs>
            result: $Utils.Optional<StoreCountAggregateOutputType> | number
          }
        }
      }
      StoreStaff: {
        payload: Prisma.$StoreStaffPayload<ExtArgs>
        fields: Prisma.StoreStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>
          }
          findFirst: {
            args: Prisma.StoreStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>
          }
          findMany: {
            args: Prisma.StoreStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>[]
          }
          create: {
            args: Prisma.StoreStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>
          }
          createMany: {
            args: Prisma.StoreStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreStaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>[]
          }
          delete: {
            args: Prisma.StoreStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>
          }
          update: {
            args: Prisma.StoreStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>
          }
          deleteMany: {
            args: Prisma.StoreStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoreStaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>[]
          }
          upsert: {
            args: Prisma.StoreStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreStaffPayload>
          }
          aggregate: {
            args: Prisma.StoreStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreStaff>
          }
          groupBy: {
            args: Prisma.StoreStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreStaffCountArgs<ExtArgs>
            result: $Utils.Optional<StoreStaffCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      SupplierContract: {
        payload: Prisma.$SupplierContractPayload<ExtArgs>
        fields: Prisma.SupplierContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>
          }
          findFirst: {
            args: Prisma.SupplierContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>
          }
          findMany: {
            args: Prisma.SupplierContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>[]
          }
          create: {
            args: Prisma.SupplierContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>
          }
          createMany: {
            args: Prisma.SupplierContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>[]
          }
          delete: {
            args: Prisma.SupplierContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>
          }
          update: {
            args: Prisma.SupplierContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>
          }
          deleteMany: {
            args: Prisma.SupplierContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierContractUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>[]
          }
          upsert: {
            args: Prisma.SupplierContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierContractPayload>
          }
          aggregate: {
            args: Prisma.SupplierContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierContract>
          }
          groupBy: {
            args: Prisma.SupplierContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierContractCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierContractCountAggregateOutputType> | number
          }
        }
      }
      SupplierPerformanceMetric: {
        payload: Prisma.$SupplierPerformanceMetricPayload<ExtArgs>
        fields: Prisma.SupplierPerformanceMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierPerformanceMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPerformanceMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierPerformanceMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPerformanceMetricPayload>
          }
          findFirst: {
            args: Prisma.SupplierPerformanceMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPerformanceMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierPerformanceMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPerformanceMetricPayload>
          }
          findMany: {
            args: Prisma.SupplierPerformanceMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPerformanceMetricPayload>[]
          }
          create: {
            args: Prisma.SupplierPerformanceMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPerformanceMetricPayload>
          }
          createMany: {
            args: Prisma.SupplierPerformanceMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierPerformanceMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPerformanceMetricPayload>[]
          }
          delete: {
            args: Prisma.SupplierPerformanceMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPerformanceMetricPayload>
          }
          update: {
            args: Prisma.SupplierPerformanceMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPerformanceMetricPayload>
          }
          deleteMany: {
            args: Prisma.SupplierPerformanceMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierPerformanceMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierPerformanceMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPerformanceMetricPayload>[]
          }
          upsert: {
            args: Prisma.SupplierPerformanceMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPerformanceMetricPayload>
          }
          aggregate: {
            args: Prisma.SupplierPerformanceMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierPerformanceMetric>
          }
          groupBy: {
            args: Prisma.SupplierPerformanceMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierPerformanceMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierPerformanceMetricCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierPerformanceMetricCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrderItem: {
        payload: Prisma.$PurchaseOrderItemPayload<ExtArgs>
        fields: Prisma.PurchaseOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          update: {
            args: Prisma.PurchaseOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrderItem>
          }
          groupBy: {
            args: Prisma.PurchaseOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      CategoryPriceRule: {
        payload: Prisma.$CategoryPriceRulePayload<ExtArgs>
        fields: Prisma.CategoryPriceRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryPriceRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPriceRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryPriceRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPriceRulePayload>
          }
          findFirst: {
            args: Prisma.CategoryPriceRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPriceRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryPriceRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPriceRulePayload>
          }
          findMany: {
            args: Prisma.CategoryPriceRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPriceRulePayload>[]
          }
          create: {
            args: Prisma.CategoryPriceRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPriceRulePayload>
          }
          createMany: {
            args: Prisma.CategoryPriceRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryPriceRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPriceRulePayload>[]
          }
          delete: {
            args: Prisma.CategoryPriceRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPriceRulePayload>
          }
          update: {
            args: Prisma.CategoryPriceRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPriceRulePayload>
          }
          deleteMany: {
            args: Prisma.CategoryPriceRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryPriceRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryPriceRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPriceRulePayload>[]
          }
          upsert: {
            args: Prisma.CategoryPriceRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPriceRulePayload>
          }
          aggregate: {
            args: Prisma.CategoryPriceRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoryPriceRule>
          }
          groupBy: {
            args: Prisma.CategoryPriceRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryPriceRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryPriceRuleCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryPriceRuleCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      Sale: {
        payload: Prisma.$SalePayload<ExtArgs>
        fields: Prisma.SaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findFirst: {
            args: Prisma.SaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findMany: {
            args: Prisma.SaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          create: {
            args: Prisma.SaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          createMany: {
            args: Prisma.SaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          delete: {
            args: Prisma.SaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          update: {
            args: Prisma.SaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          deleteMany: {
            args: Prisma.SaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          upsert: {
            args: Prisma.SaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          aggregate: {
            args: Prisma.SaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSale>
          }
          groupBy: {
            args: Prisma.SaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleCountArgs<ExtArgs>
            result: $Utils.Optional<SaleCountAggregateOutputType> | number
          }
        }
      }
      SaleItem: {
        payload: Prisma.$SaleItemPayload<ExtArgs>
        fields: Prisma.SaleItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          findFirst: {
            args: Prisma.SaleItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          findMany: {
            args: Prisma.SaleItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>[]
          }
          create: {
            args: Prisma.SaleItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          createMany: {
            args: Prisma.SaleItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>[]
          }
          delete: {
            args: Prisma.SaleItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          update: {
            args: Prisma.SaleItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          deleteMany: {
            args: Prisma.SaleItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>[]
          }
          upsert: {
            args: Prisma.SaleItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          aggregate: {
            args: Prisma.SaleItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleItem>
          }
          groupBy: {
            args: Prisma.SaleItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleItemCountArgs<ExtArgs>
            result: $Utils.Optional<SaleItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Return: {
        payload: Prisma.$ReturnPayload<ExtArgs>
        fields: Prisma.ReturnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReturnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReturnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnPayload>
          }
          findFirst: {
            args: Prisma.ReturnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReturnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnPayload>
          }
          findMany: {
            args: Prisma.ReturnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnPayload>[]
          }
          create: {
            args: Prisma.ReturnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnPayload>
          }
          createMany: {
            args: Prisma.ReturnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReturnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnPayload>[]
          }
          delete: {
            args: Prisma.ReturnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnPayload>
          }
          update: {
            args: Prisma.ReturnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnPayload>
          }
          deleteMany: {
            args: Prisma.ReturnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReturnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReturnUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnPayload>[]
          }
          upsert: {
            args: Prisma.ReturnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnPayload>
          }
          aggregate: {
            args: Prisma.ReturnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReturn>
          }
          groupBy: {
            args: Prisma.ReturnGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReturnGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReturnCountArgs<ExtArgs>
            result: $Utils.Optional<ReturnCountAggregateOutputType> | number
          }
        }
      }
      ReturnItem: {
        payload: Prisma.$ReturnItemPayload<ExtArgs>
        fields: Prisma.ReturnItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReturnItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReturnItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnItemPayload>
          }
          findFirst: {
            args: Prisma.ReturnItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReturnItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnItemPayload>
          }
          findMany: {
            args: Prisma.ReturnItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnItemPayload>[]
          }
          create: {
            args: Prisma.ReturnItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnItemPayload>
          }
          createMany: {
            args: Prisma.ReturnItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReturnItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnItemPayload>[]
          }
          delete: {
            args: Prisma.ReturnItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnItemPayload>
          }
          update: {
            args: Prisma.ReturnItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnItemPayload>
          }
          deleteMany: {
            args: Prisma.ReturnItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReturnItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReturnItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnItemPayload>[]
          }
          upsert: {
            args: Prisma.ReturnItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnItemPayload>
          }
          aggregate: {
            args: Prisma.ReturnItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReturnItem>
          }
          groupBy: {
            args: Prisma.ReturnItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReturnItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReturnItemCountArgs<ExtArgs>
            result: $Utils.Optional<ReturnItemCountAggregateOutputType> | number
          }
        }
      }
      QualityControl: {
        payload: Prisma.$QualityControlPayload<ExtArgs>
        fields: Prisma.QualityControlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QualityControlFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QualityControlFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlPayload>
          }
          findFirst: {
            args: Prisma.QualityControlFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QualityControlFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlPayload>
          }
          findMany: {
            args: Prisma.QualityControlFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlPayload>[]
          }
          create: {
            args: Prisma.QualityControlCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlPayload>
          }
          createMany: {
            args: Prisma.QualityControlCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QualityControlCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlPayload>[]
          }
          delete: {
            args: Prisma.QualityControlDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlPayload>
          }
          update: {
            args: Prisma.QualityControlUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlPayload>
          }
          deleteMany: {
            args: Prisma.QualityControlDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QualityControlUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QualityControlUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlPayload>[]
          }
          upsert: {
            args: Prisma.QualityControlUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlPayload>
          }
          aggregate: {
            args: Prisma.QualityControlAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQualityControl>
          }
          groupBy: {
            args: Prisma.QualityControlGroupByArgs<ExtArgs>
            result: $Utils.Optional<QualityControlGroupByOutputType>[]
          }
          count: {
            args: Prisma.QualityControlCountArgs<ExtArgs>
            result: $Utils.Optional<QualityControlCountAggregateOutputType> | number
          }
        }
      }
      QualityControlItem: {
        payload: Prisma.$QualityControlItemPayload<ExtArgs>
        fields: Prisma.QualityControlItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QualityControlItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QualityControlItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlItemPayload>
          }
          findFirst: {
            args: Prisma.QualityControlItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QualityControlItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlItemPayload>
          }
          findMany: {
            args: Prisma.QualityControlItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlItemPayload>[]
          }
          create: {
            args: Prisma.QualityControlItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlItemPayload>
          }
          createMany: {
            args: Prisma.QualityControlItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QualityControlItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlItemPayload>[]
          }
          delete: {
            args: Prisma.QualityControlItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlItemPayload>
          }
          update: {
            args: Prisma.QualityControlItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlItemPayload>
          }
          deleteMany: {
            args: Prisma.QualityControlItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QualityControlItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QualityControlItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlItemPayload>[]
          }
          upsert: {
            args: Prisma.QualityControlItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityControlItemPayload>
          }
          aggregate: {
            args: Prisma.QualityControlItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQualityControlItem>
          }
          groupBy: {
            args: Prisma.QualityControlItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<QualityControlItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.QualityControlItemCountArgs<ExtArgs>
            result: $Utils.Optional<QualityControlItemCountAggregateOutputType> | number
          }
        }
      }
      Transfer: {
        payload: Prisma.$TransferPayload<ExtArgs>
        fields: Prisma.TransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findFirst: {
            args: Prisma.TransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findMany: {
            args: Prisma.TransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          create: {
            args: Prisma.TransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          createMany: {
            args: Prisma.TransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          delete: {
            args: Prisma.TransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          update: {
            args: Prisma.TransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          deleteMany: {
            args: Prisma.TransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          upsert: {
            args: Prisma.TransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          aggregate: {
            args: Prisma.TransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransfer>
          }
          groupBy: {
            args: Prisma.TransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferCountArgs<ExtArgs>
            result: $Utils.Optional<TransferCountAggregateOutputType> | number
          }
        }
      }
      TransferDocument: {
        payload: Prisma.$TransferDocumentPayload<ExtArgs>
        fields: Prisma.TransferDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDocumentPayload>
          }
          findFirst: {
            args: Prisma.TransferDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDocumentPayload>
          }
          findMany: {
            args: Prisma.TransferDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDocumentPayload>[]
          }
          create: {
            args: Prisma.TransferDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDocumentPayload>
          }
          createMany: {
            args: Prisma.TransferDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDocumentPayload>[]
          }
          delete: {
            args: Prisma.TransferDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDocumentPayload>
          }
          update: {
            args: Prisma.TransferDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDocumentPayload>
          }
          deleteMany: {
            args: Prisma.TransferDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransferDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDocumentPayload>[]
          }
          upsert: {
            args: Prisma.TransferDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferDocumentPayload>
          }
          aggregate: {
            args: Prisma.TransferDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransferDocument>
          }
          groupBy: {
            args: Prisma.TransferDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<TransferDocumentCountAggregateOutputType> | number
          }
        }
      }
      TransferItem: {
        payload: Prisma.$TransferItemPayload<ExtArgs>
        fields: Prisma.TransferItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          findFirst: {
            args: Prisma.TransferItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          findMany: {
            args: Prisma.TransferItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>[]
          }
          create: {
            args: Prisma.TransferItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          createMany: {
            args: Prisma.TransferItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>[]
          }
          delete: {
            args: Prisma.TransferItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          update: {
            args: Prisma.TransferItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          deleteMany: {
            args: Prisma.TransferItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransferItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>[]
          }
          upsert: {
            args: Prisma.TransferItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferItemPayload>
          }
          aggregate: {
            args: Prisma.TransferItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransferItem>
          }
          groupBy: {
            args: Prisma.TransferItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferItemCountArgs<ExtArgs>
            result: $Utils.Optional<TransferItemCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      LoyaltyProgram: {
        payload: Prisma.$LoyaltyProgramPayload<ExtArgs>
        fields: Prisma.LoyaltyProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoyaltyProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoyaltyProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>
          }
          findFirst: {
            args: Prisma.LoyaltyProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoyaltyProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>
          }
          findMany: {
            args: Prisma.LoyaltyProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>[]
          }
          create: {
            args: Prisma.LoyaltyProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>
          }
          createMany: {
            args: Prisma.LoyaltyProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoyaltyProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>[]
          }
          delete: {
            args: Prisma.LoyaltyProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>
          }
          update: {
            args: Prisma.LoyaltyProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>
          }
          deleteMany: {
            args: Prisma.LoyaltyProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoyaltyProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoyaltyProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>[]
          }
          upsert: {
            args: Prisma.LoyaltyProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramPayload>
          }
          aggregate: {
            args: Prisma.LoyaltyProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoyaltyProgram>
          }
          groupBy: {
            args: Prisma.LoyaltyProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoyaltyProgramCountArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyProgramCountAggregateOutputType> | number
          }
        }
      }
      LoyaltyProgramTier: {
        payload: Prisma.$LoyaltyProgramTierPayload<ExtArgs>
        fields: Prisma.LoyaltyProgramTierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoyaltyProgramTierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoyaltyProgramTierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>
          }
          findFirst: {
            args: Prisma.LoyaltyProgramTierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoyaltyProgramTierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>
          }
          findMany: {
            args: Prisma.LoyaltyProgramTierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>[]
          }
          create: {
            args: Prisma.LoyaltyProgramTierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>
          }
          createMany: {
            args: Prisma.LoyaltyProgramTierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoyaltyProgramTierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>[]
          }
          delete: {
            args: Prisma.LoyaltyProgramTierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>
          }
          update: {
            args: Prisma.LoyaltyProgramTierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>
          }
          deleteMany: {
            args: Prisma.LoyaltyProgramTierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoyaltyProgramTierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoyaltyProgramTierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>[]
          }
          upsert: {
            args: Prisma.LoyaltyProgramTierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyProgramTierPayload>
          }
          aggregate: {
            args: Prisma.LoyaltyProgramTierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoyaltyProgramTier>
          }
          groupBy: {
            args: Prisma.LoyaltyProgramTierGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyProgramTierGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoyaltyProgramTierCountArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyProgramTierCountAggregateOutputType> | number
          }
        }
      }
      LoyaltyTransaction: {
        payload: Prisma.$LoyaltyTransactionPayload<ExtArgs>
        fields: Prisma.LoyaltyTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoyaltyTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
          }
          findFirst: {
            args: Prisma.LoyaltyTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoyaltyTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
          }
          findMany: {
            args: Prisma.LoyaltyTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>[]
          }
          create: {
            args: Prisma.LoyaltyTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
          }
          createMany: {
            args: Prisma.LoyaltyTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoyaltyTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>[]
          }
          delete: {
            args: Prisma.LoyaltyTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
          }
          update: {
            args: Prisma.LoyaltyTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
          }
          deleteMany: {
            args: Prisma.LoyaltyTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoyaltyTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoyaltyTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>[]
          }
          upsert: {
            args: Prisma.LoyaltyTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoyaltyTransactionPayload>
          }
          aggregate: {
            args: Prisma.LoyaltyTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoyaltyTransaction>
          }
          groupBy: {
            args: Prisma.LoyaltyTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoyaltyTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<LoyaltyTransactionCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Audit: {
        payload: Prisma.$AuditPayload<ExtArgs>
        fields: Prisma.AuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          findFirst: {
            args: Prisma.AuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          findMany: {
            args: Prisma.AuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>[]
          }
          create: {
            args: Prisma.AuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          createMany: {
            args: Prisma.AuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>[]
          }
          delete: {
            args: Prisma.AuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          update: {
            args: Prisma.AuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          deleteMany: {
            args: Prisma.AuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>[]
          }
          upsert: {
            args: Prisma.AuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditPayload>
          }
          aggregate: {
            args: Prisma.AuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudit>
          }
          groupBy: {
            args: Prisma.AuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditCountArgs<ExtArgs>
            result: $Utils.Optional<AuditCountAggregateOutputType> | number
          }
        }
      }
      AuditItem: {
        payload: Prisma.$AuditItemPayload<ExtArgs>
        fields: Prisma.AuditItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>
          }
          findFirst: {
            args: Prisma.AuditItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>
          }
          findMany: {
            args: Prisma.AuditItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>[]
          }
          create: {
            args: Prisma.AuditItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>
          }
          createMany: {
            args: Prisma.AuditItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>[]
          }
          delete: {
            args: Prisma.AuditItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>
          }
          update: {
            args: Prisma.AuditItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>
          }
          deleteMany: {
            args: Prisma.AuditItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>[]
          }
          upsert: {
            args: Prisma.AuditItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditItemPayload>
          }
          aggregate: {
            args: Prisma.AuditItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditItem>
          }
          groupBy: {
            args: Prisma.AuditItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditItemCountArgs<ExtArgs>
            result: $Utils.Optional<AuditItemCountAggregateOutputType> | number
          }
        }
      }
      AuditAssignment: {
        payload: Prisma.$AuditAssignmentPayload<ExtArgs>
        fields: Prisma.AuditAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>
          }
          findFirst: {
            args: Prisma.AuditAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>
          }
          findMany: {
            args: Prisma.AuditAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>[]
          }
          create: {
            args: Prisma.AuditAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>
          }
          createMany: {
            args: Prisma.AuditAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>[]
          }
          delete: {
            args: Prisma.AuditAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>
          }
          update: {
            args: Prisma.AuditAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AuditAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.AuditAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAssignmentPayload>
          }
          aggregate: {
            args: Prisma.AuditAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditAssignment>
          }
          groupBy: {
            args: Prisma.AuditAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AuditAssignmentCountAggregateOutputType> | number
          }
        }
      }
      TaxRate: {
        payload: Prisma.$TaxRatePayload<ExtArgs>
        fields: Prisma.TaxRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          findFirst: {
            args: Prisma.TaxRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          findMany: {
            args: Prisma.TaxRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>[]
          }
          create: {
            args: Prisma.TaxRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          createMany: {
            args: Prisma.TaxRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>[]
          }
          delete: {
            args: Prisma.TaxRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          update: {
            args: Prisma.TaxRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          deleteMany: {
            args: Prisma.TaxRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaxRateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>[]
          }
          upsert: {
            args: Prisma.TaxRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          aggregate: {
            args: Prisma.TaxRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxRate>
          }
          groupBy: {
            args: Prisma.TaxRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxRateCountArgs<ExtArgs>
            result: $Utils.Optional<TaxRateCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    warehouse?: WarehouseOmit
    warehouseZone?: WarehouseZoneOmit
    warehouseAisle?: WarehouseAisleOmit
    warehouseShelf?: WarehouseShelfOmit
    warehouseBin?: WarehouseBinOmit
    warehouseStaff?: WarehouseStaffOmit
    store?: StoreOmit
    storeStaff?: StoreStaffOmit
    supplier?: SupplierOmit
    supplierContract?: SupplierContractOmit
    supplierPerformanceMetric?: SupplierPerformanceMetricOmit
    purchaseOrder?: PurchaseOrderOmit
    purchaseOrderItem?: PurchaseOrderItemOmit
    product?: ProductOmit
    category?: CategoryOmit
    categoryPriceRule?: CategoryPriceRuleOmit
    inventoryItem?: InventoryItemOmit
    sale?: SaleOmit
    saleItem?: SaleItemOmit
    payment?: PaymentOmit
    return?: ReturnOmit
    returnItem?: ReturnItemOmit
    qualityControl?: QualityControlOmit
    qualityControlItem?: QualityControlItemOmit
    transfer?: TransferOmit
    transferDocument?: TransferDocumentOmit
    transferItem?: TransferItemOmit
    customer?: CustomerOmit
    address?: AddressOmit
    loyaltyProgram?: LoyaltyProgramOmit
    loyaltyProgramTier?: LoyaltyProgramTierOmit
    loyaltyTransaction?: LoyaltyTransactionOmit
    auditLog?: AuditLogOmit
    audit?: AuditOmit
    auditItem?: AuditItemOmit
    auditAssignment?: AuditAssignmentOmit
    taxRate?: TaxRateOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    createdSales: number
    processedReturns: number
    inspectedQCs: number
    createdAudits: number
    auditAssignments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    createdSales?: boolean | UserCountOutputTypeCountCreatedSalesArgs
    processedReturns?: boolean | UserCountOutputTypeCountProcessedReturnsArgs
    inspectedQCs?: boolean | UserCountOutputTypeCountInspectedQCsArgs
    createdAudits?: boolean | UserCountOutputTypeCountCreatedAuditsArgs
    auditAssignments?: boolean | UserCountOutputTypeCountAuditAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessedReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInspectedQCsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QualityControlWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditAssignmentWhereInput
  }


  /**
   * Count Type WarehouseCountOutputType
   */

  export type WarehouseCountOutputType = {
    zones: number
    inventoryItems: number
    staff: number
    transfersFrom: number
    transfersTo: number
    purchaseOrders: number
    qualityControls: number
    audits: number
  }

  export type WarehouseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zones?: boolean | WarehouseCountOutputTypeCountZonesArgs
    inventoryItems?: boolean | WarehouseCountOutputTypeCountInventoryItemsArgs
    staff?: boolean | WarehouseCountOutputTypeCountStaffArgs
    transfersFrom?: boolean | WarehouseCountOutputTypeCountTransfersFromArgs
    transfersTo?: boolean | WarehouseCountOutputTypeCountTransfersToArgs
    purchaseOrders?: boolean | WarehouseCountOutputTypeCountPurchaseOrdersArgs
    qualityControls?: boolean | WarehouseCountOutputTypeCountQualityControlsArgs
    audits?: boolean | WarehouseCountOutputTypeCountAuditsArgs
  }

  // Custom InputTypes
  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseCountOutputType
     */
    select?: WarehouseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseZoneWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseStaffWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountTransfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountTransfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountQualityControlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QualityControlWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditWhereInput
  }


  /**
   * Count Type WarehouseZoneCountOutputType
   */

  export type WarehouseZoneCountOutputType = {
    aisles: number
  }

  export type WarehouseZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aisles?: boolean | WarehouseZoneCountOutputTypeCountAislesArgs
  }

  // Custom InputTypes
  /**
   * WarehouseZoneCountOutputType without action
   */
  export type WarehouseZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZoneCountOutputType
     */
    select?: WarehouseZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseZoneCountOutputType without action
   */
  export type WarehouseZoneCountOutputTypeCountAislesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseAisleWhereInput
  }


  /**
   * Count Type WarehouseAisleCountOutputType
   */

  export type WarehouseAisleCountOutputType = {
    shelves: number
  }

  export type WarehouseAisleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shelves?: boolean | WarehouseAisleCountOutputTypeCountShelvesArgs
  }

  // Custom InputTypes
  /**
   * WarehouseAisleCountOutputType without action
   */
  export type WarehouseAisleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisleCountOutputType
     */
    select?: WarehouseAisleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseAisleCountOutputType without action
   */
  export type WarehouseAisleCountOutputTypeCountShelvesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseShelfWhereInput
  }


  /**
   * Count Type WarehouseShelfCountOutputType
   */

  export type WarehouseShelfCountOutputType = {
    bins: number
  }

  export type WarehouseShelfCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bins?: boolean | WarehouseShelfCountOutputTypeCountBinsArgs
  }

  // Custom InputTypes
  /**
   * WarehouseShelfCountOutputType without action
   */
  export type WarehouseShelfCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelfCountOutputType
     */
    select?: WarehouseShelfCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseShelfCountOutputType without action
   */
  export type WarehouseShelfCountOutputTypeCountBinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseBinWhereInput
  }


  /**
   * Count Type WarehouseBinCountOutputType
   */

  export type WarehouseBinCountOutputType = {
    inventoryItems: number
  }

  export type WarehouseBinCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | WarehouseBinCountOutputTypeCountInventoryItemsArgs
  }

  // Custom InputTypes
  /**
   * WarehouseBinCountOutputType without action
   */
  export type WarehouseBinCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBinCountOutputType
     */
    select?: WarehouseBinCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseBinCountOutputType without action
   */
  export type WarehouseBinCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }


  /**
   * Count Type StoreCountOutputType
   */

  export type StoreCountOutputType = {
    inventoryItems: number
    sales: number
    returns: number
    staff: number
    transfersFrom: number
    transfersTo: number
  }

  export type StoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | StoreCountOutputTypeCountInventoryItemsArgs
    sales?: boolean | StoreCountOutputTypeCountSalesArgs
    returns?: boolean | StoreCountOutputTypeCountReturnsArgs
    staff?: boolean | StoreCountOutputTypeCountStaffArgs
    transfersFrom?: boolean | StoreCountOutputTypeCountTransfersFromArgs
    transfersTo?: boolean | StoreCountOutputTypeCountTransfersToArgs
  }

  // Custom InputTypes
  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCountOutputType
     */
    select?: StoreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreStaffWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountTransfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountTransfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    products: number
    contracts: number
    purchaseOrders: number
    performanceMetrics: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | SupplierCountOutputTypeCountProductsArgs
    contracts?: boolean | SupplierCountOutputTypeCountContractsArgs
    purchaseOrders?: boolean | SupplierCountOutputTypeCountPurchaseOrdersArgs
    performanceMetrics?: boolean | SupplierCountOutputTypeCountPerformanceMetricsArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierContractWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPerformanceMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierPerformanceMetricWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    items: number
    qualityControls: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseOrderCountOutputTypeCountItemsArgs
    qualityControls?: boolean | PurchaseOrderCountOutputTypeCountQualityControlsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountQualityControlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QualityControlWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    purchaseOrderItems: number
    qualityControlItems: number
    returnItems: number
    inventoryItems: number
    saleItems: number
    transferItems: number
    auditItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrderItems?: boolean | ProductCountOutputTypeCountPurchaseOrderItemsArgs
    qualityControlItems?: boolean | ProductCountOutputTypeCountQualityControlItemsArgs
    returnItems?: boolean | ProductCountOutputTypeCountReturnItemsArgs
    inventoryItems?: boolean | ProductCountOutputTypeCountInventoryItemsArgs
    saleItems?: boolean | ProductCountOutputTypeCountSaleItemsArgs
    transferItems?: boolean | ProductCountOutputTypeCountTransferItemsArgs
    auditItems?: boolean | ProductCountOutputTypeCountAuditItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountQualityControlItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QualityControlItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSaleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTransferItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountAuditItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditItemWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
    priceRules: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
    priceRules?: boolean | CategoryCountOutputTypeCountPriceRulesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountPriceRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryPriceRuleWhereInput
  }


  /**
   * Count Type InventoryItemCountOutputType
   */

  export type InventoryItemCountOutputType = {
    saleItems: number
    auditItems: number
  }

  export type InventoryItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleItems?: boolean | InventoryItemCountOutputTypeCountSaleItemsArgs
    auditItems?: boolean | InventoryItemCountOutputTypeCountAuditItemsArgs
  }

  // Custom InputTypes
  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItemCountOutputType
     */
    select?: InventoryItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountSaleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountAuditItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditItemWhereInput
  }


  /**
   * Count Type SaleCountOutputType
   */

  export type SaleCountOutputType = {
    items: number
    payments: number
    returns: number
  }

  export type SaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SaleCountOutputTypeCountItemsArgs
    payments?: boolean | SaleCountOutputTypeCountPaymentsArgs
    returns?: boolean | SaleCountOutputTypeCountReturnsArgs
  }

  // Custom InputTypes
  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleCountOutputType
     */
    select?: SaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnWhereInput
  }


  /**
   * Count Type SaleItemCountOutputType
   */

  export type SaleItemCountOutputType = {
    returnItems: number
  }

  export type SaleItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    returnItems?: boolean | SaleItemCountOutputTypeCountReturnItemsArgs
  }

  // Custom InputTypes
  /**
   * SaleItemCountOutputType without action
   */
  export type SaleItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItemCountOutputType
     */
    select?: SaleItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaleItemCountOutputType without action
   */
  export type SaleItemCountOutputTypeCountReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnItemWhereInput
  }


  /**
   * Count Type ReturnCountOutputType
   */

  export type ReturnCountOutputType = {
    items: number
    qualityControls: number
  }

  export type ReturnCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ReturnCountOutputTypeCountItemsArgs
    qualityControls?: boolean | ReturnCountOutputTypeCountQualityControlsArgs
  }

  // Custom InputTypes
  /**
   * ReturnCountOutputType without action
   */
  export type ReturnCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnCountOutputType
     */
    select?: ReturnCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReturnCountOutputType without action
   */
  export type ReturnCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnItemWhereInput
  }

  /**
   * ReturnCountOutputType without action
   */
  export type ReturnCountOutputTypeCountQualityControlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QualityControlWhereInput
  }


  /**
   * Count Type QualityControlCountOutputType
   */

  export type QualityControlCountOutputType = {
    items: number
  }

  export type QualityControlCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | QualityControlCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * QualityControlCountOutputType without action
   */
  export type QualityControlCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControlCountOutputType
     */
    select?: QualityControlCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QualityControlCountOutputType without action
   */
  export type QualityControlCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QualityControlItemWhereInput
  }


  /**
   * Count Type TransferCountOutputType
   */

  export type TransferCountOutputType = {
    items: number
    documents: number
  }

  export type TransferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TransferCountOutputTypeCountItemsArgs
    documents?: boolean | TransferCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * TransferCountOutputType without action
   */
  export type TransferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferCountOutputType
     */
    select?: TransferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransferCountOutputType without action
   */
  export type TransferCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferItemWhereInput
  }

  /**
   * TransferCountOutputType without action
   */
  export type TransferCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferDocumentWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    sales: number
    returns: number
    addresses: number
    loyaltyTransactions: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | CustomerCountOutputTypeCountSalesArgs
    returns?: boolean | CustomerCountOutputTypeCountReturnsArgs
    addresses?: boolean | CustomerCountOutputTypeCountAddressesArgs
    loyaltyTransactions?: boolean | CustomerCountOutputTypeCountLoyaltyTransactionsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountLoyaltyTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyTransactionWhereInput
  }


  /**
   * Count Type LoyaltyProgramCountOutputType
   */

  export type LoyaltyProgramCountOutputType = {
    tiers: number
    transactions: number
  }

  export type LoyaltyProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tiers?: boolean | LoyaltyProgramCountOutputTypeCountTiersArgs
    transactions?: boolean | LoyaltyProgramCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * LoyaltyProgramCountOutputType without action
   */
  export type LoyaltyProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramCountOutputType
     */
    select?: LoyaltyProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LoyaltyProgramCountOutputType without action
   */
  export type LoyaltyProgramCountOutputTypeCountTiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyProgramTierWhereInput
  }

  /**
   * LoyaltyProgramCountOutputType without action
   */
  export type LoyaltyProgramCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyTransactionWhereInput
  }


  /**
   * Count Type AuditCountOutputType
   */

  export type AuditCountOutputType = {
    items: number
    assignments: number
  }

  export type AuditCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | AuditCountOutputTypeCountItemsArgs
    assignments?: boolean | AuditCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * AuditCountOutputType without action
   */
  export type AuditCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditCountOutputType
     */
    select?: AuditCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuditCountOutputType without action
   */
  export type AuditCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditItemWhereInput
  }

  /**
   * AuditCountOutputType without action
   */
  export type AuditCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditAssignmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    image: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    image: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    password: number
    image: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    emailVerified: Date | null
    password: string | null
    image: string | null
    role: $Enums.UserRole
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    createdSales?: boolean | User$createdSalesArgs<ExtArgs>
    processedReturns?: boolean | User$processedReturnsArgs<ExtArgs>
    inspectedQCs?: boolean | User$inspectedQCsArgs<ExtArgs>
    warehouseStaff?: boolean | User$warehouseStaffArgs<ExtArgs>
    storeStaff?: boolean | User$storeStaffArgs<ExtArgs>
    createdAudits?: boolean | User$createdAuditsArgs<ExtArgs>
    auditAssignments?: boolean | User$auditAssignmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "password" | "image" | "role" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    createdSales?: boolean | User$createdSalesArgs<ExtArgs>
    processedReturns?: boolean | User$processedReturnsArgs<ExtArgs>
    inspectedQCs?: boolean | User$inspectedQCsArgs<ExtArgs>
    warehouseStaff?: boolean | User$warehouseStaffArgs<ExtArgs>
    storeStaff?: boolean | User$storeStaffArgs<ExtArgs>
    createdAudits?: boolean | User$createdAuditsArgs<ExtArgs>
    auditAssignments?: boolean | User$auditAssignmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      createdSales: Prisma.$SalePayload<ExtArgs>[]
      processedReturns: Prisma.$ReturnPayload<ExtArgs>[]
      inspectedQCs: Prisma.$QualityControlPayload<ExtArgs>[]
      warehouseStaff: Prisma.$WarehouseStaffPayload<ExtArgs> | null
      storeStaff: Prisma.$StoreStaffPayload<ExtArgs> | null
      createdAudits: Prisma.$AuditPayload<ExtArgs>[]
      auditAssignments: Prisma.$AuditAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      emailVerified: Date | null
      password: string | null
      image: string | null
      role: $Enums.UserRole
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdSales<T extends User$createdSalesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdSalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processedReturns<T extends User$processedReturnsArgs<ExtArgs> = {}>(args?: Subset<T, User$processedReturnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inspectedQCs<T extends User$inspectedQCsArgs<ExtArgs> = {}>(args?: Subset<T, User$inspectedQCsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    warehouseStaff<T extends User$warehouseStaffArgs<ExtArgs> = {}>(args?: Subset<T, User$warehouseStaffArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    storeStaff<T extends User$storeStaffArgs<ExtArgs> = {}>(args?: Subset<T, User$storeStaffArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdAudits<T extends User$createdAuditsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditAssignments<T extends User$auditAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly password: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.createdSales
   */
  export type User$createdSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * User.processedReturns
   */
  export type User$processedReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnInclude<ExtArgs> | null
    where?: ReturnWhereInput
    orderBy?: ReturnOrderByWithRelationInput | ReturnOrderByWithRelationInput[]
    cursor?: ReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnScalarFieldEnum | ReturnScalarFieldEnum[]
  }

  /**
   * User.inspectedQCs
   */
  export type User$inspectedQCsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlInclude<ExtArgs> | null
    where?: QualityControlWhereInput
    orderBy?: QualityControlOrderByWithRelationInput | QualityControlOrderByWithRelationInput[]
    cursor?: QualityControlWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QualityControlScalarFieldEnum | QualityControlScalarFieldEnum[]
  }

  /**
   * User.warehouseStaff
   */
  export type User$warehouseStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    where?: WarehouseStaffWhereInput
  }

  /**
   * User.storeStaff
   */
  export type User$storeStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    where?: StoreStaffWhereInput
  }

  /**
   * User.createdAudits
   */
  export type User$createdAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    where?: AuditWhereInput
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    cursor?: AuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * User.auditAssignments
   */
  export type User$auditAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    where?: AuditAssignmentWhereInput
    orderBy?: AuditAssignmentOrderByWithRelationInput | AuditAssignmentOrderByWithRelationInput[]
    cursor?: AuditAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditAssignmentScalarFieldEnum | AuditAssignmentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Warehouse
   */

  export type AggregateWarehouse = {
    _count: WarehouseCountAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  export type WarehouseMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    address: string | null
    contactPerson: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    address: string | null
    contactPerson: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseCountAggregateOutputType = {
    id: number
    name: number
    code: number
    address: number
    contactPerson: number
    phone: number
    email: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    address?: true
    contactPerson?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    address?: true
    contactPerson?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    address?: true
    contactPerson?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouse to aggregate.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Warehouses
    **/
    _count?: true | WarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMaxAggregateInputType
  }

  export type GetWarehouseAggregateType<T extends WarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse[P]>
      : GetScalarType<T[P], AggregateWarehouse[P]>
  }




  export type WarehouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithAggregationInput | WarehouseOrderByWithAggregationInput[]
    by: WarehouseScalarFieldEnum[] | WarehouseScalarFieldEnum
    having?: WarehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseCountAggregateInputType | true
    _min?: WarehouseMinAggregateInputType
    _max?: WarehouseMaxAggregateInputType
  }

  export type WarehouseGroupByOutputType = {
    id: string
    name: string
    code: string
    address: string | null
    contactPerson: string | null
    phone: string | null
    email: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: WarehouseCountAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  type GetWarehouseGroupByPayload<T extends WarehouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    contactPerson?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zones?: boolean | Warehouse$zonesArgs<ExtArgs>
    inventoryItems?: boolean | Warehouse$inventoryItemsArgs<ExtArgs>
    staff?: boolean | Warehouse$staffArgs<ExtArgs>
    transfersFrom?: boolean | Warehouse$transfersFromArgs<ExtArgs>
    transfersTo?: boolean | Warehouse$transfersToArgs<ExtArgs>
    purchaseOrders?: boolean | Warehouse$purchaseOrdersArgs<ExtArgs>
    qualityControls?: boolean | Warehouse$qualityControlsArgs<ExtArgs>
    audits?: boolean | Warehouse$auditsArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    contactPerson?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    contactPerson?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    contactPerson?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "address" | "contactPerson" | "phone" | "email" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouse"]>
  export type WarehouseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zones?: boolean | Warehouse$zonesArgs<ExtArgs>
    inventoryItems?: boolean | Warehouse$inventoryItemsArgs<ExtArgs>
    staff?: boolean | Warehouse$staffArgs<ExtArgs>
    transfersFrom?: boolean | Warehouse$transfersFromArgs<ExtArgs>
    transfersTo?: boolean | Warehouse$transfersToArgs<ExtArgs>
    purchaseOrders?: boolean | Warehouse$purchaseOrdersArgs<ExtArgs>
    qualityControls?: boolean | Warehouse$qualityControlsArgs<ExtArgs>
    audits?: boolean | Warehouse$auditsArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WarehouseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WarehousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Warehouse"
    objects: {
      zones: Prisma.$WarehouseZonePayload<ExtArgs>[]
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      staff: Prisma.$WarehouseStaffPayload<ExtArgs>[]
      transfersFrom: Prisma.$TransferPayload<ExtArgs>[]
      transfersTo: Prisma.$TransferPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      qualityControls: Prisma.$QualityControlPayload<ExtArgs>[]
      audits: Prisma.$AuditPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      address: string | null
      contactPerson: string | null
      phone: string | null
      email: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouse"]>
    composites: {}
  }

  type WarehouseGetPayload<S extends boolean | null | undefined | WarehouseDefaultArgs> = $Result.GetResult<Prisma.$WarehousePayload, S>

  type WarehouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseCountAggregateInputType | true
    }

  export interface WarehouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Warehouse'], meta: { name: 'Warehouse' } }
    /**
     * Find zero or one Warehouse that matches the filter.
     * @param {WarehouseFindUniqueArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseFindUniqueArgs>(args: SelectSubset<T, WarehouseFindUniqueArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Warehouse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseFindUniqueOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseFindFirstArgs>(args?: SelectSubset<T, WarehouseFindFirstArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouse.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseFindManyArgs>(args?: SelectSubset<T, WarehouseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Warehouse.
     * @param {WarehouseCreateArgs} args - Arguments to create a Warehouse.
     * @example
     * // Create one Warehouse
     * const Warehouse = await prisma.warehouse.create({
     *   data: {
     *     // ... data to create a Warehouse
     *   }
     * })
     * 
     */
    create<T extends WarehouseCreateArgs>(args: SelectSubset<T, WarehouseCreateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Warehouses.
     * @param {WarehouseCreateManyArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseCreateManyArgs>(args?: SelectSubset<T, WarehouseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Warehouses and returns the data saved in the database.
     * @param {WarehouseCreateManyAndReturnArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Warehouse.
     * @param {WarehouseDeleteArgs} args - Arguments to delete one Warehouse.
     * @example
     * // Delete one Warehouse
     * const Warehouse = await prisma.warehouse.delete({
     *   where: {
     *     // ... filter to delete one Warehouse
     *   }
     * })
     * 
     */
    delete<T extends WarehouseDeleteArgs>(args: SelectSubset<T, WarehouseDeleteArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Warehouse.
     * @param {WarehouseUpdateArgs} args - Arguments to update one Warehouse.
     * @example
     * // Update one Warehouse
     * const warehouse = await prisma.warehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseUpdateArgs>(args: SelectSubset<T, WarehouseUpdateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Warehouses.
     * @param {WarehouseDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseDeleteManyArgs>(args?: SelectSubset<T, WarehouseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseUpdateManyArgs>(args: SelectSubset<T, WarehouseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses and returns the data updated in the database.
     * @param {WarehouseUpdateManyAndReturnArgs} args - Arguments to update many Warehouses.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Warehouse.
     * @param {WarehouseUpsertArgs} args - Arguments to update or create a Warehouse.
     * @example
     * // Update or create a Warehouse
     * const warehouse = await prisma.warehouse.upsert({
     *   create: {
     *     // ... data to create a Warehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseUpsertArgs>(args: SelectSubset<T, WarehouseUpsertArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouse.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends WarehouseCountArgs>(
      args?: Subset<T, WarehouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAggregateArgs>(args: Subset<T, WarehouseAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAggregateType<T>>

    /**
     * Group by Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Warehouse model
   */
  readonly fields: WarehouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Warehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zones<T extends Warehouse$zonesArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryItems<T extends Warehouse$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staff<T extends Warehouse$staffArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfersFrom<T extends Warehouse$transfersFromArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$transfersFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfersTo<T extends Warehouse$transfersToArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$transfersToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends Warehouse$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qualityControls<T extends Warehouse$qualityControlsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$qualityControlsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    audits<T extends Warehouse$auditsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$auditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Warehouse model
   */
  interface WarehouseFieldRefs {
    readonly id: FieldRef<"Warehouse", 'String'>
    readonly name: FieldRef<"Warehouse", 'String'>
    readonly code: FieldRef<"Warehouse", 'String'>
    readonly address: FieldRef<"Warehouse", 'String'>
    readonly contactPerson: FieldRef<"Warehouse", 'String'>
    readonly phone: FieldRef<"Warehouse", 'String'>
    readonly email: FieldRef<"Warehouse", 'String'>
    readonly isActive: FieldRef<"Warehouse", 'Boolean'>
    readonly createdAt: FieldRef<"Warehouse", 'DateTime'>
    readonly updatedAt: FieldRef<"Warehouse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Warehouse findUnique
   */
  export type WarehouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findUniqueOrThrow
   */
  export type WarehouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findFirst
   */
  export type WarehouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findFirstOrThrow
   */
  export type WarehouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findMany
   */
  export type WarehouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse create
   */
  export type WarehouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to create a Warehouse.
     */
    data: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
  }

  /**
   * Warehouse createMany
   */
  export type WarehouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse createManyAndReturn
   */
  export type WarehouseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse update
   */
  export type WarehouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to update a Warehouse.
     */
    data: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
    /**
     * Choose, which Warehouse to update.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse updateMany
   */
  export type WarehouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
  }

  /**
   * Warehouse updateManyAndReturn
   */
  export type WarehouseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
  }

  /**
   * Warehouse upsert
   */
  export type WarehouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The filter to search for the Warehouse to update in case it exists.
     */
    where: WarehouseWhereUniqueInput
    /**
     * In case the Warehouse found by the `where` argument doesn't exist, create a new Warehouse with this data.
     */
    create: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
    /**
     * In case the Warehouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
  }

  /**
   * Warehouse delete
   */
  export type WarehouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter which Warehouse to delete.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse deleteMany
   */
  export type WarehouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouses to delete
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to delete.
     */
    limit?: number
  }

  /**
   * Warehouse.zones
   */
  export type Warehouse$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    where?: WarehouseZoneWhereInput
    orderBy?: WarehouseZoneOrderByWithRelationInput | WarehouseZoneOrderByWithRelationInput[]
    cursor?: WarehouseZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseZoneScalarFieldEnum | WarehouseZoneScalarFieldEnum[]
  }

  /**
   * Warehouse.inventoryItems
   */
  export type Warehouse$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Warehouse.staff
   */
  export type Warehouse$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    where?: WarehouseStaffWhereInput
    orderBy?: WarehouseStaffOrderByWithRelationInput | WarehouseStaffOrderByWithRelationInput[]
    cursor?: WarehouseStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseStaffScalarFieldEnum | WarehouseStaffScalarFieldEnum[]
  }

  /**
   * Warehouse.transfersFrom
   */
  export type Warehouse$transfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Warehouse.transfersTo
   */
  export type Warehouse$transfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Warehouse.purchaseOrders
   */
  export type Warehouse$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Warehouse.qualityControls
   */
  export type Warehouse$qualityControlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlInclude<ExtArgs> | null
    where?: QualityControlWhereInput
    orderBy?: QualityControlOrderByWithRelationInput | QualityControlOrderByWithRelationInput[]
    cursor?: QualityControlWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QualityControlScalarFieldEnum | QualityControlScalarFieldEnum[]
  }

  /**
   * Warehouse.audits
   */
  export type Warehouse$auditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    where?: AuditWhereInput
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    cursor?: AuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Warehouse without action
   */
  export type WarehouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
  }


  /**
   * Model WarehouseZone
   */

  export type AggregateWarehouseZone = {
    _count: WarehouseZoneCountAggregateOutputType | null
    _min: WarehouseZoneMinAggregateOutputType | null
    _max: WarehouseZoneMaxAggregateOutputType | null
  }

  export type WarehouseZoneMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    warehouseId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseZoneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    warehouseId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseZoneCountAggregateOutputType = {
    id: number
    name: number
    code: number
    warehouseId: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseZoneMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    warehouseId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseZoneMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    warehouseId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseZoneCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    warehouseId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseZone to aggregate.
     */
    where?: WarehouseZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseZones to fetch.
     */
    orderBy?: WarehouseZoneOrderByWithRelationInput | WarehouseZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarehouseZones
    **/
    _count?: true | WarehouseZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseZoneMaxAggregateInputType
  }

  export type GetWarehouseZoneAggregateType<T extends WarehouseZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouseZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouseZone[P]>
      : GetScalarType<T[P], AggregateWarehouseZone[P]>
  }




  export type WarehouseZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseZoneWhereInput
    orderBy?: WarehouseZoneOrderByWithAggregationInput | WarehouseZoneOrderByWithAggregationInput[]
    by: WarehouseZoneScalarFieldEnum[] | WarehouseZoneScalarFieldEnum
    having?: WarehouseZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseZoneCountAggregateInputType | true
    _min?: WarehouseZoneMinAggregateInputType
    _max?: WarehouseZoneMaxAggregateInputType
  }

  export type WarehouseZoneGroupByOutputType = {
    id: string
    name: string
    code: string
    warehouseId: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: WarehouseZoneCountAggregateOutputType | null
    _min: WarehouseZoneMinAggregateOutputType | null
    _max: WarehouseZoneMaxAggregateOutputType | null
  }

  type GetWarehouseZoneGroupByPayload<T extends WarehouseZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseZoneGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseZoneGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    warehouseId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    aisles?: boolean | WarehouseZone$aislesArgs<ExtArgs>
    _count?: boolean | WarehouseZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseZone"]>

  export type WarehouseZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    warehouseId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseZone"]>

  export type WarehouseZoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    warehouseId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseZone"]>

  export type WarehouseZoneSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    warehouseId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseZoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "warehouseId" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouseZone"]>
  export type WarehouseZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    aisles?: boolean | WarehouseZone$aislesArgs<ExtArgs>
    _count?: boolean | WarehouseZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type WarehouseZoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }

  export type $WarehouseZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarehouseZone"
    objects: {
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      aisles: Prisma.$WarehouseAislePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      warehouseId: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouseZone"]>
    composites: {}
  }

  type WarehouseZoneGetPayload<S extends boolean | null | undefined | WarehouseZoneDefaultArgs> = $Result.GetResult<Prisma.$WarehouseZonePayload, S>

  type WarehouseZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseZoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseZoneCountAggregateInputType | true
    }

  export interface WarehouseZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarehouseZone'], meta: { name: 'WarehouseZone' } }
    /**
     * Find zero or one WarehouseZone that matches the filter.
     * @param {WarehouseZoneFindUniqueArgs} args - Arguments to find a WarehouseZone
     * @example
     * // Get one WarehouseZone
     * const warehouseZone = await prisma.warehouseZone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseZoneFindUniqueArgs>(args: SelectSubset<T, WarehouseZoneFindUniqueArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WarehouseZone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseZoneFindUniqueOrThrowArgs} args - Arguments to find a WarehouseZone
     * @example
     * // Get one WarehouseZone
     * const warehouseZone = await prisma.warehouseZone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseZone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseZoneFindFirstArgs} args - Arguments to find a WarehouseZone
     * @example
     * // Get one WarehouseZone
     * const warehouseZone = await prisma.warehouseZone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseZoneFindFirstArgs>(args?: SelectSubset<T, WarehouseZoneFindFirstArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseZone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseZoneFindFirstOrThrowArgs} args - Arguments to find a WarehouseZone
     * @example
     * // Get one WarehouseZone
     * const warehouseZone = await prisma.warehouseZone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WarehouseZones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarehouseZones
     * const warehouseZones = await prisma.warehouseZone.findMany()
     * 
     * // Get first 10 WarehouseZones
     * const warehouseZones = await prisma.warehouseZone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseZoneWithIdOnly = await prisma.warehouseZone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseZoneFindManyArgs>(args?: SelectSubset<T, WarehouseZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WarehouseZone.
     * @param {WarehouseZoneCreateArgs} args - Arguments to create a WarehouseZone.
     * @example
     * // Create one WarehouseZone
     * const WarehouseZone = await prisma.warehouseZone.create({
     *   data: {
     *     // ... data to create a WarehouseZone
     *   }
     * })
     * 
     */
    create<T extends WarehouseZoneCreateArgs>(args: SelectSubset<T, WarehouseZoneCreateArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WarehouseZones.
     * @param {WarehouseZoneCreateManyArgs} args - Arguments to create many WarehouseZones.
     * @example
     * // Create many WarehouseZones
     * const warehouseZone = await prisma.warehouseZone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseZoneCreateManyArgs>(args?: SelectSubset<T, WarehouseZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WarehouseZones and returns the data saved in the database.
     * @param {WarehouseZoneCreateManyAndReturnArgs} args - Arguments to create many WarehouseZones.
     * @example
     * // Create many WarehouseZones
     * const warehouseZone = await prisma.warehouseZone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WarehouseZones and only return the `id`
     * const warehouseZoneWithIdOnly = await prisma.warehouseZone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WarehouseZone.
     * @param {WarehouseZoneDeleteArgs} args - Arguments to delete one WarehouseZone.
     * @example
     * // Delete one WarehouseZone
     * const WarehouseZone = await prisma.warehouseZone.delete({
     *   where: {
     *     // ... filter to delete one WarehouseZone
     *   }
     * })
     * 
     */
    delete<T extends WarehouseZoneDeleteArgs>(args: SelectSubset<T, WarehouseZoneDeleteArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WarehouseZone.
     * @param {WarehouseZoneUpdateArgs} args - Arguments to update one WarehouseZone.
     * @example
     * // Update one WarehouseZone
     * const warehouseZone = await prisma.warehouseZone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseZoneUpdateArgs>(args: SelectSubset<T, WarehouseZoneUpdateArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WarehouseZones.
     * @param {WarehouseZoneDeleteManyArgs} args - Arguments to filter WarehouseZones to delete.
     * @example
     * // Delete a few WarehouseZones
     * const { count } = await prisma.warehouseZone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseZoneDeleteManyArgs>(args?: SelectSubset<T, WarehouseZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarehouseZones
     * const warehouseZone = await prisma.warehouseZone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseZoneUpdateManyArgs>(args: SelectSubset<T, WarehouseZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseZones and returns the data updated in the database.
     * @param {WarehouseZoneUpdateManyAndReturnArgs} args - Arguments to update many WarehouseZones.
     * @example
     * // Update many WarehouseZones
     * const warehouseZone = await prisma.warehouseZone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WarehouseZones and only return the `id`
     * const warehouseZoneWithIdOnly = await prisma.warehouseZone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseZoneUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseZoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WarehouseZone.
     * @param {WarehouseZoneUpsertArgs} args - Arguments to update or create a WarehouseZone.
     * @example
     * // Update or create a WarehouseZone
     * const warehouseZone = await prisma.warehouseZone.upsert({
     *   create: {
     *     // ... data to create a WarehouseZone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarehouseZone we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseZoneUpsertArgs>(args: SelectSubset<T, WarehouseZoneUpsertArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WarehouseZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseZoneCountArgs} args - Arguments to filter WarehouseZones to count.
     * @example
     * // Count the number of WarehouseZones
     * const count = await prisma.warehouseZone.count({
     *   where: {
     *     // ... the filter for the WarehouseZones we want to count
     *   }
     * })
    **/
    count<T extends WarehouseZoneCountArgs>(
      args?: Subset<T, WarehouseZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarehouseZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseZoneAggregateArgs>(args: Subset<T, WarehouseZoneAggregateArgs>): Prisma.PrismaPromise<GetWarehouseZoneAggregateType<T>>

    /**
     * Group by WarehouseZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseZoneGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarehouseZone model
   */
  readonly fields: WarehouseZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarehouseZone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    aisles<T extends WarehouseZone$aislesArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseZone$aislesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WarehouseZone model
   */
  interface WarehouseZoneFieldRefs {
    readonly id: FieldRef<"WarehouseZone", 'String'>
    readonly name: FieldRef<"WarehouseZone", 'String'>
    readonly code: FieldRef<"WarehouseZone", 'String'>
    readonly warehouseId: FieldRef<"WarehouseZone", 'String'>
    readonly description: FieldRef<"WarehouseZone", 'String'>
    readonly createdAt: FieldRef<"WarehouseZone", 'DateTime'>
    readonly updatedAt: FieldRef<"WarehouseZone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WarehouseZone findUnique
   */
  export type WarehouseZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseZone to fetch.
     */
    where: WarehouseZoneWhereUniqueInput
  }

  /**
   * WarehouseZone findUniqueOrThrow
   */
  export type WarehouseZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseZone to fetch.
     */
    where: WarehouseZoneWhereUniqueInput
  }

  /**
   * WarehouseZone findFirst
   */
  export type WarehouseZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseZone to fetch.
     */
    where?: WarehouseZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseZones to fetch.
     */
    orderBy?: WarehouseZoneOrderByWithRelationInput | WarehouseZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseZones.
     */
    cursor?: WarehouseZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseZones.
     */
    distinct?: WarehouseZoneScalarFieldEnum | WarehouseZoneScalarFieldEnum[]
  }

  /**
   * WarehouseZone findFirstOrThrow
   */
  export type WarehouseZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseZone to fetch.
     */
    where?: WarehouseZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseZones to fetch.
     */
    orderBy?: WarehouseZoneOrderByWithRelationInput | WarehouseZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseZones.
     */
    cursor?: WarehouseZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseZones.
     */
    distinct?: WarehouseZoneScalarFieldEnum | WarehouseZoneScalarFieldEnum[]
  }

  /**
   * WarehouseZone findMany
   */
  export type WarehouseZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseZones to fetch.
     */
    where?: WarehouseZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseZones to fetch.
     */
    orderBy?: WarehouseZoneOrderByWithRelationInput | WarehouseZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarehouseZones.
     */
    cursor?: WarehouseZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseZones.
     */
    skip?: number
    distinct?: WarehouseZoneScalarFieldEnum | WarehouseZoneScalarFieldEnum[]
  }

  /**
   * WarehouseZone create
   */
  export type WarehouseZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a WarehouseZone.
     */
    data: XOR<WarehouseZoneCreateInput, WarehouseZoneUncheckedCreateInput>
  }

  /**
   * WarehouseZone createMany
   */
  export type WarehouseZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarehouseZones.
     */
    data: WarehouseZoneCreateManyInput | WarehouseZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WarehouseZone createManyAndReturn
   */
  export type WarehouseZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * The data used to create many WarehouseZones.
     */
    data: WarehouseZoneCreateManyInput | WarehouseZoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseZone update
   */
  export type WarehouseZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a WarehouseZone.
     */
    data: XOR<WarehouseZoneUpdateInput, WarehouseZoneUncheckedUpdateInput>
    /**
     * Choose, which WarehouseZone to update.
     */
    where: WarehouseZoneWhereUniqueInput
  }

  /**
   * WarehouseZone updateMany
   */
  export type WarehouseZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarehouseZones.
     */
    data: XOR<WarehouseZoneUpdateManyMutationInput, WarehouseZoneUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseZones to update
     */
    where?: WarehouseZoneWhereInput
    /**
     * Limit how many WarehouseZones to update.
     */
    limit?: number
  }

  /**
   * WarehouseZone updateManyAndReturn
   */
  export type WarehouseZoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * The data used to update WarehouseZones.
     */
    data: XOR<WarehouseZoneUpdateManyMutationInput, WarehouseZoneUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseZones to update
     */
    where?: WarehouseZoneWhereInput
    /**
     * Limit how many WarehouseZones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseZone upsert
   */
  export type WarehouseZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the WarehouseZone to update in case it exists.
     */
    where: WarehouseZoneWhereUniqueInput
    /**
     * In case the WarehouseZone found by the `where` argument doesn't exist, create a new WarehouseZone with this data.
     */
    create: XOR<WarehouseZoneCreateInput, WarehouseZoneUncheckedCreateInput>
    /**
     * In case the WarehouseZone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseZoneUpdateInput, WarehouseZoneUncheckedUpdateInput>
  }

  /**
   * WarehouseZone delete
   */
  export type WarehouseZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
    /**
     * Filter which WarehouseZone to delete.
     */
    where: WarehouseZoneWhereUniqueInput
  }

  /**
   * WarehouseZone deleteMany
   */
  export type WarehouseZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseZones to delete
     */
    where?: WarehouseZoneWhereInput
    /**
     * Limit how many WarehouseZones to delete.
     */
    limit?: number
  }

  /**
   * WarehouseZone.aisles
   */
  export type WarehouseZone$aislesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    where?: WarehouseAisleWhereInput
    orderBy?: WarehouseAisleOrderByWithRelationInput | WarehouseAisleOrderByWithRelationInput[]
    cursor?: WarehouseAisleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseAisleScalarFieldEnum | WarehouseAisleScalarFieldEnum[]
  }

  /**
   * WarehouseZone without action
   */
  export type WarehouseZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseZone
     */
    select?: WarehouseZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseZone
     */
    omit?: WarehouseZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseZoneInclude<ExtArgs> | null
  }


  /**
   * Model WarehouseAisle
   */

  export type AggregateWarehouseAisle = {
    _count: WarehouseAisleCountAggregateOutputType | null
    _min: WarehouseAisleMinAggregateOutputType | null
    _max: WarehouseAisleMaxAggregateOutputType | null
  }

  export type WarehouseAisleMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseAisleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseAisleCountAggregateOutputType = {
    id: number
    name: number
    code: number
    zoneId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseAisleMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseAisleMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseAisleCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseAisleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseAisle to aggregate.
     */
    where?: WarehouseAisleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseAisles to fetch.
     */
    orderBy?: WarehouseAisleOrderByWithRelationInput | WarehouseAisleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseAisleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseAisles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseAisles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarehouseAisles
    **/
    _count?: true | WarehouseAisleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseAisleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseAisleMaxAggregateInputType
  }

  export type GetWarehouseAisleAggregateType<T extends WarehouseAisleAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouseAisle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouseAisle[P]>
      : GetScalarType<T[P], AggregateWarehouseAisle[P]>
  }




  export type WarehouseAisleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseAisleWhereInput
    orderBy?: WarehouseAisleOrderByWithAggregationInput | WarehouseAisleOrderByWithAggregationInput[]
    by: WarehouseAisleScalarFieldEnum[] | WarehouseAisleScalarFieldEnum
    having?: WarehouseAisleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseAisleCountAggregateInputType | true
    _min?: WarehouseAisleMinAggregateInputType
    _max?: WarehouseAisleMaxAggregateInputType
  }

  export type WarehouseAisleGroupByOutputType = {
    id: string
    name: string
    code: string
    zoneId: string
    createdAt: Date
    updatedAt: Date
    _count: WarehouseAisleCountAggregateOutputType | null
    _min: WarehouseAisleMinAggregateOutputType | null
    _max: WarehouseAisleMaxAggregateOutputType | null
  }

  type GetWarehouseAisleGroupByPayload<T extends WarehouseAisleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseAisleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseAisleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseAisleGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseAisleGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseAisleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | WarehouseZoneDefaultArgs<ExtArgs>
    shelves?: boolean | WarehouseAisle$shelvesArgs<ExtArgs>
    _count?: boolean | WarehouseAisleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseAisle"]>

  export type WarehouseAisleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | WarehouseZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseAisle"]>

  export type WarehouseAisleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | WarehouseZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseAisle"]>

  export type WarehouseAisleSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseAisleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "zoneId" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouseAisle"]>
  export type WarehouseAisleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | WarehouseZoneDefaultArgs<ExtArgs>
    shelves?: boolean | WarehouseAisle$shelvesArgs<ExtArgs>
    _count?: boolean | WarehouseAisleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseAisleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | WarehouseZoneDefaultArgs<ExtArgs>
  }
  export type WarehouseAisleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | WarehouseZoneDefaultArgs<ExtArgs>
  }

  export type $WarehouseAislePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarehouseAisle"
    objects: {
      zone: Prisma.$WarehouseZonePayload<ExtArgs>
      shelves: Prisma.$WarehouseShelfPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      zoneId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouseAisle"]>
    composites: {}
  }

  type WarehouseAisleGetPayload<S extends boolean | null | undefined | WarehouseAisleDefaultArgs> = $Result.GetResult<Prisma.$WarehouseAislePayload, S>

  type WarehouseAisleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseAisleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseAisleCountAggregateInputType | true
    }

  export interface WarehouseAisleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarehouseAisle'], meta: { name: 'WarehouseAisle' } }
    /**
     * Find zero or one WarehouseAisle that matches the filter.
     * @param {WarehouseAisleFindUniqueArgs} args - Arguments to find a WarehouseAisle
     * @example
     * // Get one WarehouseAisle
     * const warehouseAisle = await prisma.warehouseAisle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseAisleFindUniqueArgs>(args: SelectSubset<T, WarehouseAisleFindUniqueArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WarehouseAisle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseAisleFindUniqueOrThrowArgs} args - Arguments to find a WarehouseAisle
     * @example
     * // Get one WarehouseAisle
     * const warehouseAisle = await prisma.warehouseAisle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseAisleFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseAisleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseAisle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAisleFindFirstArgs} args - Arguments to find a WarehouseAisle
     * @example
     * // Get one WarehouseAisle
     * const warehouseAisle = await prisma.warehouseAisle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseAisleFindFirstArgs>(args?: SelectSubset<T, WarehouseAisleFindFirstArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseAisle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAisleFindFirstOrThrowArgs} args - Arguments to find a WarehouseAisle
     * @example
     * // Get one WarehouseAisle
     * const warehouseAisle = await prisma.warehouseAisle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseAisleFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseAisleFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WarehouseAisles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAisleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarehouseAisles
     * const warehouseAisles = await prisma.warehouseAisle.findMany()
     * 
     * // Get first 10 WarehouseAisles
     * const warehouseAisles = await prisma.warehouseAisle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseAisleWithIdOnly = await prisma.warehouseAisle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseAisleFindManyArgs>(args?: SelectSubset<T, WarehouseAisleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WarehouseAisle.
     * @param {WarehouseAisleCreateArgs} args - Arguments to create a WarehouseAisle.
     * @example
     * // Create one WarehouseAisle
     * const WarehouseAisle = await prisma.warehouseAisle.create({
     *   data: {
     *     // ... data to create a WarehouseAisle
     *   }
     * })
     * 
     */
    create<T extends WarehouseAisleCreateArgs>(args: SelectSubset<T, WarehouseAisleCreateArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WarehouseAisles.
     * @param {WarehouseAisleCreateManyArgs} args - Arguments to create many WarehouseAisles.
     * @example
     * // Create many WarehouseAisles
     * const warehouseAisle = await prisma.warehouseAisle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseAisleCreateManyArgs>(args?: SelectSubset<T, WarehouseAisleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WarehouseAisles and returns the data saved in the database.
     * @param {WarehouseAisleCreateManyAndReturnArgs} args - Arguments to create many WarehouseAisles.
     * @example
     * // Create many WarehouseAisles
     * const warehouseAisle = await prisma.warehouseAisle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WarehouseAisles and only return the `id`
     * const warehouseAisleWithIdOnly = await prisma.warehouseAisle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseAisleCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseAisleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WarehouseAisle.
     * @param {WarehouseAisleDeleteArgs} args - Arguments to delete one WarehouseAisle.
     * @example
     * // Delete one WarehouseAisle
     * const WarehouseAisle = await prisma.warehouseAisle.delete({
     *   where: {
     *     // ... filter to delete one WarehouseAisle
     *   }
     * })
     * 
     */
    delete<T extends WarehouseAisleDeleteArgs>(args: SelectSubset<T, WarehouseAisleDeleteArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WarehouseAisle.
     * @param {WarehouseAisleUpdateArgs} args - Arguments to update one WarehouseAisle.
     * @example
     * // Update one WarehouseAisle
     * const warehouseAisle = await prisma.warehouseAisle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseAisleUpdateArgs>(args: SelectSubset<T, WarehouseAisleUpdateArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WarehouseAisles.
     * @param {WarehouseAisleDeleteManyArgs} args - Arguments to filter WarehouseAisles to delete.
     * @example
     * // Delete a few WarehouseAisles
     * const { count } = await prisma.warehouseAisle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseAisleDeleteManyArgs>(args?: SelectSubset<T, WarehouseAisleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseAisles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAisleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarehouseAisles
     * const warehouseAisle = await prisma.warehouseAisle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseAisleUpdateManyArgs>(args: SelectSubset<T, WarehouseAisleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseAisles and returns the data updated in the database.
     * @param {WarehouseAisleUpdateManyAndReturnArgs} args - Arguments to update many WarehouseAisles.
     * @example
     * // Update many WarehouseAisles
     * const warehouseAisle = await prisma.warehouseAisle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WarehouseAisles and only return the `id`
     * const warehouseAisleWithIdOnly = await prisma.warehouseAisle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseAisleUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseAisleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WarehouseAisle.
     * @param {WarehouseAisleUpsertArgs} args - Arguments to update or create a WarehouseAisle.
     * @example
     * // Update or create a WarehouseAisle
     * const warehouseAisle = await prisma.warehouseAisle.upsert({
     *   create: {
     *     // ... data to create a WarehouseAisle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarehouseAisle we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseAisleUpsertArgs>(args: SelectSubset<T, WarehouseAisleUpsertArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WarehouseAisles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAisleCountArgs} args - Arguments to filter WarehouseAisles to count.
     * @example
     * // Count the number of WarehouseAisles
     * const count = await prisma.warehouseAisle.count({
     *   where: {
     *     // ... the filter for the WarehouseAisles we want to count
     *   }
     * })
    **/
    count<T extends WarehouseAisleCountArgs>(
      args?: Subset<T, WarehouseAisleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseAisleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarehouseAisle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAisleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAisleAggregateArgs>(args: Subset<T, WarehouseAisleAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAisleAggregateType<T>>

    /**
     * Group by WarehouseAisle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAisleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseAisleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseAisleGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseAisleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseAisleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseAisleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarehouseAisle model
   */
  readonly fields: WarehouseAisleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarehouseAisle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseAisleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone<T extends WarehouseZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseZoneDefaultArgs<ExtArgs>>): Prisma__WarehouseZoneClient<$Result.GetResult<Prisma.$WarehouseZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shelves<T extends WarehouseAisle$shelvesArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseAisle$shelvesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WarehouseAisle model
   */
  interface WarehouseAisleFieldRefs {
    readonly id: FieldRef<"WarehouseAisle", 'String'>
    readonly name: FieldRef<"WarehouseAisle", 'String'>
    readonly code: FieldRef<"WarehouseAisle", 'String'>
    readonly zoneId: FieldRef<"WarehouseAisle", 'String'>
    readonly createdAt: FieldRef<"WarehouseAisle", 'DateTime'>
    readonly updatedAt: FieldRef<"WarehouseAisle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WarehouseAisle findUnique
   */
  export type WarehouseAisleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseAisle to fetch.
     */
    where: WarehouseAisleWhereUniqueInput
  }

  /**
   * WarehouseAisle findUniqueOrThrow
   */
  export type WarehouseAisleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseAisle to fetch.
     */
    where: WarehouseAisleWhereUniqueInput
  }

  /**
   * WarehouseAisle findFirst
   */
  export type WarehouseAisleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseAisle to fetch.
     */
    where?: WarehouseAisleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseAisles to fetch.
     */
    orderBy?: WarehouseAisleOrderByWithRelationInput | WarehouseAisleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseAisles.
     */
    cursor?: WarehouseAisleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseAisles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseAisles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseAisles.
     */
    distinct?: WarehouseAisleScalarFieldEnum | WarehouseAisleScalarFieldEnum[]
  }

  /**
   * WarehouseAisle findFirstOrThrow
   */
  export type WarehouseAisleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseAisle to fetch.
     */
    where?: WarehouseAisleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseAisles to fetch.
     */
    orderBy?: WarehouseAisleOrderByWithRelationInput | WarehouseAisleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseAisles.
     */
    cursor?: WarehouseAisleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseAisles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseAisles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseAisles.
     */
    distinct?: WarehouseAisleScalarFieldEnum | WarehouseAisleScalarFieldEnum[]
  }

  /**
   * WarehouseAisle findMany
   */
  export type WarehouseAisleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseAisles to fetch.
     */
    where?: WarehouseAisleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseAisles to fetch.
     */
    orderBy?: WarehouseAisleOrderByWithRelationInput | WarehouseAisleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarehouseAisles.
     */
    cursor?: WarehouseAisleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseAisles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseAisles.
     */
    skip?: number
    distinct?: WarehouseAisleScalarFieldEnum | WarehouseAisleScalarFieldEnum[]
  }

  /**
   * WarehouseAisle create
   */
  export type WarehouseAisleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * The data needed to create a WarehouseAisle.
     */
    data: XOR<WarehouseAisleCreateInput, WarehouseAisleUncheckedCreateInput>
  }

  /**
   * WarehouseAisle createMany
   */
  export type WarehouseAisleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarehouseAisles.
     */
    data: WarehouseAisleCreateManyInput | WarehouseAisleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WarehouseAisle createManyAndReturn
   */
  export type WarehouseAisleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * The data used to create many WarehouseAisles.
     */
    data: WarehouseAisleCreateManyInput | WarehouseAisleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseAisle update
   */
  export type WarehouseAisleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * The data needed to update a WarehouseAisle.
     */
    data: XOR<WarehouseAisleUpdateInput, WarehouseAisleUncheckedUpdateInput>
    /**
     * Choose, which WarehouseAisle to update.
     */
    where: WarehouseAisleWhereUniqueInput
  }

  /**
   * WarehouseAisle updateMany
   */
  export type WarehouseAisleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarehouseAisles.
     */
    data: XOR<WarehouseAisleUpdateManyMutationInput, WarehouseAisleUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseAisles to update
     */
    where?: WarehouseAisleWhereInput
    /**
     * Limit how many WarehouseAisles to update.
     */
    limit?: number
  }

  /**
   * WarehouseAisle updateManyAndReturn
   */
  export type WarehouseAisleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * The data used to update WarehouseAisles.
     */
    data: XOR<WarehouseAisleUpdateManyMutationInput, WarehouseAisleUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseAisles to update
     */
    where?: WarehouseAisleWhereInput
    /**
     * Limit how many WarehouseAisles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseAisle upsert
   */
  export type WarehouseAisleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * The filter to search for the WarehouseAisle to update in case it exists.
     */
    where: WarehouseAisleWhereUniqueInput
    /**
     * In case the WarehouseAisle found by the `where` argument doesn't exist, create a new WarehouseAisle with this data.
     */
    create: XOR<WarehouseAisleCreateInput, WarehouseAisleUncheckedCreateInput>
    /**
     * In case the WarehouseAisle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseAisleUpdateInput, WarehouseAisleUncheckedUpdateInput>
  }

  /**
   * WarehouseAisle delete
   */
  export type WarehouseAisleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
    /**
     * Filter which WarehouseAisle to delete.
     */
    where: WarehouseAisleWhereUniqueInput
  }

  /**
   * WarehouseAisle deleteMany
   */
  export type WarehouseAisleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseAisles to delete
     */
    where?: WarehouseAisleWhereInput
    /**
     * Limit how many WarehouseAisles to delete.
     */
    limit?: number
  }

  /**
   * WarehouseAisle.shelves
   */
  export type WarehouseAisle$shelvesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    where?: WarehouseShelfWhereInput
    orderBy?: WarehouseShelfOrderByWithRelationInput | WarehouseShelfOrderByWithRelationInput[]
    cursor?: WarehouseShelfWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseShelfScalarFieldEnum | WarehouseShelfScalarFieldEnum[]
  }

  /**
   * WarehouseAisle without action
   */
  export type WarehouseAisleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseAisle
     */
    select?: WarehouseAisleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseAisle
     */
    omit?: WarehouseAisleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseAisleInclude<ExtArgs> | null
  }


  /**
   * Model WarehouseShelf
   */

  export type AggregateWarehouseShelf = {
    _count: WarehouseShelfCountAggregateOutputType | null
    _min: WarehouseShelfMinAggregateOutputType | null
    _max: WarehouseShelfMaxAggregateOutputType | null
  }

  export type WarehouseShelfMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    aisleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseShelfMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    aisleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseShelfCountAggregateOutputType = {
    id: number
    name: number
    code: number
    aisleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseShelfMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    aisleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseShelfMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    aisleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseShelfCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    aisleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseShelfAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseShelf to aggregate.
     */
    where?: WarehouseShelfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseShelves to fetch.
     */
    orderBy?: WarehouseShelfOrderByWithRelationInput | WarehouseShelfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseShelfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseShelves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseShelves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarehouseShelves
    **/
    _count?: true | WarehouseShelfCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseShelfMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseShelfMaxAggregateInputType
  }

  export type GetWarehouseShelfAggregateType<T extends WarehouseShelfAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouseShelf]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouseShelf[P]>
      : GetScalarType<T[P], AggregateWarehouseShelf[P]>
  }




  export type WarehouseShelfGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseShelfWhereInput
    orderBy?: WarehouseShelfOrderByWithAggregationInput | WarehouseShelfOrderByWithAggregationInput[]
    by: WarehouseShelfScalarFieldEnum[] | WarehouseShelfScalarFieldEnum
    having?: WarehouseShelfScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseShelfCountAggregateInputType | true
    _min?: WarehouseShelfMinAggregateInputType
    _max?: WarehouseShelfMaxAggregateInputType
  }

  export type WarehouseShelfGroupByOutputType = {
    id: string
    name: string
    code: string
    aisleId: string
    createdAt: Date
    updatedAt: Date
    _count: WarehouseShelfCountAggregateOutputType | null
    _min: WarehouseShelfMinAggregateOutputType | null
    _max: WarehouseShelfMaxAggregateOutputType | null
  }

  type GetWarehouseShelfGroupByPayload<T extends WarehouseShelfGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseShelfGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseShelfGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseShelfGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseShelfGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseShelfSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    aisleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aisle?: boolean | WarehouseAisleDefaultArgs<ExtArgs>
    bins?: boolean | WarehouseShelf$binsArgs<ExtArgs>
    _count?: boolean | WarehouseShelfCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseShelf"]>

  export type WarehouseShelfSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    aisleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aisle?: boolean | WarehouseAisleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseShelf"]>

  export type WarehouseShelfSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    aisleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aisle?: boolean | WarehouseAisleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseShelf"]>

  export type WarehouseShelfSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    aisleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseShelfOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "aisleId" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouseShelf"]>
  export type WarehouseShelfInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aisle?: boolean | WarehouseAisleDefaultArgs<ExtArgs>
    bins?: boolean | WarehouseShelf$binsArgs<ExtArgs>
    _count?: boolean | WarehouseShelfCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseShelfIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aisle?: boolean | WarehouseAisleDefaultArgs<ExtArgs>
  }
  export type WarehouseShelfIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aisle?: boolean | WarehouseAisleDefaultArgs<ExtArgs>
  }

  export type $WarehouseShelfPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarehouseShelf"
    objects: {
      aisle: Prisma.$WarehouseAislePayload<ExtArgs>
      bins: Prisma.$WarehouseBinPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      aisleId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouseShelf"]>
    composites: {}
  }

  type WarehouseShelfGetPayload<S extends boolean | null | undefined | WarehouseShelfDefaultArgs> = $Result.GetResult<Prisma.$WarehouseShelfPayload, S>

  type WarehouseShelfCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseShelfFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseShelfCountAggregateInputType | true
    }

  export interface WarehouseShelfDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarehouseShelf'], meta: { name: 'WarehouseShelf' } }
    /**
     * Find zero or one WarehouseShelf that matches the filter.
     * @param {WarehouseShelfFindUniqueArgs} args - Arguments to find a WarehouseShelf
     * @example
     * // Get one WarehouseShelf
     * const warehouseShelf = await prisma.warehouseShelf.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseShelfFindUniqueArgs>(args: SelectSubset<T, WarehouseShelfFindUniqueArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WarehouseShelf that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseShelfFindUniqueOrThrowArgs} args - Arguments to find a WarehouseShelf
     * @example
     * // Get one WarehouseShelf
     * const warehouseShelf = await prisma.warehouseShelf.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseShelfFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseShelfFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseShelf that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseShelfFindFirstArgs} args - Arguments to find a WarehouseShelf
     * @example
     * // Get one WarehouseShelf
     * const warehouseShelf = await prisma.warehouseShelf.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseShelfFindFirstArgs>(args?: SelectSubset<T, WarehouseShelfFindFirstArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseShelf that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseShelfFindFirstOrThrowArgs} args - Arguments to find a WarehouseShelf
     * @example
     * // Get one WarehouseShelf
     * const warehouseShelf = await prisma.warehouseShelf.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseShelfFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseShelfFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WarehouseShelves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseShelfFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarehouseShelves
     * const warehouseShelves = await prisma.warehouseShelf.findMany()
     * 
     * // Get first 10 WarehouseShelves
     * const warehouseShelves = await prisma.warehouseShelf.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseShelfWithIdOnly = await prisma.warehouseShelf.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseShelfFindManyArgs>(args?: SelectSubset<T, WarehouseShelfFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WarehouseShelf.
     * @param {WarehouseShelfCreateArgs} args - Arguments to create a WarehouseShelf.
     * @example
     * // Create one WarehouseShelf
     * const WarehouseShelf = await prisma.warehouseShelf.create({
     *   data: {
     *     // ... data to create a WarehouseShelf
     *   }
     * })
     * 
     */
    create<T extends WarehouseShelfCreateArgs>(args: SelectSubset<T, WarehouseShelfCreateArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WarehouseShelves.
     * @param {WarehouseShelfCreateManyArgs} args - Arguments to create many WarehouseShelves.
     * @example
     * // Create many WarehouseShelves
     * const warehouseShelf = await prisma.warehouseShelf.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseShelfCreateManyArgs>(args?: SelectSubset<T, WarehouseShelfCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WarehouseShelves and returns the data saved in the database.
     * @param {WarehouseShelfCreateManyAndReturnArgs} args - Arguments to create many WarehouseShelves.
     * @example
     * // Create many WarehouseShelves
     * const warehouseShelf = await prisma.warehouseShelf.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WarehouseShelves and only return the `id`
     * const warehouseShelfWithIdOnly = await prisma.warehouseShelf.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseShelfCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseShelfCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WarehouseShelf.
     * @param {WarehouseShelfDeleteArgs} args - Arguments to delete one WarehouseShelf.
     * @example
     * // Delete one WarehouseShelf
     * const WarehouseShelf = await prisma.warehouseShelf.delete({
     *   where: {
     *     // ... filter to delete one WarehouseShelf
     *   }
     * })
     * 
     */
    delete<T extends WarehouseShelfDeleteArgs>(args: SelectSubset<T, WarehouseShelfDeleteArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WarehouseShelf.
     * @param {WarehouseShelfUpdateArgs} args - Arguments to update one WarehouseShelf.
     * @example
     * // Update one WarehouseShelf
     * const warehouseShelf = await prisma.warehouseShelf.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseShelfUpdateArgs>(args: SelectSubset<T, WarehouseShelfUpdateArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WarehouseShelves.
     * @param {WarehouseShelfDeleteManyArgs} args - Arguments to filter WarehouseShelves to delete.
     * @example
     * // Delete a few WarehouseShelves
     * const { count } = await prisma.warehouseShelf.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseShelfDeleteManyArgs>(args?: SelectSubset<T, WarehouseShelfDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseShelves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseShelfUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarehouseShelves
     * const warehouseShelf = await prisma.warehouseShelf.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseShelfUpdateManyArgs>(args: SelectSubset<T, WarehouseShelfUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseShelves and returns the data updated in the database.
     * @param {WarehouseShelfUpdateManyAndReturnArgs} args - Arguments to update many WarehouseShelves.
     * @example
     * // Update many WarehouseShelves
     * const warehouseShelf = await prisma.warehouseShelf.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WarehouseShelves and only return the `id`
     * const warehouseShelfWithIdOnly = await prisma.warehouseShelf.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseShelfUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseShelfUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WarehouseShelf.
     * @param {WarehouseShelfUpsertArgs} args - Arguments to update or create a WarehouseShelf.
     * @example
     * // Update or create a WarehouseShelf
     * const warehouseShelf = await prisma.warehouseShelf.upsert({
     *   create: {
     *     // ... data to create a WarehouseShelf
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarehouseShelf we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseShelfUpsertArgs>(args: SelectSubset<T, WarehouseShelfUpsertArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WarehouseShelves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseShelfCountArgs} args - Arguments to filter WarehouseShelves to count.
     * @example
     * // Count the number of WarehouseShelves
     * const count = await prisma.warehouseShelf.count({
     *   where: {
     *     // ... the filter for the WarehouseShelves we want to count
     *   }
     * })
    **/
    count<T extends WarehouseShelfCountArgs>(
      args?: Subset<T, WarehouseShelfCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseShelfCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarehouseShelf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseShelfAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseShelfAggregateArgs>(args: Subset<T, WarehouseShelfAggregateArgs>): Prisma.PrismaPromise<GetWarehouseShelfAggregateType<T>>

    /**
     * Group by WarehouseShelf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseShelfGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseShelfGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseShelfGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseShelfGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseShelfGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseShelfGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarehouseShelf model
   */
  readonly fields: WarehouseShelfFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarehouseShelf.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseShelfClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aisle<T extends WarehouseAisleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseAisleDefaultArgs<ExtArgs>>): Prisma__WarehouseAisleClient<$Result.GetResult<Prisma.$WarehouseAislePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bins<T extends WarehouseShelf$binsArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseShelf$binsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WarehouseShelf model
   */
  interface WarehouseShelfFieldRefs {
    readonly id: FieldRef<"WarehouseShelf", 'String'>
    readonly name: FieldRef<"WarehouseShelf", 'String'>
    readonly code: FieldRef<"WarehouseShelf", 'String'>
    readonly aisleId: FieldRef<"WarehouseShelf", 'String'>
    readonly createdAt: FieldRef<"WarehouseShelf", 'DateTime'>
    readonly updatedAt: FieldRef<"WarehouseShelf", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WarehouseShelf findUnique
   */
  export type WarehouseShelfFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseShelf to fetch.
     */
    where: WarehouseShelfWhereUniqueInput
  }

  /**
   * WarehouseShelf findUniqueOrThrow
   */
  export type WarehouseShelfFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseShelf to fetch.
     */
    where: WarehouseShelfWhereUniqueInput
  }

  /**
   * WarehouseShelf findFirst
   */
  export type WarehouseShelfFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseShelf to fetch.
     */
    where?: WarehouseShelfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseShelves to fetch.
     */
    orderBy?: WarehouseShelfOrderByWithRelationInput | WarehouseShelfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseShelves.
     */
    cursor?: WarehouseShelfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseShelves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseShelves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseShelves.
     */
    distinct?: WarehouseShelfScalarFieldEnum | WarehouseShelfScalarFieldEnum[]
  }

  /**
   * WarehouseShelf findFirstOrThrow
   */
  export type WarehouseShelfFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseShelf to fetch.
     */
    where?: WarehouseShelfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseShelves to fetch.
     */
    orderBy?: WarehouseShelfOrderByWithRelationInput | WarehouseShelfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseShelves.
     */
    cursor?: WarehouseShelfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseShelves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseShelves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseShelves.
     */
    distinct?: WarehouseShelfScalarFieldEnum | WarehouseShelfScalarFieldEnum[]
  }

  /**
   * WarehouseShelf findMany
   */
  export type WarehouseShelfFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseShelves to fetch.
     */
    where?: WarehouseShelfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseShelves to fetch.
     */
    orderBy?: WarehouseShelfOrderByWithRelationInput | WarehouseShelfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarehouseShelves.
     */
    cursor?: WarehouseShelfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseShelves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseShelves.
     */
    skip?: number
    distinct?: WarehouseShelfScalarFieldEnum | WarehouseShelfScalarFieldEnum[]
  }

  /**
   * WarehouseShelf create
   */
  export type WarehouseShelfCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * The data needed to create a WarehouseShelf.
     */
    data: XOR<WarehouseShelfCreateInput, WarehouseShelfUncheckedCreateInput>
  }

  /**
   * WarehouseShelf createMany
   */
  export type WarehouseShelfCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarehouseShelves.
     */
    data: WarehouseShelfCreateManyInput | WarehouseShelfCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WarehouseShelf createManyAndReturn
   */
  export type WarehouseShelfCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * The data used to create many WarehouseShelves.
     */
    data: WarehouseShelfCreateManyInput | WarehouseShelfCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseShelf update
   */
  export type WarehouseShelfUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * The data needed to update a WarehouseShelf.
     */
    data: XOR<WarehouseShelfUpdateInput, WarehouseShelfUncheckedUpdateInput>
    /**
     * Choose, which WarehouseShelf to update.
     */
    where: WarehouseShelfWhereUniqueInput
  }

  /**
   * WarehouseShelf updateMany
   */
  export type WarehouseShelfUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarehouseShelves.
     */
    data: XOR<WarehouseShelfUpdateManyMutationInput, WarehouseShelfUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseShelves to update
     */
    where?: WarehouseShelfWhereInput
    /**
     * Limit how many WarehouseShelves to update.
     */
    limit?: number
  }

  /**
   * WarehouseShelf updateManyAndReturn
   */
  export type WarehouseShelfUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * The data used to update WarehouseShelves.
     */
    data: XOR<WarehouseShelfUpdateManyMutationInput, WarehouseShelfUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseShelves to update
     */
    where?: WarehouseShelfWhereInput
    /**
     * Limit how many WarehouseShelves to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseShelf upsert
   */
  export type WarehouseShelfUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * The filter to search for the WarehouseShelf to update in case it exists.
     */
    where: WarehouseShelfWhereUniqueInput
    /**
     * In case the WarehouseShelf found by the `where` argument doesn't exist, create a new WarehouseShelf with this data.
     */
    create: XOR<WarehouseShelfCreateInput, WarehouseShelfUncheckedCreateInput>
    /**
     * In case the WarehouseShelf was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseShelfUpdateInput, WarehouseShelfUncheckedUpdateInput>
  }

  /**
   * WarehouseShelf delete
   */
  export type WarehouseShelfDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
    /**
     * Filter which WarehouseShelf to delete.
     */
    where: WarehouseShelfWhereUniqueInput
  }

  /**
   * WarehouseShelf deleteMany
   */
  export type WarehouseShelfDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseShelves to delete
     */
    where?: WarehouseShelfWhereInput
    /**
     * Limit how many WarehouseShelves to delete.
     */
    limit?: number
  }

  /**
   * WarehouseShelf.bins
   */
  export type WarehouseShelf$binsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    where?: WarehouseBinWhereInput
    orderBy?: WarehouseBinOrderByWithRelationInput | WarehouseBinOrderByWithRelationInput[]
    cursor?: WarehouseBinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseBinScalarFieldEnum | WarehouseBinScalarFieldEnum[]
  }

  /**
   * WarehouseShelf without action
   */
  export type WarehouseShelfDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseShelf
     */
    select?: WarehouseShelfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseShelf
     */
    omit?: WarehouseShelfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseShelfInclude<ExtArgs> | null
  }


  /**
   * Model WarehouseBin
   */

  export type AggregateWarehouseBin = {
    _count: WarehouseBinCountAggregateOutputType | null
    _avg: WarehouseBinAvgAggregateOutputType | null
    _sum: WarehouseBinSumAggregateOutputType | null
    _min: WarehouseBinMinAggregateOutputType | null
    _max: WarehouseBinMaxAggregateOutputType | null
  }

  export type WarehouseBinAvgAggregateOutputType = {
    capacity: number | null
  }

  export type WarehouseBinSumAggregateOutputType = {
    capacity: number | null
  }

  export type WarehouseBinMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    shelfId: string | null
    capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseBinMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    shelfId: string | null
    capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseBinCountAggregateOutputType = {
    id: number
    name: number
    code: number
    shelfId: number
    capacity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseBinAvgAggregateInputType = {
    capacity?: true
  }

  export type WarehouseBinSumAggregateInputType = {
    capacity?: true
  }

  export type WarehouseBinMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    shelfId?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseBinMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    shelfId?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseBinCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    shelfId?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseBinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseBin to aggregate.
     */
    where?: WarehouseBinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseBins to fetch.
     */
    orderBy?: WarehouseBinOrderByWithRelationInput | WarehouseBinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseBinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseBins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseBins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarehouseBins
    **/
    _count?: true | WarehouseBinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarehouseBinAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarehouseBinSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseBinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseBinMaxAggregateInputType
  }

  export type GetWarehouseBinAggregateType<T extends WarehouseBinAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouseBin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouseBin[P]>
      : GetScalarType<T[P], AggregateWarehouseBin[P]>
  }




  export type WarehouseBinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseBinWhereInput
    orderBy?: WarehouseBinOrderByWithAggregationInput | WarehouseBinOrderByWithAggregationInput[]
    by: WarehouseBinScalarFieldEnum[] | WarehouseBinScalarFieldEnum
    having?: WarehouseBinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseBinCountAggregateInputType | true
    _avg?: WarehouseBinAvgAggregateInputType
    _sum?: WarehouseBinSumAggregateInputType
    _min?: WarehouseBinMinAggregateInputType
    _max?: WarehouseBinMaxAggregateInputType
  }

  export type WarehouseBinGroupByOutputType = {
    id: string
    name: string
    code: string
    shelfId: string
    capacity: number | null
    createdAt: Date
    updatedAt: Date
    _count: WarehouseBinCountAggregateOutputType | null
    _avg: WarehouseBinAvgAggregateOutputType | null
    _sum: WarehouseBinSumAggregateOutputType | null
    _min: WarehouseBinMinAggregateOutputType | null
    _max: WarehouseBinMaxAggregateOutputType | null
  }

  type GetWarehouseBinGroupByPayload<T extends WarehouseBinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseBinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseBinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseBinGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseBinGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseBinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    shelfId?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shelf?: boolean | WarehouseShelfDefaultArgs<ExtArgs>
    inventoryItems?: boolean | WarehouseBin$inventoryItemsArgs<ExtArgs>
    _count?: boolean | WarehouseBinCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseBin"]>

  export type WarehouseBinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    shelfId?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shelf?: boolean | WarehouseShelfDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseBin"]>

  export type WarehouseBinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    shelfId?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shelf?: boolean | WarehouseShelfDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseBin"]>

  export type WarehouseBinSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    shelfId?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseBinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "shelfId" | "capacity" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouseBin"]>
  export type WarehouseBinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shelf?: boolean | WarehouseShelfDefaultArgs<ExtArgs>
    inventoryItems?: boolean | WarehouseBin$inventoryItemsArgs<ExtArgs>
    _count?: boolean | WarehouseBinCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseBinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shelf?: boolean | WarehouseShelfDefaultArgs<ExtArgs>
  }
  export type WarehouseBinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shelf?: boolean | WarehouseShelfDefaultArgs<ExtArgs>
  }

  export type $WarehouseBinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarehouseBin"
    objects: {
      shelf: Prisma.$WarehouseShelfPayload<ExtArgs>
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      shelfId: string
      capacity: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouseBin"]>
    composites: {}
  }

  type WarehouseBinGetPayload<S extends boolean | null | undefined | WarehouseBinDefaultArgs> = $Result.GetResult<Prisma.$WarehouseBinPayload, S>

  type WarehouseBinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseBinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseBinCountAggregateInputType | true
    }

  export interface WarehouseBinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarehouseBin'], meta: { name: 'WarehouseBin' } }
    /**
     * Find zero or one WarehouseBin that matches the filter.
     * @param {WarehouseBinFindUniqueArgs} args - Arguments to find a WarehouseBin
     * @example
     * // Get one WarehouseBin
     * const warehouseBin = await prisma.warehouseBin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseBinFindUniqueArgs>(args: SelectSubset<T, WarehouseBinFindUniqueArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WarehouseBin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseBinFindUniqueOrThrowArgs} args - Arguments to find a WarehouseBin
     * @example
     * // Get one WarehouseBin
     * const warehouseBin = await prisma.warehouseBin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseBinFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseBinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseBin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseBinFindFirstArgs} args - Arguments to find a WarehouseBin
     * @example
     * // Get one WarehouseBin
     * const warehouseBin = await prisma.warehouseBin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseBinFindFirstArgs>(args?: SelectSubset<T, WarehouseBinFindFirstArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseBin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseBinFindFirstOrThrowArgs} args - Arguments to find a WarehouseBin
     * @example
     * // Get one WarehouseBin
     * const warehouseBin = await prisma.warehouseBin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseBinFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseBinFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WarehouseBins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseBinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarehouseBins
     * const warehouseBins = await prisma.warehouseBin.findMany()
     * 
     * // Get first 10 WarehouseBins
     * const warehouseBins = await prisma.warehouseBin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseBinWithIdOnly = await prisma.warehouseBin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseBinFindManyArgs>(args?: SelectSubset<T, WarehouseBinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WarehouseBin.
     * @param {WarehouseBinCreateArgs} args - Arguments to create a WarehouseBin.
     * @example
     * // Create one WarehouseBin
     * const WarehouseBin = await prisma.warehouseBin.create({
     *   data: {
     *     // ... data to create a WarehouseBin
     *   }
     * })
     * 
     */
    create<T extends WarehouseBinCreateArgs>(args: SelectSubset<T, WarehouseBinCreateArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WarehouseBins.
     * @param {WarehouseBinCreateManyArgs} args - Arguments to create many WarehouseBins.
     * @example
     * // Create many WarehouseBins
     * const warehouseBin = await prisma.warehouseBin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseBinCreateManyArgs>(args?: SelectSubset<T, WarehouseBinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WarehouseBins and returns the data saved in the database.
     * @param {WarehouseBinCreateManyAndReturnArgs} args - Arguments to create many WarehouseBins.
     * @example
     * // Create many WarehouseBins
     * const warehouseBin = await prisma.warehouseBin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WarehouseBins and only return the `id`
     * const warehouseBinWithIdOnly = await prisma.warehouseBin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseBinCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseBinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WarehouseBin.
     * @param {WarehouseBinDeleteArgs} args - Arguments to delete one WarehouseBin.
     * @example
     * // Delete one WarehouseBin
     * const WarehouseBin = await prisma.warehouseBin.delete({
     *   where: {
     *     // ... filter to delete one WarehouseBin
     *   }
     * })
     * 
     */
    delete<T extends WarehouseBinDeleteArgs>(args: SelectSubset<T, WarehouseBinDeleteArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WarehouseBin.
     * @param {WarehouseBinUpdateArgs} args - Arguments to update one WarehouseBin.
     * @example
     * // Update one WarehouseBin
     * const warehouseBin = await prisma.warehouseBin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseBinUpdateArgs>(args: SelectSubset<T, WarehouseBinUpdateArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WarehouseBins.
     * @param {WarehouseBinDeleteManyArgs} args - Arguments to filter WarehouseBins to delete.
     * @example
     * // Delete a few WarehouseBins
     * const { count } = await prisma.warehouseBin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseBinDeleteManyArgs>(args?: SelectSubset<T, WarehouseBinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseBins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseBinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarehouseBins
     * const warehouseBin = await prisma.warehouseBin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseBinUpdateManyArgs>(args: SelectSubset<T, WarehouseBinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseBins and returns the data updated in the database.
     * @param {WarehouseBinUpdateManyAndReturnArgs} args - Arguments to update many WarehouseBins.
     * @example
     * // Update many WarehouseBins
     * const warehouseBin = await prisma.warehouseBin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WarehouseBins and only return the `id`
     * const warehouseBinWithIdOnly = await prisma.warehouseBin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseBinUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseBinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WarehouseBin.
     * @param {WarehouseBinUpsertArgs} args - Arguments to update or create a WarehouseBin.
     * @example
     * // Update or create a WarehouseBin
     * const warehouseBin = await prisma.warehouseBin.upsert({
     *   create: {
     *     // ... data to create a WarehouseBin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarehouseBin we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseBinUpsertArgs>(args: SelectSubset<T, WarehouseBinUpsertArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WarehouseBins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseBinCountArgs} args - Arguments to filter WarehouseBins to count.
     * @example
     * // Count the number of WarehouseBins
     * const count = await prisma.warehouseBin.count({
     *   where: {
     *     // ... the filter for the WarehouseBins we want to count
     *   }
     * })
    **/
    count<T extends WarehouseBinCountArgs>(
      args?: Subset<T, WarehouseBinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseBinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarehouseBin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseBinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseBinAggregateArgs>(args: Subset<T, WarehouseBinAggregateArgs>): Prisma.PrismaPromise<GetWarehouseBinAggregateType<T>>

    /**
     * Group by WarehouseBin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseBinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseBinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseBinGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseBinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseBinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseBinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarehouseBin model
   */
  readonly fields: WarehouseBinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarehouseBin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseBinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shelf<T extends WarehouseShelfDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseShelfDefaultArgs<ExtArgs>>): Prisma__WarehouseShelfClient<$Result.GetResult<Prisma.$WarehouseShelfPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventoryItems<T extends WarehouseBin$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseBin$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WarehouseBin model
   */
  interface WarehouseBinFieldRefs {
    readonly id: FieldRef<"WarehouseBin", 'String'>
    readonly name: FieldRef<"WarehouseBin", 'String'>
    readonly code: FieldRef<"WarehouseBin", 'String'>
    readonly shelfId: FieldRef<"WarehouseBin", 'String'>
    readonly capacity: FieldRef<"WarehouseBin", 'Int'>
    readonly createdAt: FieldRef<"WarehouseBin", 'DateTime'>
    readonly updatedAt: FieldRef<"WarehouseBin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WarehouseBin findUnique
   */
  export type WarehouseBinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseBin to fetch.
     */
    where: WarehouseBinWhereUniqueInput
  }

  /**
   * WarehouseBin findUniqueOrThrow
   */
  export type WarehouseBinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseBin to fetch.
     */
    where: WarehouseBinWhereUniqueInput
  }

  /**
   * WarehouseBin findFirst
   */
  export type WarehouseBinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseBin to fetch.
     */
    where?: WarehouseBinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseBins to fetch.
     */
    orderBy?: WarehouseBinOrderByWithRelationInput | WarehouseBinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseBins.
     */
    cursor?: WarehouseBinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseBins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseBins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseBins.
     */
    distinct?: WarehouseBinScalarFieldEnum | WarehouseBinScalarFieldEnum[]
  }

  /**
   * WarehouseBin findFirstOrThrow
   */
  export type WarehouseBinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseBin to fetch.
     */
    where?: WarehouseBinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseBins to fetch.
     */
    orderBy?: WarehouseBinOrderByWithRelationInput | WarehouseBinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseBins.
     */
    cursor?: WarehouseBinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseBins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseBins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseBins.
     */
    distinct?: WarehouseBinScalarFieldEnum | WarehouseBinScalarFieldEnum[]
  }

  /**
   * WarehouseBin findMany
   */
  export type WarehouseBinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseBins to fetch.
     */
    where?: WarehouseBinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseBins to fetch.
     */
    orderBy?: WarehouseBinOrderByWithRelationInput | WarehouseBinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarehouseBins.
     */
    cursor?: WarehouseBinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseBins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseBins.
     */
    skip?: number
    distinct?: WarehouseBinScalarFieldEnum | WarehouseBinScalarFieldEnum[]
  }

  /**
   * WarehouseBin create
   */
  export type WarehouseBinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * The data needed to create a WarehouseBin.
     */
    data: XOR<WarehouseBinCreateInput, WarehouseBinUncheckedCreateInput>
  }

  /**
   * WarehouseBin createMany
   */
  export type WarehouseBinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarehouseBins.
     */
    data: WarehouseBinCreateManyInput | WarehouseBinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WarehouseBin createManyAndReturn
   */
  export type WarehouseBinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * The data used to create many WarehouseBins.
     */
    data: WarehouseBinCreateManyInput | WarehouseBinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseBin update
   */
  export type WarehouseBinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * The data needed to update a WarehouseBin.
     */
    data: XOR<WarehouseBinUpdateInput, WarehouseBinUncheckedUpdateInput>
    /**
     * Choose, which WarehouseBin to update.
     */
    where: WarehouseBinWhereUniqueInput
  }

  /**
   * WarehouseBin updateMany
   */
  export type WarehouseBinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarehouseBins.
     */
    data: XOR<WarehouseBinUpdateManyMutationInput, WarehouseBinUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseBins to update
     */
    where?: WarehouseBinWhereInput
    /**
     * Limit how many WarehouseBins to update.
     */
    limit?: number
  }

  /**
   * WarehouseBin updateManyAndReturn
   */
  export type WarehouseBinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * The data used to update WarehouseBins.
     */
    data: XOR<WarehouseBinUpdateManyMutationInput, WarehouseBinUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseBins to update
     */
    where?: WarehouseBinWhereInput
    /**
     * Limit how many WarehouseBins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseBin upsert
   */
  export type WarehouseBinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * The filter to search for the WarehouseBin to update in case it exists.
     */
    where: WarehouseBinWhereUniqueInput
    /**
     * In case the WarehouseBin found by the `where` argument doesn't exist, create a new WarehouseBin with this data.
     */
    create: XOR<WarehouseBinCreateInput, WarehouseBinUncheckedCreateInput>
    /**
     * In case the WarehouseBin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseBinUpdateInput, WarehouseBinUncheckedUpdateInput>
  }

  /**
   * WarehouseBin delete
   */
  export type WarehouseBinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    /**
     * Filter which WarehouseBin to delete.
     */
    where: WarehouseBinWhereUniqueInput
  }

  /**
   * WarehouseBin deleteMany
   */
  export type WarehouseBinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseBins to delete
     */
    where?: WarehouseBinWhereInput
    /**
     * Limit how many WarehouseBins to delete.
     */
    limit?: number
  }

  /**
   * WarehouseBin.inventoryItems
   */
  export type WarehouseBin$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * WarehouseBin without action
   */
  export type WarehouseBinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
  }


  /**
   * Model WarehouseStaff
   */

  export type AggregateWarehouseStaff = {
    _count: WarehouseStaffCountAggregateOutputType | null
    _min: WarehouseStaffMinAggregateOutputType | null
    _max: WarehouseStaffMaxAggregateOutputType | null
  }

  export type WarehouseStaffMinAggregateOutputType = {
    id: string | null
    userId: string | null
    warehouseId: string | null
    position: string | null
    isManager: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseStaffMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    warehouseId: string | null
    position: string | null
    isManager: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseStaffCountAggregateOutputType = {
    id: number
    userId: number
    warehouseId: number
    position: number
    isManager: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseStaffMinAggregateInputType = {
    id?: true
    userId?: true
    warehouseId?: true
    position?: true
    isManager?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseStaffMaxAggregateInputType = {
    id?: true
    userId?: true
    warehouseId?: true
    position?: true
    isManager?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseStaffCountAggregateInputType = {
    id?: true
    userId?: true
    warehouseId?: true
    position?: true
    isManager?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseStaff to aggregate.
     */
    where?: WarehouseStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseStaffs to fetch.
     */
    orderBy?: WarehouseStaffOrderByWithRelationInput | WarehouseStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarehouseStaffs
    **/
    _count?: true | WarehouseStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseStaffMaxAggregateInputType
  }

  export type GetWarehouseStaffAggregateType<T extends WarehouseStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouseStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouseStaff[P]>
      : GetScalarType<T[P], AggregateWarehouseStaff[P]>
  }




  export type WarehouseStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseStaffWhereInput
    orderBy?: WarehouseStaffOrderByWithAggregationInput | WarehouseStaffOrderByWithAggregationInput[]
    by: WarehouseStaffScalarFieldEnum[] | WarehouseStaffScalarFieldEnum
    having?: WarehouseStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseStaffCountAggregateInputType | true
    _min?: WarehouseStaffMinAggregateInputType
    _max?: WarehouseStaffMaxAggregateInputType
  }

  export type WarehouseStaffGroupByOutputType = {
    id: string
    userId: string
    warehouseId: string
    position: string | null
    isManager: boolean
    createdAt: Date
    updatedAt: Date
    _count: WarehouseStaffCountAggregateOutputType | null
    _min: WarehouseStaffMinAggregateOutputType | null
    _max: WarehouseStaffMaxAggregateOutputType | null
  }

  type GetWarehouseStaffGroupByPayload<T extends WarehouseStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseStaffGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseStaffGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    warehouseId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseStaff"]>

  export type WarehouseStaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    warehouseId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseStaff"]>

  export type WarehouseStaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    warehouseId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseStaff"]>

  export type WarehouseStaffSelectScalar = {
    id?: boolean
    userId?: boolean
    warehouseId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseStaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "warehouseId" | "position" | "isManager" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouseStaff"]>
  export type WarehouseStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type WarehouseStaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type WarehouseStaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }

  export type $WarehouseStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarehouseStaff"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      warehouseId: string
      position: string | null
      isManager: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouseStaff"]>
    composites: {}
  }

  type WarehouseStaffGetPayload<S extends boolean | null | undefined | WarehouseStaffDefaultArgs> = $Result.GetResult<Prisma.$WarehouseStaffPayload, S>

  type WarehouseStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseStaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseStaffCountAggregateInputType | true
    }

  export interface WarehouseStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarehouseStaff'], meta: { name: 'WarehouseStaff' } }
    /**
     * Find zero or one WarehouseStaff that matches the filter.
     * @param {WarehouseStaffFindUniqueArgs} args - Arguments to find a WarehouseStaff
     * @example
     * // Get one WarehouseStaff
     * const warehouseStaff = await prisma.warehouseStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseStaffFindUniqueArgs>(args: SelectSubset<T, WarehouseStaffFindUniqueArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WarehouseStaff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseStaffFindUniqueOrThrowArgs} args - Arguments to find a WarehouseStaff
     * @example
     * // Get one WarehouseStaff
     * const warehouseStaff = await prisma.warehouseStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseStaffFindFirstArgs} args - Arguments to find a WarehouseStaff
     * @example
     * // Get one WarehouseStaff
     * const warehouseStaff = await prisma.warehouseStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseStaffFindFirstArgs>(args?: SelectSubset<T, WarehouseStaffFindFirstArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarehouseStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseStaffFindFirstOrThrowArgs} args - Arguments to find a WarehouseStaff
     * @example
     * // Get one WarehouseStaff
     * const warehouseStaff = await prisma.warehouseStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WarehouseStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarehouseStaffs
     * const warehouseStaffs = await prisma.warehouseStaff.findMany()
     * 
     * // Get first 10 WarehouseStaffs
     * const warehouseStaffs = await prisma.warehouseStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseStaffWithIdOnly = await prisma.warehouseStaff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseStaffFindManyArgs>(args?: SelectSubset<T, WarehouseStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WarehouseStaff.
     * @param {WarehouseStaffCreateArgs} args - Arguments to create a WarehouseStaff.
     * @example
     * // Create one WarehouseStaff
     * const WarehouseStaff = await prisma.warehouseStaff.create({
     *   data: {
     *     // ... data to create a WarehouseStaff
     *   }
     * })
     * 
     */
    create<T extends WarehouseStaffCreateArgs>(args: SelectSubset<T, WarehouseStaffCreateArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WarehouseStaffs.
     * @param {WarehouseStaffCreateManyArgs} args - Arguments to create many WarehouseStaffs.
     * @example
     * // Create many WarehouseStaffs
     * const warehouseStaff = await prisma.warehouseStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseStaffCreateManyArgs>(args?: SelectSubset<T, WarehouseStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WarehouseStaffs and returns the data saved in the database.
     * @param {WarehouseStaffCreateManyAndReturnArgs} args - Arguments to create many WarehouseStaffs.
     * @example
     * // Create many WarehouseStaffs
     * const warehouseStaff = await prisma.warehouseStaff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WarehouseStaffs and only return the `id`
     * const warehouseStaffWithIdOnly = await prisma.warehouseStaff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseStaffCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseStaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WarehouseStaff.
     * @param {WarehouseStaffDeleteArgs} args - Arguments to delete one WarehouseStaff.
     * @example
     * // Delete one WarehouseStaff
     * const WarehouseStaff = await prisma.warehouseStaff.delete({
     *   where: {
     *     // ... filter to delete one WarehouseStaff
     *   }
     * })
     * 
     */
    delete<T extends WarehouseStaffDeleteArgs>(args: SelectSubset<T, WarehouseStaffDeleteArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WarehouseStaff.
     * @param {WarehouseStaffUpdateArgs} args - Arguments to update one WarehouseStaff.
     * @example
     * // Update one WarehouseStaff
     * const warehouseStaff = await prisma.warehouseStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseStaffUpdateArgs>(args: SelectSubset<T, WarehouseStaffUpdateArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WarehouseStaffs.
     * @param {WarehouseStaffDeleteManyArgs} args - Arguments to filter WarehouseStaffs to delete.
     * @example
     * // Delete a few WarehouseStaffs
     * const { count } = await prisma.warehouseStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseStaffDeleteManyArgs>(args?: SelectSubset<T, WarehouseStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarehouseStaffs
     * const warehouseStaff = await prisma.warehouseStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseStaffUpdateManyArgs>(args: SelectSubset<T, WarehouseStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseStaffs and returns the data updated in the database.
     * @param {WarehouseStaffUpdateManyAndReturnArgs} args - Arguments to update many WarehouseStaffs.
     * @example
     * // Update many WarehouseStaffs
     * const warehouseStaff = await prisma.warehouseStaff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WarehouseStaffs and only return the `id`
     * const warehouseStaffWithIdOnly = await prisma.warehouseStaff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseStaffUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseStaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WarehouseStaff.
     * @param {WarehouseStaffUpsertArgs} args - Arguments to update or create a WarehouseStaff.
     * @example
     * // Update or create a WarehouseStaff
     * const warehouseStaff = await prisma.warehouseStaff.upsert({
     *   create: {
     *     // ... data to create a WarehouseStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarehouseStaff we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseStaffUpsertArgs>(args: SelectSubset<T, WarehouseStaffUpsertArgs<ExtArgs>>): Prisma__WarehouseStaffClient<$Result.GetResult<Prisma.$WarehouseStaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WarehouseStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseStaffCountArgs} args - Arguments to filter WarehouseStaffs to count.
     * @example
     * // Count the number of WarehouseStaffs
     * const count = await prisma.warehouseStaff.count({
     *   where: {
     *     // ... the filter for the WarehouseStaffs we want to count
     *   }
     * })
    **/
    count<T extends WarehouseStaffCountArgs>(
      args?: Subset<T, WarehouseStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarehouseStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseStaffAggregateArgs>(args: Subset<T, WarehouseStaffAggregateArgs>): Prisma.PrismaPromise<GetWarehouseStaffAggregateType<T>>

    /**
     * Group by WarehouseStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseStaffGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarehouseStaff model
   */
  readonly fields: WarehouseStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarehouseStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WarehouseStaff model
   */
  interface WarehouseStaffFieldRefs {
    readonly id: FieldRef<"WarehouseStaff", 'String'>
    readonly userId: FieldRef<"WarehouseStaff", 'String'>
    readonly warehouseId: FieldRef<"WarehouseStaff", 'String'>
    readonly position: FieldRef<"WarehouseStaff", 'String'>
    readonly isManager: FieldRef<"WarehouseStaff", 'Boolean'>
    readonly createdAt: FieldRef<"WarehouseStaff", 'DateTime'>
    readonly updatedAt: FieldRef<"WarehouseStaff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WarehouseStaff findUnique
   */
  export type WarehouseStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseStaff to fetch.
     */
    where: WarehouseStaffWhereUniqueInput
  }

  /**
   * WarehouseStaff findUniqueOrThrow
   */
  export type WarehouseStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseStaff to fetch.
     */
    where: WarehouseStaffWhereUniqueInput
  }

  /**
   * WarehouseStaff findFirst
   */
  export type WarehouseStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseStaff to fetch.
     */
    where?: WarehouseStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseStaffs to fetch.
     */
    orderBy?: WarehouseStaffOrderByWithRelationInput | WarehouseStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseStaffs.
     */
    cursor?: WarehouseStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseStaffs.
     */
    distinct?: WarehouseStaffScalarFieldEnum | WarehouseStaffScalarFieldEnum[]
  }

  /**
   * WarehouseStaff findFirstOrThrow
   */
  export type WarehouseStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseStaff to fetch.
     */
    where?: WarehouseStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseStaffs to fetch.
     */
    orderBy?: WarehouseStaffOrderByWithRelationInput | WarehouseStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseStaffs.
     */
    cursor?: WarehouseStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseStaffs.
     */
    distinct?: WarehouseStaffScalarFieldEnum | WarehouseStaffScalarFieldEnum[]
  }

  /**
   * WarehouseStaff findMany
   */
  export type WarehouseStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseStaffs to fetch.
     */
    where?: WarehouseStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseStaffs to fetch.
     */
    orderBy?: WarehouseStaffOrderByWithRelationInput | WarehouseStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarehouseStaffs.
     */
    cursor?: WarehouseStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseStaffs.
     */
    skip?: number
    distinct?: WarehouseStaffScalarFieldEnum | WarehouseStaffScalarFieldEnum[]
  }

  /**
   * WarehouseStaff create
   */
  export type WarehouseStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a WarehouseStaff.
     */
    data: XOR<WarehouseStaffCreateInput, WarehouseStaffUncheckedCreateInput>
  }

  /**
   * WarehouseStaff createMany
   */
  export type WarehouseStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarehouseStaffs.
     */
    data: WarehouseStaffCreateManyInput | WarehouseStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WarehouseStaff createManyAndReturn
   */
  export type WarehouseStaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * The data used to create many WarehouseStaffs.
     */
    data: WarehouseStaffCreateManyInput | WarehouseStaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseStaff update
   */
  export type WarehouseStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a WarehouseStaff.
     */
    data: XOR<WarehouseStaffUpdateInput, WarehouseStaffUncheckedUpdateInput>
    /**
     * Choose, which WarehouseStaff to update.
     */
    where: WarehouseStaffWhereUniqueInput
  }

  /**
   * WarehouseStaff updateMany
   */
  export type WarehouseStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarehouseStaffs.
     */
    data: XOR<WarehouseStaffUpdateManyMutationInput, WarehouseStaffUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseStaffs to update
     */
    where?: WarehouseStaffWhereInput
    /**
     * Limit how many WarehouseStaffs to update.
     */
    limit?: number
  }

  /**
   * WarehouseStaff updateManyAndReturn
   */
  export type WarehouseStaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * The data used to update WarehouseStaffs.
     */
    data: XOR<WarehouseStaffUpdateManyMutationInput, WarehouseStaffUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseStaffs to update
     */
    where?: WarehouseStaffWhereInput
    /**
     * Limit how many WarehouseStaffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarehouseStaff upsert
   */
  export type WarehouseStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the WarehouseStaff to update in case it exists.
     */
    where: WarehouseStaffWhereUniqueInput
    /**
     * In case the WarehouseStaff found by the `where` argument doesn't exist, create a new WarehouseStaff with this data.
     */
    create: XOR<WarehouseStaffCreateInput, WarehouseStaffUncheckedCreateInput>
    /**
     * In case the WarehouseStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseStaffUpdateInput, WarehouseStaffUncheckedUpdateInput>
  }

  /**
   * WarehouseStaff delete
   */
  export type WarehouseStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
    /**
     * Filter which WarehouseStaff to delete.
     */
    where: WarehouseStaffWhereUniqueInput
  }

  /**
   * WarehouseStaff deleteMany
   */
  export type WarehouseStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseStaffs to delete
     */
    where?: WarehouseStaffWhereInput
    /**
     * Limit how many WarehouseStaffs to delete.
     */
    limit?: number
  }

  /**
   * WarehouseStaff without action
   */
  export type WarehouseStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseStaff
     */
    select?: WarehouseStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseStaff
     */
    omit?: WarehouseStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseStaffInclude<ExtArgs> | null
  }


  /**
   * Model Store
   */

  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    address: string | null
    phone: string | null
    email: string | null
    openingHours: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    address: string | null
    phone: string | null
    email: string | null
    openingHours: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreCountAggregateOutputType = {
    id: number
    name: number
    code: number
    address: number
    phone: number
    email: number
    openingHours: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    address?: true
    phone?: true
    email?: true
    openingHours?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    address?: true
    phone?: true
    email?: true
    openingHours?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    address?: true
    phone?: true
    email?: true
    openingHours?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Store to aggregate.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type StoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithAggregationInput | StoreOrderByWithAggregationInput[]
    by: StoreScalarFieldEnum[] | StoreScalarFieldEnum
    having?: StoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }

  export type StoreGroupByOutputType = {
    id: string
    name: string
    code: string
    address: string | null
    phone: string | null
    email: string | null
    openingHours: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StoreCountAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends StoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type StoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    openingHours?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventoryItems?: boolean | Store$inventoryItemsArgs<ExtArgs>
    sales?: boolean | Store$salesArgs<ExtArgs>
    returns?: boolean | Store$returnsArgs<ExtArgs>
    staff?: boolean | Store$staffArgs<ExtArgs>
    transfersFrom?: boolean | Store$transfersFromArgs<ExtArgs>
    transfersTo?: boolean | Store$transfersToArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    openingHours?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["store"]>

  export type StoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    openingHours?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["store"]>

  export type StoreSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    openingHours?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "address" | "phone" | "email" | "openingHours" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["store"]>
  export type StoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | Store$inventoryItemsArgs<ExtArgs>
    sales?: boolean | Store$salesArgs<ExtArgs>
    returns?: boolean | Store$returnsArgs<ExtArgs>
    staff?: boolean | Store$staffArgs<ExtArgs>
    transfersFrom?: boolean | Store$transfersFromArgs<ExtArgs>
    transfersTo?: boolean | Store$transfersToArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Store"
    objects: {
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      sales: Prisma.$SalePayload<ExtArgs>[]
      returns: Prisma.$ReturnPayload<ExtArgs>[]
      staff: Prisma.$StoreStaffPayload<ExtArgs>[]
      transfersFrom: Prisma.$TransferPayload<ExtArgs>[]
      transfersTo: Prisma.$TransferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      address: string | null
      phone: string | null
      email: string | null
      openingHours: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["store"]>
    composites: {}
  }

  type StoreGetPayload<S extends boolean | null | undefined | StoreDefaultArgs> = $Result.GetResult<Prisma.$StorePayload, S>

  type StoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface StoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Store'], meta: { name: 'Store' } }
    /**
     * Find zero or one Store that matches the filter.
     * @param {StoreFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreFindUniqueArgs>(args: SelectSubset<T, StoreFindUniqueArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Store that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoreFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreFindFirstArgs>(args?: SelectSubset<T, StoreFindFirstArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeWithIdOnly = await prisma.store.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreFindManyArgs>(args?: SelectSubset<T, StoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Store.
     * @param {StoreCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
     */
    create<T extends StoreCreateArgs>(args: SelectSubset<T, StoreCreateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stores.
     * @param {StoreCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreCreateManyArgs>(args?: SelectSubset<T, StoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {StoreCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Store.
     * @param {StoreDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
     */
    delete<T extends StoreDeleteArgs>(args: SelectSubset<T, StoreDeleteArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Store.
     * @param {StoreUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreUpdateArgs>(args: SelectSubset<T, StoreUpdateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stores.
     * @param {StoreDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreDeleteManyArgs>(args?: SelectSubset<T, StoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreUpdateManyArgs>(args: SelectSubset<T, StoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores and returns the data updated in the database.
     * @param {StoreUpdateManyAndReturnArgs} args - Arguments to update many Stores.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoreUpdateManyAndReturnArgs>(args: SelectSubset<T, StoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Store.
     * @param {StoreUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
     */
    upsert<T extends StoreUpsertArgs>(args: SelectSubset<T, StoreUpsertArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoreCountArgs>(
      args?: Subset<T, StoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreGroupByArgs['orderBy'] }
        : { orderBy?: StoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Store model
   */
  readonly fields: StoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryItems<T extends Store$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Store$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends Store$salesArgs<ExtArgs> = {}>(args?: Subset<T, Store$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    returns<T extends Store$returnsArgs<ExtArgs> = {}>(args?: Subset<T, Store$returnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staff<T extends Store$staffArgs<ExtArgs> = {}>(args?: Subset<T, Store$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfersFrom<T extends Store$transfersFromArgs<ExtArgs> = {}>(args?: Subset<T, Store$transfersFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfersTo<T extends Store$transfersToArgs<ExtArgs> = {}>(args?: Subset<T, Store$transfersToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Store model
   */
  interface StoreFieldRefs {
    readonly id: FieldRef<"Store", 'String'>
    readonly name: FieldRef<"Store", 'String'>
    readonly code: FieldRef<"Store", 'String'>
    readonly address: FieldRef<"Store", 'String'>
    readonly phone: FieldRef<"Store", 'String'>
    readonly email: FieldRef<"Store", 'String'>
    readonly openingHours: FieldRef<"Store", 'String'>
    readonly isActive: FieldRef<"Store", 'Boolean'>
    readonly createdAt: FieldRef<"Store", 'DateTime'>
    readonly updatedAt: FieldRef<"Store", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Store findUnique
   */
  export type StoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findUniqueOrThrow
   */
  export type StoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findFirst
   */
  export type StoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findFirstOrThrow
   */
  export type StoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findMany
   */
  export type StoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store create
   */
  export type StoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Store.
     */
    data: XOR<StoreCreateInput, StoreUncheckedCreateInput>
  }

  /**
   * Store createMany
   */
  export type StoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Store createManyAndReturn
   */
  export type StoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Store update
   */
  export type StoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Store.
     */
    data: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
    /**
     * Choose, which Store to update.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store updateMany
   */
  export type StoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
  }

  /**
   * Store updateManyAndReturn
   */
  export type StoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
  }

  /**
   * Store upsert
   */
  export type StoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Store to update in case it exists.
     */
    where: StoreWhereUniqueInput
    /**
     * In case the Store found by the `where` argument doesn't exist, create a new Store with this data.
     */
    create: XOR<StoreCreateInput, StoreUncheckedCreateInput>
    /**
     * In case the Store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
  }

  /**
   * Store delete
   */
  export type StoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter which Store to delete.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store deleteMany
   */
  export type StoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to delete.
     */
    limit?: number
  }

  /**
   * Store.inventoryItems
   */
  export type Store$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Store.sales
   */
  export type Store$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Store.returns
   */
  export type Store$returnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnInclude<ExtArgs> | null
    where?: ReturnWhereInput
    orderBy?: ReturnOrderByWithRelationInput | ReturnOrderByWithRelationInput[]
    cursor?: ReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnScalarFieldEnum | ReturnScalarFieldEnum[]
  }

  /**
   * Store.staff
   */
  export type Store$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    where?: StoreStaffWhereInput
    orderBy?: StoreStaffOrderByWithRelationInput | StoreStaffOrderByWithRelationInput[]
    cursor?: StoreStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreStaffScalarFieldEnum | StoreStaffScalarFieldEnum[]
  }

  /**
   * Store.transfersFrom
   */
  export type Store$transfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Store.transfersTo
   */
  export type Store$transfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Store without action
   */
  export type StoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
  }


  /**
   * Model StoreStaff
   */

  export type AggregateStoreStaff = {
    _count: StoreStaffCountAggregateOutputType | null
    _min: StoreStaffMinAggregateOutputType | null
    _max: StoreStaffMaxAggregateOutputType | null
  }

  export type StoreStaffMinAggregateOutputType = {
    id: string | null
    userId: string | null
    storeId: string | null
    position: string | null
    isManager: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreStaffMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    storeId: string | null
    position: string | null
    isManager: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreStaffCountAggregateOutputType = {
    id: number
    userId: number
    storeId: number
    position: number
    isManager: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreStaffMinAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
    position?: true
    isManager?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreStaffMaxAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
    position?: true
    isManager?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreStaffCountAggregateInputType = {
    id?: true
    userId?: true
    storeId?: true
    position?: true
    isManager?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreStaff to aggregate.
     */
    where?: StoreStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreStaffs to fetch.
     */
    orderBy?: StoreStaffOrderByWithRelationInput | StoreStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreStaffs
    **/
    _count?: true | StoreStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreStaffMaxAggregateInputType
  }

  export type GetStoreStaffAggregateType<T extends StoreStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreStaff[P]>
      : GetScalarType<T[P], AggregateStoreStaff[P]>
  }




  export type StoreStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreStaffWhereInput
    orderBy?: StoreStaffOrderByWithAggregationInput | StoreStaffOrderByWithAggregationInput[]
    by: StoreStaffScalarFieldEnum[] | StoreStaffScalarFieldEnum
    having?: StoreStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreStaffCountAggregateInputType | true
    _min?: StoreStaffMinAggregateInputType
    _max?: StoreStaffMaxAggregateInputType
  }

  export type StoreStaffGroupByOutputType = {
    id: string
    userId: string
    storeId: string
    position: string | null
    isManager: boolean
    createdAt: Date
    updatedAt: Date
    _count: StoreStaffCountAggregateOutputType | null
    _min: StoreStaffMinAggregateOutputType | null
    _max: StoreStaffMaxAggregateOutputType | null
  }

  type GetStoreStaffGroupByPayload<T extends StoreStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreStaffGroupByOutputType[P]>
            : GetScalarType<T[P], StoreStaffGroupByOutputType[P]>
        }
      >
    >


  export type StoreStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storeId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeStaff"]>

  export type StoreStaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storeId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeStaff"]>

  export type StoreStaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    storeId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeStaff"]>

  export type StoreStaffSelectScalar = {
    id?: boolean
    userId?: boolean
    storeId?: boolean
    position?: boolean
    isManager?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreStaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "storeId" | "position" | "isManager" | "createdAt" | "updatedAt", ExtArgs["result"]["storeStaff"]>
  export type StoreStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type StoreStaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type StoreStaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $StoreStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreStaff"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      storeId: string
      position: string | null
      isManager: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storeStaff"]>
    composites: {}
  }

  type StoreStaffGetPayload<S extends boolean | null | undefined | StoreStaffDefaultArgs> = $Result.GetResult<Prisma.$StoreStaffPayload, S>

  type StoreStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoreStaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreStaffCountAggregateInputType | true
    }

  export interface StoreStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreStaff'], meta: { name: 'StoreStaff' } }
    /**
     * Find zero or one StoreStaff that matches the filter.
     * @param {StoreStaffFindUniqueArgs} args - Arguments to find a StoreStaff
     * @example
     * // Get one StoreStaff
     * const storeStaff = await prisma.storeStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreStaffFindUniqueArgs>(args: SelectSubset<T, StoreStaffFindUniqueArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoreStaff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoreStaffFindUniqueOrThrowArgs} args - Arguments to find a StoreStaff
     * @example
     * // Get one StoreStaff
     * const storeStaff = await prisma.storeStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoreStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStaffFindFirstArgs} args - Arguments to find a StoreStaff
     * @example
     * // Get one StoreStaff
     * const storeStaff = await prisma.storeStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreStaffFindFirstArgs>(args?: SelectSubset<T, StoreStaffFindFirstArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoreStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStaffFindFirstOrThrowArgs} args - Arguments to find a StoreStaff
     * @example
     * // Get one StoreStaff
     * const storeStaff = await prisma.storeStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoreStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreStaffs
     * const storeStaffs = await prisma.storeStaff.findMany()
     * 
     * // Get first 10 StoreStaffs
     * const storeStaffs = await prisma.storeStaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeStaffWithIdOnly = await prisma.storeStaff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreStaffFindManyArgs>(args?: SelectSubset<T, StoreStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoreStaff.
     * @param {StoreStaffCreateArgs} args - Arguments to create a StoreStaff.
     * @example
     * // Create one StoreStaff
     * const StoreStaff = await prisma.storeStaff.create({
     *   data: {
     *     // ... data to create a StoreStaff
     *   }
     * })
     * 
     */
    create<T extends StoreStaffCreateArgs>(args: SelectSubset<T, StoreStaffCreateArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoreStaffs.
     * @param {StoreStaffCreateManyArgs} args - Arguments to create many StoreStaffs.
     * @example
     * // Create many StoreStaffs
     * const storeStaff = await prisma.storeStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreStaffCreateManyArgs>(args?: SelectSubset<T, StoreStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreStaffs and returns the data saved in the database.
     * @param {StoreStaffCreateManyAndReturnArgs} args - Arguments to create many StoreStaffs.
     * @example
     * // Create many StoreStaffs
     * const storeStaff = await prisma.storeStaff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreStaffs and only return the `id`
     * const storeStaffWithIdOnly = await prisma.storeStaff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreStaffCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreStaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StoreStaff.
     * @param {StoreStaffDeleteArgs} args - Arguments to delete one StoreStaff.
     * @example
     * // Delete one StoreStaff
     * const StoreStaff = await prisma.storeStaff.delete({
     *   where: {
     *     // ... filter to delete one StoreStaff
     *   }
     * })
     * 
     */
    delete<T extends StoreStaffDeleteArgs>(args: SelectSubset<T, StoreStaffDeleteArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoreStaff.
     * @param {StoreStaffUpdateArgs} args - Arguments to update one StoreStaff.
     * @example
     * // Update one StoreStaff
     * const storeStaff = await prisma.storeStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreStaffUpdateArgs>(args: SelectSubset<T, StoreStaffUpdateArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoreStaffs.
     * @param {StoreStaffDeleteManyArgs} args - Arguments to filter StoreStaffs to delete.
     * @example
     * // Delete a few StoreStaffs
     * const { count } = await prisma.storeStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreStaffDeleteManyArgs>(args?: SelectSubset<T, StoreStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreStaffs
     * const storeStaff = await prisma.storeStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreStaffUpdateManyArgs>(args: SelectSubset<T, StoreStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreStaffs and returns the data updated in the database.
     * @param {StoreStaffUpdateManyAndReturnArgs} args - Arguments to update many StoreStaffs.
     * @example
     * // Update many StoreStaffs
     * const storeStaff = await prisma.storeStaff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StoreStaffs and only return the `id`
     * const storeStaffWithIdOnly = await prisma.storeStaff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoreStaffUpdateManyAndReturnArgs>(args: SelectSubset<T, StoreStaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StoreStaff.
     * @param {StoreStaffUpsertArgs} args - Arguments to update or create a StoreStaff.
     * @example
     * // Update or create a StoreStaff
     * const storeStaff = await prisma.storeStaff.upsert({
     *   create: {
     *     // ... data to create a StoreStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreStaff we want to update
     *   }
     * })
     */
    upsert<T extends StoreStaffUpsertArgs>(args: SelectSubset<T, StoreStaffUpsertArgs<ExtArgs>>): Prisma__StoreStaffClient<$Result.GetResult<Prisma.$StoreStaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoreStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStaffCountArgs} args - Arguments to filter StoreStaffs to count.
     * @example
     * // Count the number of StoreStaffs
     * const count = await prisma.storeStaff.count({
     *   where: {
     *     // ... the filter for the StoreStaffs we want to count
     *   }
     * })
    **/
    count<T extends StoreStaffCountArgs>(
      args?: Subset<T, StoreStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreStaffAggregateArgs>(args: Subset<T, StoreStaffAggregateArgs>): Prisma.PrismaPromise<GetStoreStaffAggregateType<T>>

    /**
     * Group by StoreStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreStaffGroupByArgs['orderBy'] }
        : { orderBy?: StoreStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreStaff model
   */
  readonly fields: StoreStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreStaff model
   */
  interface StoreStaffFieldRefs {
    readonly id: FieldRef<"StoreStaff", 'String'>
    readonly userId: FieldRef<"StoreStaff", 'String'>
    readonly storeId: FieldRef<"StoreStaff", 'String'>
    readonly position: FieldRef<"StoreStaff", 'String'>
    readonly isManager: FieldRef<"StoreStaff", 'Boolean'>
    readonly createdAt: FieldRef<"StoreStaff", 'DateTime'>
    readonly updatedAt: FieldRef<"StoreStaff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoreStaff findUnique
   */
  export type StoreStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * Filter, which StoreStaff to fetch.
     */
    where: StoreStaffWhereUniqueInput
  }

  /**
   * StoreStaff findUniqueOrThrow
   */
  export type StoreStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * Filter, which StoreStaff to fetch.
     */
    where: StoreStaffWhereUniqueInput
  }

  /**
   * StoreStaff findFirst
   */
  export type StoreStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * Filter, which StoreStaff to fetch.
     */
    where?: StoreStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreStaffs to fetch.
     */
    orderBy?: StoreStaffOrderByWithRelationInput | StoreStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreStaffs.
     */
    cursor?: StoreStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreStaffs.
     */
    distinct?: StoreStaffScalarFieldEnum | StoreStaffScalarFieldEnum[]
  }

  /**
   * StoreStaff findFirstOrThrow
   */
  export type StoreStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * Filter, which StoreStaff to fetch.
     */
    where?: StoreStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreStaffs to fetch.
     */
    orderBy?: StoreStaffOrderByWithRelationInput | StoreStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreStaffs.
     */
    cursor?: StoreStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreStaffs.
     */
    distinct?: StoreStaffScalarFieldEnum | StoreStaffScalarFieldEnum[]
  }

  /**
   * StoreStaff findMany
   */
  export type StoreStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * Filter, which StoreStaffs to fetch.
     */
    where?: StoreStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreStaffs to fetch.
     */
    orderBy?: StoreStaffOrderByWithRelationInput | StoreStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreStaffs.
     */
    cursor?: StoreStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreStaffs.
     */
    skip?: number
    distinct?: StoreStaffScalarFieldEnum | StoreStaffScalarFieldEnum[]
  }

  /**
   * StoreStaff create
   */
  export type StoreStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreStaff.
     */
    data: XOR<StoreStaffCreateInput, StoreStaffUncheckedCreateInput>
  }

  /**
   * StoreStaff createMany
   */
  export type StoreStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreStaffs.
     */
    data: StoreStaffCreateManyInput | StoreStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreStaff createManyAndReturn
   */
  export type StoreStaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * The data used to create many StoreStaffs.
     */
    data: StoreStaffCreateManyInput | StoreStaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreStaff update
   */
  export type StoreStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreStaff.
     */
    data: XOR<StoreStaffUpdateInput, StoreStaffUncheckedUpdateInput>
    /**
     * Choose, which StoreStaff to update.
     */
    where: StoreStaffWhereUniqueInput
  }

  /**
   * StoreStaff updateMany
   */
  export type StoreStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreStaffs.
     */
    data: XOR<StoreStaffUpdateManyMutationInput, StoreStaffUncheckedUpdateManyInput>
    /**
     * Filter which StoreStaffs to update
     */
    where?: StoreStaffWhereInput
    /**
     * Limit how many StoreStaffs to update.
     */
    limit?: number
  }

  /**
   * StoreStaff updateManyAndReturn
   */
  export type StoreStaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * The data used to update StoreStaffs.
     */
    data: XOR<StoreStaffUpdateManyMutationInput, StoreStaffUncheckedUpdateManyInput>
    /**
     * Filter which StoreStaffs to update
     */
    where?: StoreStaffWhereInput
    /**
     * Limit how many StoreStaffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreStaff upsert
   */
  export type StoreStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreStaff to update in case it exists.
     */
    where: StoreStaffWhereUniqueInput
    /**
     * In case the StoreStaff found by the `where` argument doesn't exist, create a new StoreStaff with this data.
     */
    create: XOR<StoreStaffCreateInput, StoreStaffUncheckedCreateInput>
    /**
     * In case the StoreStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreStaffUpdateInput, StoreStaffUncheckedUpdateInput>
  }

  /**
   * StoreStaff delete
   */
  export type StoreStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
    /**
     * Filter which StoreStaff to delete.
     */
    where: StoreStaffWhereUniqueInput
  }

  /**
   * StoreStaff deleteMany
   */
  export type StoreStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreStaffs to delete
     */
    where?: StoreStaffWhereInput
    /**
     * Limit how many StoreStaffs to delete.
     */
    limit?: number
  }

  /**
   * StoreStaff without action
   */
  export type StoreStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreStaff
     */
    select?: StoreStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoreStaff
     */
    omit?: StoreStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreStaffInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    rating: number | null
  }

  export type SupplierSumAggregateOutputType = {
    rating: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    taxId: string | null
    paymentTerms: string | null
    notes: string | null
    rating: number | null
    isActive: boolean | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    taxId: string | null
    paymentTerms: string | null
    notes: string | null
    rating: number | null
    isActive: boolean | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    name: number
    contactPerson: number
    email: number
    phone: number
    address: number
    city: number
    state: number
    postalCode: number
    country: number
    taxId: number
    paymentTerms: number
    notes: number
    rating: number
    isActive: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    rating?: true
  }

  export type SupplierSumAggregateInputType = {
    rating?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    taxId?: true
    paymentTerms?: true
    notes?: true
    rating?: true
    isActive?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    taxId?: true
    paymentTerms?: true
    notes?: true
    rating?: true
    isActive?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    taxId?: true
    paymentTerms?: true
    notes?: true
    rating?: true
    isActive?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    name: string
    contactPerson: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    taxId: string | null
    paymentTerms: string | null
    notes: string | null
    rating: number | null
    isActive: boolean
    createdById: string | null
    updatedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    taxId?: boolean
    paymentTerms?: boolean
    notes?: boolean
    rating?: boolean
    isActive?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Supplier$productsArgs<ExtArgs>
    contracts?: boolean | Supplier$contractsArgs<ExtArgs>
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    performanceMetrics?: boolean | Supplier$performanceMetricsArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    taxId?: boolean
    paymentTerms?: boolean
    notes?: boolean
    rating?: boolean
    isActive?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    taxId?: boolean
    paymentTerms?: boolean
    notes?: boolean
    rating?: boolean
    isActive?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    taxId?: boolean
    paymentTerms?: boolean
    notes?: boolean
    rating?: boolean
    isActive?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "contactPerson" | "email" | "phone" | "address" | "city" | "state" | "postalCode" | "country" | "taxId" | "paymentTerms" | "notes" | "rating" | "isActive" | "createdById" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Supplier$productsArgs<ExtArgs>
    contracts?: boolean | Supplier$contractsArgs<ExtArgs>
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    performanceMetrics?: boolean | Supplier$performanceMetricsArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      contracts: Prisma.$SupplierContractPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      performanceMetrics: Prisma.$SupplierPerformanceMetricPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contactPerson: string | null
      email: string | null
      phone: string | null
      address: string | null
      city: string | null
      state: string | null
      postalCode: string | null
      country: string | null
      taxId: string | null
      paymentTerms: string | null
      notes: string | null
      rating: number | null
      isActive: boolean
      createdById: string | null
      updatedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Supplier$productsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contracts<T extends Supplier$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends Supplier$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    performanceMetrics<T extends Supplier$performanceMetricsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$performanceMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPerformanceMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly contactPerson: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly city: FieldRef<"Supplier", 'String'>
    readonly state: FieldRef<"Supplier", 'String'>
    readonly postalCode: FieldRef<"Supplier", 'String'>
    readonly country: FieldRef<"Supplier", 'String'>
    readonly taxId: FieldRef<"Supplier", 'String'>
    readonly paymentTerms: FieldRef<"Supplier", 'String'>
    readonly notes: FieldRef<"Supplier", 'String'>
    readonly rating: FieldRef<"Supplier", 'Int'>
    readonly isActive: FieldRef<"Supplier", 'Boolean'>
    readonly createdById: FieldRef<"Supplier", 'String'>
    readonly updatedById: FieldRef<"Supplier", 'String'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier.products
   */
  export type Supplier$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Supplier.contracts
   */
  export type Supplier$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    where?: SupplierContractWhereInput
    orderBy?: SupplierContractOrderByWithRelationInput | SupplierContractOrderByWithRelationInput[]
    cursor?: SupplierContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierContractScalarFieldEnum | SupplierContractScalarFieldEnum[]
  }

  /**
   * Supplier.purchaseOrders
   */
  export type Supplier$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Supplier.performanceMetrics
   */
  export type Supplier$performanceMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPerformanceMetric
     */
    select?: SupplierPerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPerformanceMetric
     */
    omit?: SupplierPerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPerformanceMetricInclude<ExtArgs> | null
    where?: SupplierPerformanceMetricWhereInput
    orderBy?: SupplierPerformanceMetricOrderByWithRelationInput | SupplierPerformanceMetricOrderByWithRelationInput[]
    cursor?: SupplierPerformanceMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierPerformanceMetricScalarFieldEnum | SupplierPerformanceMetricScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model SupplierContract
   */

  export type AggregateSupplierContract = {
    _count: SupplierContractCountAggregateOutputType | null
    _avg: SupplierContractAvgAggregateOutputType | null
    _sum: SupplierContractSumAggregateOutputType | null
    _min: SupplierContractMinAggregateOutputType | null
    _max: SupplierContractMaxAggregateOutputType | null
  }

  export type SupplierContractAvgAggregateOutputType = {
    value: number | null
  }

  export type SupplierContractSumAggregateOutputType = {
    value: number | null
  }

  export type SupplierContractMinAggregateOutputType = {
    id: string | null
    supplierId: string | null
    contractNumber: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    renewalDate: Date | null
    value: number | null
    terms: string | null
    paymentTerms: string | null
    status: $Enums.ContractStatus | null
    documentUrl: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierContractMaxAggregateOutputType = {
    id: string | null
    supplierId: string | null
    contractNumber: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    renewalDate: Date | null
    value: number | null
    terms: string | null
    paymentTerms: string | null
    status: $Enums.ContractStatus | null
    documentUrl: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierContractCountAggregateOutputType = {
    id: number
    supplierId: number
    contractNumber: number
    title: number
    description: number
    startDate: number
    endDate: number
    renewalDate: number
    value: number
    terms: number
    paymentTerms: number
    status: number
    documentUrl: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierContractAvgAggregateInputType = {
    value?: true
  }

  export type SupplierContractSumAggregateInputType = {
    value?: true
  }

  export type SupplierContractMinAggregateInputType = {
    id?: true
    supplierId?: true
    contractNumber?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    renewalDate?: true
    value?: true
    terms?: true
    paymentTerms?: true
    status?: true
    documentUrl?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierContractMaxAggregateInputType = {
    id?: true
    supplierId?: true
    contractNumber?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    renewalDate?: true
    value?: true
    terms?: true
    paymentTerms?: true
    status?: true
    documentUrl?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierContractCountAggregateInputType = {
    id?: true
    supplierId?: true
    contractNumber?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    renewalDate?: true
    value?: true
    terms?: true
    paymentTerms?: true
    status?: true
    documentUrl?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierContract to aggregate.
     */
    where?: SupplierContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierContracts to fetch.
     */
    orderBy?: SupplierContractOrderByWithRelationInput | SupplierContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierContracts
    **/
    _count?: true | SupplierContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierContractMaxAggregateInputType
  }

  export type GetSupplierContractAggregateType<T extends SupplierContractAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierContract[P]>
      : GetScalarType<T[P], AggregateSupplierContract[P]>
  }




  export type SupplierContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierContractWhereInput
    orderBy?: SupplierContractOrderByWithAggregationInput | SupplierContractOrderByWithAggregationInput[]
    by: SupplierContractScalarFieldEnum[] | SupplierContractScalarFieldEnum
    having?: SupplierContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierContractCountAggregateInputType | true
    _avg?: SupplierContractAvgAggregateInputType
    _sum?: SupplierContractSumAggregateInputType
    _min?: SupplierContractMinAggregateInputType
    _max?: SupplierContractMaxAggregateInputType
  }

  export type SupplierContractGroupByOutputType = {
    id: string
    supplierId: string
    contractNumber: string
    title: string
    description: string | null
    startDate: Date
    endDate: Date | null
    renewalDate: Date | null
    value: number | null
    terms: string | null
    paymentTerms: string | null
    status: $Enums.ContractStatus
    documentUrl: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: SupplierContractCountAggregateOutputType | null
    _avg: SupplierContractAvgAggregateOutputType | null
    _sum: SupplierContractSumAggregateOutputType | null
    _min: SupplierContractMinAggregateOutputType | null
    _max: SupplierContractMaxAggregateOutputType | null
  }

  type GetSupplierContractGroupByPayload<T extends SupplierContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierContractGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierContractGroupByOutputType[P]>
        }
      >
    >


  export type SupplierContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    contractNumber?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    renewalDate?: boolean
    value?: boolean
    terms?: boolean
    paymentTerms?: boolean
    status?: boolean
    documentUrl?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierContract"]>

  export type SupplierContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    contractNumber?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    renewalDate?: boolean
    value?: boolean
    terms?: boolean
    paymentTerms?: boolean
    status?: boolean
    documentUrl?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierContract"]>

  export type SupplierContractSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    contractNumber?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    renewalDate?: boolean
    value?: boolean
    terms?: boolean
    paymentTerms?: boolean
    status?: boolean
    documentUrl?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierContract"]>

  export type SupplierContractSelectScalar = {
    id?: boolean
    supplierId?: boolean
    contractNumber?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    renewalDate?: boolean
    value?: boolean
    terms?: boolean
    paymentTerms?: boolean
    status?: boolean
    documentUrl?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierContractOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplierId" | "contractNumber" | "title" | "description" | "startDate" | "endDate" | "renewalDate" | "value" | "terms" | "paymentTerms" | "status" | "documentUrl" | "createdById" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["supplierContract"]>
  export type SupplierContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SupplierContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SupplierContractIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $SupplierContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierContract"
    objects: {
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supplierId: string
      contractNumber: string
      title: string
      description: string | null
      startDate: Date
      endDate: Date | null
      renewalDate: Date | null
      value: number | null
      terms: string | null
      paymentTerms: string | null
      status: $Enums.ContractStatus
      documentUrl: string | null
      createdById: string | null
      updatedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplierContract"]>
    composites: {}
  }

  type SupplierContractGetPayload<S extends boolean | null | undefined | SupplierContractDefaultArgs> = $Result.GetResult<Prisma.$SupplierContractPayload, S>

  type SupplierContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierContractFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierContractCountAggregateInputType | true
    }

  export interface SupplierContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierContract'], meta: { name: 'SupplierContract' } }
    /**
     * Find zero or one SupplierContract that matches the filter.
     * @param {SupplierContractFindUniqueArgs} args - Arguments to find a SupplierContract
     * @example
     * // Get one SupplierContract
     * const supplierContract = await prisma.supplierContract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierContractFindUniqueArgs>(args: SelectSubset<T, SupplierContractFindUniqueArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupplierContract that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierContractFindUniqueOrThrowArgs} args - Arguments to find a SupplierContract
     * @example
     * // Get one SupplierContract
     * const supplierContract = await prisma.supplierContract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierContractFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierContract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierContractFindFirstArgs} args - Arguments to find a SupplierContract
     * @example
     * // Get one SupplierContract
     * const supplierContract = await prisma.supplierContract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierContractFindFirstArgs>(args?: SelectSubset<T, SupplierContractFindFirstArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierContract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierContractFindFirstOrThrowArgs} args - Arguments to find a SupplierContract
     * @example
     * // Get one SupplierContract
     * const supplierContract = await prisma.supplierContract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierContractFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupplierContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierContracts
     * const supplierContracts = await prisma.supplierContract.findMany()
     * 
     * // Get first 10 SupplierContracts
     * const supplierContracts = await prisma.supplierContract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierContractWithIdOnly = await prisma.supplierContract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierContractFindManyArgs>(args?: SelectSubset<T, SupplierContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupplierContract.
     * @param {SupplierContractCreateArgs} args - Arguments to create a SupplierContract.
     * @example
     * // Create one SupplierContract
     * const SupplierContract = await prisma.supplierContract.create({
     *   data: {
     *     // ... data to create a SupplierContract
     *   }
     * })
     * 
     */
    create<T extends SupplierContractCreateArgs>(args: SelectSubset<T, SupplierContractCreateArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupplierContracts.
     * @param {SupplierContractCreateManyArgs} args - Arguments to create many SupplierContracts.
     * @example
     * // Create many SupplierContracts
     * const supplierContract = await prisma.supplierContract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierContractCreateManyArgs>(args?: SelectSubset<T, SupplierContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplierContracts and returns the data saved in the database.
     * @param {SupplierContractCreateManyAndReturnArgs} args - Arguments to create many SupplierContracts.
     * @example
     * // Create many SupplierContracts
     * const supplierContract = await prisma.supplierContract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplierContracts and only return the `id`
     * const supplierContractWithIdOnly = await prisma.supplierContract.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierContractCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupplierContract.
     * @param {SupplierContractDeleteArgs} args - Arguments to delete one SupplierContract.
     * @example
     * // Delete one SupplierContract
     * const SupplierContract = await prisma.supplierContract.delete({
     *   where: {
     *     // ... filter to delete one SupplierContract
     *   }
     * })
     * 
     */
    delete<T extends SupplierContractDeleteArgs>(args: SelectSubset<T, SupplierContractDeleteArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupplierContract.
     * @param {SupplierContractUpdateArgs} args - Arguments to update one SupplierContract.
     * @example
     * // Update one SupplierContract
     * const supplierContract = await prisma.supplierContract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierContractUpdateArgs>(args: SelectSubset<T, SupplierContractUpdateArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupplierContracts.
     * @param {SupplierContractDeleteManyArgs} args - Arguments to filter SupplierContracts to delete.
     * @example
     * // Delete a few SupplierContracts
     * const { count } = await prisma.supplierContract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierContractDeleteManyArgs>(args?: SelectSubset<T, SupplierContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierContracts
     * const supplierContract = await prisma.supplierContract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierContractUpdateManyArgs>(args: SelectSubset<T, SupplierContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierContracts and returns the data updated in the database.
     * @param {SupplierContractUpdateManyAndReturnArgs} args - Arguments to update many SupplierContracts.
     * @example
     * // Update many SupplierContracts
     * const supplierContract = await prisma.supplierContract.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupplierContracts and only return the `id`
     * const supplierContractWithIdOnly = await prisma.supplierContract.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierContractUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierContractUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupplierContract.
     * @param {SupplierContractUpsertArgs} args - Arguments to update or create a SupplierContract.
     * @example
     * // Update or create a SupplierContract
     * const supplierContract = await prisma.supplierContract.upsert({
     *   create: {
     *     // ... data to create a SupplierContract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierContract we want to update
     *   }
     * })
     */
    upsert<T extends SupplierContractUpsertArgs>(args: SelectSubset<T, SupplierContractUpsertArgs<ExtArgs>>): Prisma__SupplierContractClient<$Result.GetResult<Prisma.$SupplierContractPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupplierContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierContractCountArgs} args - Arguments to filter SupplierContracts to count.
     * @example
     * // Count the number of SupplierContracts
     * const count = await prisma.supplierContract.count({
     *   where: {
     *     // ... the filter for the SupplierContracts we want to count
     *   }
     * })
    **/
    count<T extends SupplierContractCountArgs>(
      args?: Subset<T, SupplierContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierContractAggregateArgs>(args: Subset<T, SupplierContractAggregateArgs>): Prisma.PrismaPromise<GetSupplierContractAggregateType<T>>

    /**
     * Group by SupplierContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierContractGroupByArgs['orderBy'] }
        : { orderBy?: SupplierContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierContract model
   */
  readonly fields: SupplierContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierContract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierContract model
   */
  interface SupplierContractFieldRefs {
    readonly id: FieldRef<"SupplierContract", 'String'>
    readonly supplierId: FieldRef<"SupplierContract", 'String'>
    readonly contractNumber: FieldRef<"SupplierContract", 'String'>
    readonly title: FieldRef<"SupplierContract", 'String'>
    readonly description: FieldRef<"SupplierContract", 'String'>
    readonly startDate: FieldRef<"SupplierContract", 'DateTime'>
    readonly endDate: FieldRef<"SupplierContract", 'DateTime'>
    readonly renewalDate: FieldRef<"SupplierContract", 'DateTime'>
    readonly value: FieldRef<"SupplierContract", 'Float'>
    readonly terms: FieldRef<"SupplierContract", 'String'>
    readonly paymentTerms: FieldRef<"SupplierContract", 'String'>
    readonly status: FieldRef<"SupplierContract", 'ContractStatus'>
    readonly documentUrl: FieldRef<"SupplierContract", 'String'>
    readonly createdById: FieldRef<"SupplierContract", 'String'>
    readonly updatedById: FieldRef<"SupplierContract", 'String'>
    readonly createdAt: FieldRef<"SupplierContract", 'DateTime'>
    readonly updatedAt: FieldRef<"SupplierContract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupplierContract findUnique
   */
  export type SupplierContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * Filter, which SupplierContract to fetch.
     */
    where: SupplierContractWhereUniqueInput
  }

  /**
   * SupplierContract findUniqueOrThrow
   */
  export type SupplierContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * Filter, which SupplierContract to fetch.
     */
    where: SupplierContractWhereUniqueInput
  }

  /**
   * SupplierContract findFirst
   */
  export type SupplierContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * Filter, which SupplierContract to fetch.
     */
    where?: SupplierContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierContracts to fetch.
     */
    orderBy?: SupplierContractOrderByWithRelationInput | SupplierContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierContracts.
     */
    cursor?: SupplierContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierContracts.
     */
    distinct?: SupplierContractScalarFieldEnum | SupplierContractScalarFieldEnum[]
  }

  /**
   * SupplierContract findFirstOrThrow
   */
  export type SupplierContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * Filter, which SupplierContract to fetch.
     */
    where?: SupplierContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierContracts to fetch.
     */
    orderBy?: SupplierContractOrderByWithRelationInput | SupplierContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierContracts.
     */
    cursor?: SupplierContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierContracts.
     */
    distinct?: SupplierContractScalarFieldEnum | SupplierContractScalarFieldEnum[]
  }

  /**
   * SupplierContract findMany
   */
  export type SupplierContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * Filter, which SupplierContracts to fetch.
     */
    where?: SupplierContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierContracts to fetch.
     */
    orderBy?: SupplierContractOrderByWithRelationInput | SupplierContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierContracts.
     */
    cursor?: SupplierContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierContracts.
     */
    skip?: number
    distinct?: SupplierContractScalarFieldEnum | SupplierContractScalarFieldEnum[]
  }

  /**
   * SupplierContract create
   */
  export type SupplierContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierContract.
     */
    data: XOR<SupplierContractCreateInput, SupplierContractUncheckedCreateInput>
  }

  /**
   * SupplierContract createMany
   */
  export type SupplierContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierContracts.
     */
    data: SupplierContractCreateManyInput | SupplierContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierContract createManyAndReturn
   */
  export type SupplierContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * The data used to create many SupplierContracts.
     */
    data: SupplierContractCreateManyInput | SupplierContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierContract update
   */
  export type SupplierContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierContract.
     */
    data: XOR<SupplierContractUpdateInput, SupplierContractUncheckedUpdateInput>
    /**
     * Choose, which SupplierContract to update.
     */
    where: SupplierContractWhereUniqueInput
  }

  /**
   * SupplierContract updateMany
   */
  export type SupplierContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierContracts.
     */
    data: XOR<SupplierContractUpdateManyMutationInput, SupplierContractUncheckedUpdateManyInput>
    /**
     * Filter which SupplierContracts to update
     */
    where?: SupplierContractWhereInput
    /**
     * Limit how many SupplierContracts to update.
     */
    limit?: number
  }

  /**
   * SupplierContract updateManyAndReturn
   */
  export type SupplierContractUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * The data used to update SupplierContracts.
     */
    data: XOR<SupplierContractUpdateManyMutationInput, SupplierContractUncheckedUpdateManyInput>
    /**
     * Filter which SupplierContracts to update
     */
    where?: SupplierContractWhereInput
    /**
     * Limit how many SupplierContracts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierContract upsert
   */
  export type SupplierContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierContract to update in case it exists.
     */
    where: SupplierContractWhereUniqueInput
    /**
     * In case the SupplierContract found by the `where` argument doesn't exist, create a new SupplierContract with this data.
     */
    create: XOR<SupplierContractCreateInput, SupplierContractUncheckedCreateInput>
    /**
     * In case the SupplierContract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierContractUpdateInput, SupplierContractUncheckedUpdateInput>
  }

  /**
   * SupplierContract delete
   */
  export type SupplierContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
    /**
     * Filter which SupplierContract to delete.
     */
    where: SupplierContractWhereUniqueInput
  }

  /**
   * SupplierContract deleteMany
   */
  export type SupplierContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierContracts to delete
     */
    where?: SupplierContractWhereInput
    /**
     * Limit how many SupplierContracts to delete.
     */
    limit?: number
  }

  /**
   * SupplierContract without action
   */
  export type SupplierContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierContract
     */
    select?: SupplierContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierContract
     */
    omit?: SupplierContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierContractInclude<ExtArgs> | null
  }


  /**
   * Model SupplierPerformanceMetric
   */

  export type AggregateSupplierPerformanceMetric = {
    _count: SupplierPerformanceMetricCountAggregateOutputType | null
    _avg: SupplierPerformanceMetricAvgAggregateOutputType | null
    _sum: SupplierPerformanceMetricSumAggregateOutputType | null
    _min: SupplierPerformanceMetricMinAggregateOutputType | null
    _max: SupplierPerformanceMetricMaxAggregateOutputType | null
  }

  export type SupplierPerformanceMetricAvgAggregateOutputType = {
    value: number | null
  }

  export type SupplierPerformanceMetricSumAggregateOutputType = {
    value: number | null
  }

  export type SupplierPerformanceMetricMinAggregateOutputType = {
    id: string | null
    supplierId: string | null
    metricType: $Enums.PerformanceMetricType | null
    date: Date | null
    value: number | null
    notes: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierPerformanceMetricMaxAggregateOutputType = {
    id: string | null
    supplierId: string | null
    metricType: $Enums.PerformanceMetricType | null
    date: Date | null
    value: number | null
    notes: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierPerformanceMetricCountAggregateOutputType = {
    id: number
    supplierId: number
    metricType: number
    date: number
    value: number
    notes: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierPerformanceMetricAvgAggregateInputType = {
    value?: true
  }

  export type SupplierPerformanceMetricSumAggregateInputType = {
    value?: true
  }

  export type SupplierPerformanceMetricMinAggregateInputType = {
    id?: true
    supplierId?: true
    metricType?: true
    date?: true
    value?: true
    notes?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierPerformanceMetricMaxAggregateInputType = {
    id?: true
    supplierId?: true
    metricType?: true
    date?: true
    value?: true
    notes?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierPerformanceMetricCountAggregateInputType = {
    id?: true
    supplierId?: true
    metricType?: true
    date?: true
    value?: true
    notes?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierPerformanceMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierPerformanceMetric to aggregate.
     */
    where?: SupplierPerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPerformanceMetrics to fetch.
     */
    orderBy?: SupplierPerformanceMetricOrderByWithRelationInput | SupplierPerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierPerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierPerformanceMetrics
    **/
    _count?: true | SupplierPerformanceMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierPerformanceMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierPerformanceMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierPerformanceMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierPerformanceMetricMaxAggregateInputType
  }

  export type GetSupplierPerformanceMetricAggregateType<T extends SupplierPerformanceMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierPerformanceMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierPerformanceMetric[P]>
      : GetScalarType<T[P], AggregateSupplierPerformanceMetric[P]>
  }




  export type SupplierPerformanceMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierPerformanceMetricWhereInput
    orderBy?: SupplierPerformanceMetricOrderByWithAggregationInput | SupplierPerformanceMetricOrderByWithAggregationInput[]
    by: SupplierPerformanceMetricScalarFieldEnum[] | SupplierPerformanceMetricScalarFieldEnum
    having?: SupplierPerformanceMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierPerformanceMetricCountAggregateInputType | true
    _avg?: SupplierPerformanceMetricAvgAggregateInputType
    _sum?: SupplierPerformanceMetricSumAggregateInputType
    _min?: SupplierPerformanceMetricMinAggregateInputType
    _max?: SupplierPerformanceMetricMaxAggregateInputType
  }

  export type SupplierPerformanceMetricGroupByOutputType = {
    id: string
    supplierId: string
    metricType: $Enums.PerformanceMetricType
    date: Date
    value: number
    notes: string | null
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: SupplierPerformanceMetricCountAggregateOutputType | null
    _avg: SupplierPerformanceMetricAvgAggregateOutputType | null
    _sum: SupplierPerformanceMetricSumAggregateOutputType | null
    _min: SupplierPerformanceMetricMinAggregateOutputType | null
    _max: SupplierPerformanceMetricMaxAggregateOutputType | null
  }

  type GetSupplierPerformanceMetricGroupByPayload<T extends SupplierPerformanceMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierPerformanceMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierPerformanceMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierPerformanceMetricGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierPerformanceMetricGroupByOutputType[P]>
        }
      >
    >


  export type SupplierPerformanceMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    metricType?: boolean
    date?: boolean
    value?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierPerformanceMetric"]>

  export type SupplierPerformanceMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    metricType?: boolean
    date?: boolean
    value?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierPerformanceMetric"]>

  export type SupplierPerformanceMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    metricType?: boolean
    date?: boolean
    value?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierPerformanceMetric"]>

  export type SupplierPerformanceMetricSelectScalar = {
    id?: boolean
    supplierId?: boolean
    metricType?: boolean
    date?: boolean
    value?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierPerformanceMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplierId" | "metricType" | "date" | "value" | "notes" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["supplierPerformanceMetric"]>
  export type SupplierPerformanceMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SupplierPerformanceMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type SupplierPerformanceMetricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $SupplierPerformanceMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierPerformanceMetric"
    objects: {
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supplierId: string
      metricType: $Enums.PerformanceMetricType
      date: Date
      value: number
      notes: string | null
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplierPerformanceMetric"]>
    composites: {}
  }

  type SupplierPerformanceMetricGetPayload<S extends boolean | null | undefined | SupplierPerformanceMetricDefaultArgs> = $Result.GetResult<Prisma.$SupplierPerformanceMetricPayload, S>

  type SupplierPerformanceMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierPerformanceMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierPerformanceMetricCountAggregateInputType | true
    }

  export interface SupplierPerformanceMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierPerformanceMetric'], meta: { name: 'SupplierPerformanceMetric' } }
    /**
     * Find zero or one SupplierPerformanceMetric that matches the filter.
     * @param {SupplierPerformanceMetricFindUniqueArgs} args - Arguments to find a SupplierPerformanceMetric
     * @example
     * // Get one SupplierPerformanceMetric
     * const supplierPerformanceMetric = await prisma.supplierPerformanceMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierPerformanceMetricFindUniqueArgs>(args: SelectSubset<T, SupplierPerformanceMetricFindUniqueArgs<ExtArgs>>): Prisma__SupplierPerformanceMetricClient<$Result.GetResult<Prisma.$SupplierPerformanceMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupplierPerformanceMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierPerformanceMetricFindUniqueOrThrowArgs} args - Arguments to find a SupplierPerformanceMetric
     * @example
     * // Get one SupplierPerformanceMetric
     * const supplierPerformanceMetric = await prisma.supplierPerformanceMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierPerformanceMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierPerformanceMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierPerformanceMetricClient<$Result.GetResult<Prisma.$SupplierPerformanceMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierPerformanceMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPerformanceMetricFindFirstArgs} args - Arguments to find a SupplierPerformanceMetric
     * @example
     * // Get one SupplierPerformanceMetric
     * const supplierPerformanceMetric = await prisma.supplierPerformanceMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierPerformanceMetricFindFirstArgs>(args?: SelectSubset<T, SupplierPerformanceMetricFindFirstArgs<ExtArgs>>): Prisma__SupplierPerformanceMetricClient<$Result.GetResult<Prisma.$SupplierPerformanceMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierPerformanceMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPerformanceMetricFindFirstOrThrowArgs} args - Arguments to find a SupplierPerformanceMetric
     * @example
     * // Get one SupplierPerformanceMetric
     * const supplierPerformanceMetric = await prisma.supplierPerformanceMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierPerformanceMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierPerformanceMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierPerformanceMetricClient<$Result.GetResult<Prisma.$SupplierPerformanceMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupplierPerformanceMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPerformanceMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierPerformanceMetrics
     * const supplierPerformanceMetrics = await prisma.supplierPerformanceMetric.findMany()
     * 
     * // Get first 10 SupplierPerformanceMetrics
     * const supplierPerformanceMetrics = await prisma.supplierPerformanceMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierPerformanceMetricWithIdOnly = await prisma.supplierPerformanceMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierPerformanceMetricFindManyArgs>(args?: SelectSubset<T, SupplierPerformanceMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPerformanceMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupplierPerformanceMetric.
     * @param {SupplierPerformanceMetricCreateArgs} args - Arguments to create a SupplierPerformanceMetric.
     * @example
     * // Create one SupplierPerformanceMetric
     * const SupplierPerformanceMetric = await prisma.supplierPerformanceMetric.create({
     *   data: {
     *     // ... data to create a SupplierPerformanceMetric
     *   }
     * })
     * 
     */
    create<T extends SupplierPerformanceMetricCreateArgs>(args: SelectSubset<T, SupplierPerformanceMetricCreateArgs<ExtArgs>>): Prisma__SupplierPerformanceMetricClient<$Result.GetResult<Prisma.$SupplierPerformanceMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupplierPerformanceMetrics.
     * @param {SupplierPerformanceMetricCreateManyArgs} args - Arguments to create many SupplierPerformanceMetrics.
     * @example
     * // Create many SupplierPerformanceMetrics
     * const supplierPerformanceMetric = await prisma.supplierPerformanceMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierPerformanceMetricCreateManyArgs>(args?: SelectSubset<T, SupplierPerformanceMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplierPerformanceMetrics and returns the data saved in the database.
     * @param {SupplierPerformanceMetricCreateManyAndReturnArgs} args - Arguments to create many SupplierPerformanceMetrics.
     * @example
     * // Create many SupplierPerformanceMetrics
     * const supplierPerformanceMetric = await prisma.supplierPerformanceMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplierPerformanceMetrics and only return the `id`
     * const supplierPerformanceMetricWithIdOnly = await prisma.supplierPerformanceMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierPerformanceMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierPerformanceMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPerformanceMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupplierPerformanceMetric.
     * @param {SupplierPerformanceMetricDeleteArgs} args - Arguments to delete one SupplierPerformanceMetric.
     * @example
     * // Delete one SupplierPerformanceMetric
     * const SupplierPerformanceMetric = await prisma.supplierPerformanceMetric.delete({
     *   where: {
     *     // ... filter to delete one SupplierPerformanceMetric
     *   }
     * })
     * 
     */
    delete<T extends SupplierPerformanceMetricDeleteArgs>(args: SelectSubset<T, SupplierPerformanceMetricDeleteArgs<ExtArgs>>): Prisma__SupplierPerformanceMetricClient<$Result.GetResult<Prisma.$SupplierPerformanceMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupplierPerformanceMetric.
     * @param {SupplierPerformanceMetricUpdateArgs} args - Arguments to update one SupplierPerformanceMetric.
     * @example
     * // Update one SupplierPerformanceMetric
     * const supplierPerformanceMetric = await prisma.supplierPerformanceMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierPerformanceMetricUpdateArgs>(args: SelectSubset<T, SupplierPerformanceMetricUpdateArgs<ExtArgs>>): Prisma__SupplierPerformanceMetricClient<$Result.GetResult<Prisma.$SupplierPerformanceMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupplierPerformanceMetrics.
     * @param {SupplierPerformanceMetricDeleteManyArgs} args - Arguments to filter SupplierPerformanceMetrics to delete.
     * @example
     * // Delete a few SupplierPerformanceMetrics
     * const { count } = await prisma.supplierPerformanceMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierPerformanceMetricDeleteManyArgs>(args?: SelectSubset<T, SupplierPerformanceMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierPerformanceMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPerformanceMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierPerformanceMetrics
     * const supplierPerformanceMetric = await prisma.supplierPerformanceMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierPerformanceMetricUpdateManyArgs>(args: SelectSubset<T, SupplierPerformanceMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierPerformanceMetrics and returns the data updated in the database.
     * @param {SupplierPerformanceMetricUpdateManyAndReturnArgs} args - Arguments to update many SupplierPerformanceMetrics.
     * @example
     * // Update many SupplierPerformanceMetrics
     * const supplierPerformanceMetric = await prisma.supplierPerformanceMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupplierPerformanceMetrics and only return the `id`
     * const supplierPerformanceMetricWithIdOnly = await prisma.supplierPerformanceMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierPerformanceMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierPerformanceMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPerformanceMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupplierPerformanceMetric.
     * @param {SupplierPerformanceMetricUpsertArgs} args - Arguments to update or create a SupplierPerformanceMetric.
     * @example
     * // Update or create a SupplierPerformanceMetric
     * const supplierPerformanceMetric = await prisma.supplierPerformanceMetric.upsert({
     *   create: {
     *     // ... data to create a SupplierPerformanceMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierPerformanceMetric we want to update
     *   }
     * })
     */
    upsert<T extends SupplierPerformanceMetricUpsertArgs>(args: SelectSubset<T, SupplierPerformanceMetricUpsertArgs<ExtArgs>>): Prisma__SupplierPerformanceMetricClient<$Result.GetResult<Prisma.$SupplierPerformanceMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupplierPerformanceMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPerformanceMetricCountArgs} args - Arguments to filter SupplierPerformanceMetrics to count.
     * @example
     * // Count the number of SupplierPerformanceMetrics
     * const count = await prisma.supplierPerformanceMetric.count({
     *   where: {
     *     // ... the filter for the SupplierPerformanceMetrics we want to count
     *   }
     * })
    **/
    count<T extends SupplierPerformanceMetricCountArgs>(
      args?: Subset<T, SupplierPerformanceMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierPerformanceMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierPerformanceMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPerformanceMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierPerformanceMetricAggregateArgs>(args: Subset<T, SupplierPerformanceMetricAggregateArgs>): Prisma.PrismaPromise<GetSupplierPerformanceMetricAggregateType<T>>

    /**
     * Group by SupplierPerformanceMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPerformanceMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierPerformanceMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierPerformanceMetricGroupByArgs['orderBy'] }
        : { orderBy?: SupplierPerformanceMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierPerformanceMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierPerformanceMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierPerformanceMetric model
   */
  readonly fields: SupplierPerformanceMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierPerformanceMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierPerformanceMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierPerformanceMetric model
   */
  interface SupplierPerformanceMetricFieldRefs {
    readonly id: FieldRef<"SupplierPerformanceMetric", 'String'>
    readonly supplierId: FieldRef<"SupplierPerformanceMetric", 'String'>
    readonly metricType: FieldRef<"SupplierPerformanceMetric", 'PerformanceMetricType'>
    readonly date: FieldRef<"SupplierPerformanceMetric", 'DateTime'>
    readonly value: FieldRef<"SupplierPerformanceMetric", 'Float'>
    readonly notes: FieldRef<"SupplierPerformanceMetric", 'String'>
    readonly createdById: FieldRef<"SupplierPerformanceMetric", 'String'>
    readonly createdAt: FieldRef<"SupplierPerformanceMetric", 'DateTime'>
    readonly updatedAt: FieldRef<"SupplierPerformanceMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupplierPerformanceMetric findUnique
   */
  export type SupplierPerformanceMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPerformanceMetric
     */
    select?: SupplierPerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPerformanceMetric
     */
    omit?: SupplierPerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPerformanceMetric to fetch.
     */
    where: SupplierPerformanceMetricWhereUniqueInput
  }

  /**
   * SupplierPerformanceMetric findUniqueOrThrow
   */
  export type SupplierPerformanceMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPerformanceMetric
     */
    select?: SupplierPerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPerformanceMetric
     */
    omit?: SupplierPerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPerformanceMetric to fetch.
     */
    where: SupplierPerformanceMetricWhereUniqueInput
  }

  /**
   * SupplierPerformanceMetric findFirst
   */
  export type SupplierPerformanceMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPerformanceMetric
     */
    select?: SupplierPerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPerformanceMetric
     */
    omit?: SupplierPerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPerformanceMetric to fetch.
     */
    where?: SupplierPerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPerformanceMetrics to fetch.
     */
    orderBy?: SupplierPerformanceMetricOrderByWithRelationInput | SupplierPerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierPerformanceMetrics.
     */
    cursor?: SupplierPerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierPerformanceMetrics.
     */
    distinct?: SupplierPerformanceMetricScalarFieldEnum | SupplierPerformanceMetricScalarFieldEnum[]
  }

  /**
   * SupplierPerformanceMetric findFirstOrThrow
   */
  export type SupplierPerformanceMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPerformanceMetric
     */
    select?: SupplierPerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPerformanceMetric
     */
    omit?: SupplierPerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPerformanceMetric to fetch.
     */
    where?: SupplierPerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPerformanceMetrics to fetch.
     */
    orderBy?: SupplierPerformanceMetricOrderByWithRelationInput | SupplierPerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierPerformanceMetrics.
     */
    cursor?: SupplierPerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierPerformanceMetrics.
     */
    distinct?: SupplierPerformanceMetricScalarFieldEnum | SupplierPerformanceMetricScalarFieldEnum[]
  }

  /**
   * SupplierPerformanceMetric findMany
   */
  export type SupplierPerformanceMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPerformanceMetric
     */
    select?: SupplierPerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPerformanceMetric
     */
    omit?: SupplierPerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPerformanceMetrics to fetch.
     */
    where?: SupplierPerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPerformanceMetrics to fetch.
     */
    orderBy?: SupplierPerformanceMetricOrderByWithRelationInput | SupplierPerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierPerformanceMetrics.
     */
    cursor?: SupplierPerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPerformanceMetrics.
     */
    skip?: number
    distinct?: SupplierPerformanceMetricScalarFieldEnum | SupplierPerformanceMetricScalarFieldEnum[]
  }

  /**
   * SupplierPerformanceMetric create
   */
  export type SupplierPerformanceMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPerformanceMetric
     */
    select?: SupplierPerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPerformanceMetric
     */
    omit?: SupplierPerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPerformanceMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierPerformanceMetric.
     */
    data: XOR<SupplierPerformanceMetricCreateInput, SupplierPerformanceMetricUncheckedCreateInput>
  }

  /**
   * SupplierPerformanceMetric createMany
   */
  export type SupplierPerformanceMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierPerformanceMetrics.
     */
    data: SupplierPerformanceMetricCreateManyInput | SupplierPerformanceMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierPerformanceMetric createManyAndReturn
   */
  export type SupplierPerformanceMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPerformanceMetric
     */
    select?: SupplierPerformanceMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPerformanceMetric
     */
    omit?: SupplierPerformanceMetricOmit<ExtArgs> | null
    /**
     * The data used to create many SupplierPerformanceMetrics.
     */
    data: SupplierPerformanceMetricCreateManyInput | SupplierPerformanceMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPerformanceMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierPerformanceMetric update
   */
  export type SupplierPerformanceMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPerformanceMetric
     */
    select?: SupplierPerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPerformanceMetric
     */
    omit?: SupplierPerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPerformanceMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierPerformanceMetric.
     */
    data: XOR<SupplierPerformanceMetricUpdateInput, SupplierPerformanceMetricUncheckedUpdateInput>
    /**
     * Choose, which SupplierPerformanceMetric to update.
     */
    where: SupplierPerformanceMetricWhereUniqueInput
  }

  /**
   * SupplierPerformanceMetric updateMany
   */
  export type SupplierPerformanceMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierPerformanceMetrics.
     */
    data: XOR<SupplierPerformanceMetricUpdateManyMutationInput, SupplierPerformanceMetricUncheckedUpdateManyInput>
    /**
     * Filter which SupplierPerformanceMetrics to update
     */
    where?: SupplierPerformanceMetricWhereInput
    /**
     * Limit how many SupplierPerformanceMetrics to update.
     */
    limit?: number
  }

  /**
   * SupplierPerformanceMetric updateManyAndReturn
   */
  export type SupplierPerformanceMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPerformanceMetric
     */
    select?: SupplierPerformanceMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPerformanceMetric
     */
    omit?: SupplierPerformanceMetricOmit<ExtArgs> | null
    /**
     * The data used to update SupplierPerformanceMetrics.
     */
    data: XOR<SupplierPerformanceMetricUpdateManyMutationInput, SupplierPerformanceMetricUncheckedUpdateManyInput>
    /**
     * Filter which SupplierPerformanceMetrics to update
     */
    where?: SupplierPerformanceMetricWhereInput
    /**
     * Limit how many SupplierPerformanceMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPerformanceMetricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierPerformanceMetric upsert
   */
  export type SupplierPerformanceMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPerformanceMetric
     */
    select?: SupplierPerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPerformanceMetric
     */
    omit?: SupplierPerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPerformanceMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierPerformanceMetric to update in case it exists.
     */
    where: SupplierPerformanceMetricWhereUniqueInput
    /**
     * In case the SupplierPerformanceMetric found by the `where` argument doesn't exist, create a new SupplierPerformanceMetric with this data.
     */
    create: XOR<SupplierPerformanceMetricCreateInput, SupplierPerformanceMetricUncheckedCreateInput>
    /**
     * In case the SupplierPerformanceMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierPerformanceMetricUpdateInput, SupplierPerformanceMetricUncheckedUpdateInput>
  }

  /**
   * SupplierPerformanceMetric delete
   */
  export type SupplierPerformanceMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPerformanceMetric
     */
    select?: SupplierPerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPerformanceMetric
     */
    omit?: SupplierPerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter which SupplierPerformanceMetric to delete.
     */
    where: SupplierPerformanceMetricWhereUniqueInput
  }

  /**
   * SupplierPerformanceMetric deleteMany
   */
  export type SupplierPerformanceMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierPerformanceMetrics to delete
     */
    where?: SupplierPerformanceMetricWhereInput
    /**
     * Limit how many SupplierPerformanceMetrics to delete.
     */
    limit?: number
  }

  /**
   * SupplierPerformanceMetric without action
   */
  export type SupplierPerformanceMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPerformanceMetric
     */
    select?: SupplierPerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPerformanceMetric
     */
    omit?: SupplierPerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPerformanceMetricInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    subtotal: number | null
    taxAmount: number | null
    totalAmount: number | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    subtotal: number | null
    taxAmount: number | null
    totalAmount: number | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    supplierId: string | null
    warehouseId: string | null
    orderDate: Date | null
    expectedDeliveryDate: Date | null
    status: $Enums.PurchaseOrderStatus | null
    subtotal: number | null
    taxAmount: number | null
    totalAmount: number | null
    notes: string | null
    createdById: string | null
    approvedById: string | null
    receivedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    supplierId: string | null
    warehouseId: string | null
    orderDate: Date | null
    expectedDeliveryDate: Date | null
    status: $Enums.PurchaseOrderStatus | null
    subtotal: number | null
    taxAmount: number | null
    totalAmount: number | null
    notes: string | null
    createdById: string | null
    approvedById: string | null
    receivedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    supplierId: number
    warehouseId: number
    orderDate: number
    expectedDeliveryDate: number
    status: number
    subtotal: number
    taxAmount: number
    totalAmount: number
    notes: number
    createdById: number
    approvedById: number
    receivedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    supplierId?: true
    warehouseId?: true
    orderDate?: true
    expectedDeliveryDate?: true
    status?: true
    subtotal?: true
    taxAmount?: true
    totalAmount?: true
    notes?: true
    createdById?: true
    approvedById?: true
    receivedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    supplierId?: true
    warehouseId?: true
    orderDate?: true
    expectedDeliveryDate?: true
    status?: true
    subtotal?: true
    taxAmount?: true
    totalAmount?: true
    notes?: true
    createdById?: true
    approvedById?: true
    receivedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    supplierId?: true
    warehouseId?: true
    orderDate?: true
    expectedDeliveryDate?: true
    status?: true
    subtotal?: true
    taxAmount?: true
    totalAmount?: true
    notes?: true
    createdById?: true
    approvedById?: true
    receivedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    orderNumber: string
    supplierId: string
    warehouseId: string
    orderDate: Date
    expectedDeliveryDate: Date | null
    status: $Enums.PurchaseOrderStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    notes: string | null
    createdById: string | null
    approvedById: string | null
    receivedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    supplierId?: boolean
    warehouseId?: boolean
    orderDate?: boolean
    expectedDeliveryDate?: boolean
    status?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdById?: boolean
    approvedById?: boolean
    receivedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    qualityControls?: boolean | PurchaseOrder$qualityControlsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    supplierId?: boolean
    warehouseId?: boolean
    orderDate?: boolean
    expectedDeliveryDate?: boolean
    status?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdById?: boolean
    approvedById?: boolean
    receivedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    supplierId?: boolean
    warehouseId?: boolean
    orderDate?: boolean
    expectedDeliveryDate?: boolean
    status?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdById?: boolean
    approvedById?: boolean
    receivedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    supplierId?: boolean
    warehouseId?: boolean
    orderDate?: boolean
    expectedDeliveryDate?: boolean
    status?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdById?: boolean
    approvedById?: boolean
    receivedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "supplierId" | "warehouseId" | "orderDate" | "expectedDeliveryDate" | "status" | "subtotal" | "taxAmount" | "totalAmount" | "notes" | "createdById" | "approvedById" | "receivedById" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrder"]>
  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    qualityControls?: boolean | PurchaseOrder$qualityControlsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      supplier: Prisma.$SupplierPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      items: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
      qualityControls: Prisma.$QualityControlPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      supplierId: string
      warehouseId: string
      orderDate: Date
      expectedDeliveryDate: Date | null
      status: $Enums.PurchaseOrderStatus
      subtotal: number
      taxAmount: number
      totalAmount: number
      notes: string | null
      createdById: string | null
      approvedById: string | null
      receivedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders and returns the data updated in the database.
     * @param {PurchaseOrderUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrders.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends PurchaseOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qualityControls<T extends PurchaseOrder$qualityControlsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$qualityControlsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly orderNumber: FieldRef<"PurchaseOrder", 'String'>
    readonly supplierId: FieldRef<"PurchaseOrder", 'String'>
    readonly warehouseId: FieldRef<"PurchaseOrder", 'String'>
    readonly orderDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly expectedDeliveryDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly status: FieldRef<"PurchaseOrder", 'PurchaseOrderStatus'>
    readonly subtotal: FieldRef<"PurchaseOrder", 'Float'>
    readonly taxAmount: FieldRef<"PurchaseOrder", 'Float'>
    readonly totalAmount: FieldRef<"PurchaseOrder", 'Float'>
    readonly notes: FieldRef<"PurchaseOrder", 'String'>
    readonly createdById: FieldRef<"PurchaseOrder", 'String'>
    readonly approvedById: FieldRef<"PurchaseOrder", 'String'>
    readonly receivedById: FieldRef<"PurchaseOrder", 'String'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrder updateManyAndReturn
   */
  export type PurchaseOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrder.items
   */
  export type PurchaseOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrder.qualityControls
   */
  export type PurchaseOrder$qualityControlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlInclude<ExtArgs> | null
    where?: QualityControlWhereInput
    orderBy?: QualityControlOrderByWithRelationInput | QualityControlOrderByWithRelationInput[]
    cursor?: QualityControlWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QualityControlScalarFieldEnum | QualityControlScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrderItem
   */

  export type AggregatePurchaseOrderItem = {
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  export type PurchaseOrderItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    receivedQuantity: number | null
  }

  export type PurchaseOrderItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    receivedQuantity: number | null
  }

  export type PurchaseOrderItemMinAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    receivedQuantity: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderItemMaxAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    productId: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    receivedQuantity: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderItemCountAggregateOutputType = {
    id: number
    purchaseOrderId: number
    productId: number
    quantity: number
    unitPrice: number
    totalPrice: number
    receivedQuantity: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    receivedQuantity?: true
  }

  export type PurchaseOrderItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    receivedQuantity?: true
  }

  export type PurchaseOrderItemMinAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    receivedQuantity?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderItemMaxAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    receivedQuantity?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderItemCountAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    receivedQuantity?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItem to aggregate.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrderItems
    **/
    _count?: true | PurchaseOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type GetPurchaseOrderItemAggregateType<T extends PurchaseOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
      : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
  }




  export type PurchaseOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithAggregationInput | PurchaseOrderItemOrderByWithAggregationInput[]
    by: PurchaseOrderItemScalarFieldEnum[] | PurchaseOrderItemScalarFieldEnum
    having?: PurchaseOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderItemCountAggregateInputType | true
    _avg?: PurchaseOrderItemAvgAggregateInputType
    _sum?: PurchaseOrderItemSumAggregateInputType
    _min?: PurchaseOrderItemMinAggregateInputType
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type PurchaseOrderItemGroupByOutputType = {
    id: string
    purchaseOrderId: string
    productId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    receivedQuantity: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  type GetPurchaseOrderItemGroupByPayload<T extends PurchaseOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    receivedQuantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    receivedQuantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    receivedQuantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectScalar = {
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    receivedQuantity?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseOrderId" | "productId" | "quantity" | "unitPrice" | "totalPrice" | "receivedQuantity" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrderItem"]>
  export type PurchaseOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrderItem"
    objects: {
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchaseOrderId: string
      productId: string
      quantity: number
      unitPrice: number
      totalPrice: number
      receivedQuantity: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrderItem"]>
    composites: {}
  }

  type PurchaseOrderItemGetPayload<S extends boolean | null | undefined | PurchaseOrderItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderItemPayload, S>

  type PurchaseOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderItemCountAggregateInputType | true
    }

  export interface PurchaseOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrderItem'], meta: { name: 'PurchaseOrderItem' } }
    /**
     * Find zero or one PurchaseOrderItem that matches the filter.
     * @param {PurchaseOrderItemFindUniqueArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderItemFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderItemFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
     * 
     * // Get first 10 PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderItemFindManyArgs>(args?: SelectSubset<T, PurchaseOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrderItem.
     * @param {PurchaseOrderItemCreateArgs} args - Arguments to create a PurchaseOrderItem.
     * @example
     * // Create one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.create({
     *   data: {
     *     // ... data to create a PurchaseOrderItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderItemCreateArgs>(args: SelectSubset<T, PurchaseOrderItemCreateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrderItems.
     * @param {PurchaseOrderItemCreateManyArgs} args - Arguments to create many PurchaseOrderItems.
     * @example
     * // Create many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderItemCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrderItems and returns the data saved in the database.
     * @param {PurchaseOrderItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrderItems.
     * @example
     * // Create many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrderItems and only return the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrderItem.
     * @param {PurchaseOrderItemDeleteArgs} args - Arguments to delete one PurchaseOrderItem.
     * @example
     * // Delete one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrderItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderItemDeleteArgs>(args: SelectSubset<T, PurchaseOrderItemDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpdateArgs} args - Arguments to update one PurchaseOrderItem.
     * @example
     * // Update one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderItemUpdateArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrderItems.
     * @param {PurchaseOrderItemDeleteManyArgs} args - Arguments to filter PurchaseOrderItems to delete.
     * @example
     * // Delete a few PurchaseOrderItems
     * const { count } = await prisma.purchaseOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderItemUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderItems and returns the data updated in the database.
     * @param {PurchaseOrderItemUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrderItems.
     * @example
     * // Update many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrderItems and only return the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpsertArgs} args - Arguments to update or create a PurchaseOrderItem.
     * @example
     * // Update or create a PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderItemUpsertArgs>(args: SelectSubset<T, PurchaseOrderItemUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemCountArgs} args - Arguments to filter PurchaseOrderItems to count.
     * @example
     * // Count the number of PurchaseOrderItems
     * const count = await prisma.purchaseOrderItem.count({
     *   where: {
     *     // ... the filter for the PurchaseOrderItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderItemCountArgs>(
      args?: Subset<T, PurchaseOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderItemAggregateArgs>(args: Subset<T, PurchaseOrderItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderItemAggregateType<T>>

    /**
     * Group by PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrderItem model
   */
  readonly fields: PurchaseOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrder<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrderItem model
   */
  interface PurchaseOrderItemFieldRefs {
    readonly id: FieldRef<"PurchaseOrderItem", 'String'>
    readonly purchaseOrderId: FieldRef<"PurchaseOrderItem", 'String'>
    readonly productId: FieldRef<"PurchaseOrderItem", 'String'>
    readonly quantity: FieldRef<"PurchaseOrderItem", 'Int'>
    readonly unitPrice: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly totalPrice: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly receivedQuantity: FieldRef<"PurchaseOrderItem", 'Int'>
    readonly notes: FieldRef<"PurchaseOrderItem", 'String'>
    readonly createdAt: FieldRef<"PurchaseOrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrderItem findUnique
   */
  export type PurchaseOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findUniqueOrThrow
   */
  export type PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findFirst
   */
  export type PurchaseOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findFirstOrThrow
   */
  export type PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findMany
   */
  export type PurchaseOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItems to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem create
   */
  export type PurchaseOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
  }

  /**
   * PurchaseOrderItem createMany
   */
  export type PurchaseOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrderItems.
     */
    data: PurchaseOrderItemCreateManyInput | PurchaseOrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrderItem createManyAndReturn
   */
  export type PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrderItems.
     */
    data: PurchaseOrderItemCreateManyInput | PurchaseOrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderItem update
   */
  export type PurchaseOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrderItem to update.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem updateMany
   */
  export type PurchaseOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrderItems.
     */
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderItems to update
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * Limit how many PurchaseOrderItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrderItem updateManyAndReturn
   */
  export type PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrderItems.
     */
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderItems to update
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * Limit how many PurchaseOrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderItem upsert
   */
  export type PurchaseOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrderItem to update in case it exists.
     */
    where: PurchaseOrderItemWhereUniqueInput
    /**
     * In case the PurchaseOrderItem found by the `where` argument doesn't exist, create a new PurchaseOrderItem with this data.
     */
    create: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
    /**
     * In case the PurchaseOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
  }

  /**
   * PurchaseOrderItem delete
   */
  export type PurchaseOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrderItem to delete.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem deleteMany
   */
  export type PurchaseOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItems to delete
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * Limit how many PurchaseOrderItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrderItem without action
   */
  export type PurchaseOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    costPrice: number | null
    wholesalePrice: number | null
    retailPrice: number | null
    minStockLevel: number | null
    reorderPoint: number | null
    leadTime: number | null
  }

  export type ProductSumAggregateOutputType = {
    costPrice: number | null
    wholesalePrice: number | null
    retailPrice: number | null
    minStockLevel: number | null
    reorderPoint: number | null
    leadTime: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    sku: string | null
    barcode: string | null
    name: string | null
    description: string | null
    unit: string | null
    categoryId: string | null
    supplierId: string | null
    costPrice: number | null
    wholesalePrice: number | null
    retailPrice: number | null
    minStockLevel: number | null
    reorderPoint: number | null
    leadTime: number | null
    condition: $Enums.ProductCondition | null
    createdById: string | null
    updatedById: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    barcode: string | null
    name: string | null
    description: string | null
    unit: string | null
    categoryId: string | null
    supplierId: string | null
    costPrice: number | null
    wholesalePrice: number | null
    retailPrice: number | null
    minStockLevel: number | null
    reorderPoint: number | null
    leadTime: number | null
    condition: $Enums.ProductCondition | null
    createdById: string | null
    updatedById: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sku: number
    barcode: number
    name: number
    description: number
    unit: number
    categoryId: number
    supplierId: number
    costPrice: number
    wholesalePrice: number
    retailPrice: number
    minStockLevel: number
    reorderPoint: number
    leadTime: number
    condition: number
    createdById: number
    updatedById: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    costPrice?: true
    wholesalePrice?: true
    retailPrice?: true
    minStockLevel?: true
    reorderPoint?: true
    leadTime?: true
  }

  export type ProductSumAggregateInputType = {
    costPrice?: true
    wholesalePrice?: true
    retailPrice?: true
    minStockLevel?: true
    reorderPoint?: true
    leadTime?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    sku?: true
    barcode?: true
    name?: true
    description?: true
    unit?: true
    categoryId?: true
    supplierId?: true
    costPrice?: true
    wholesalePrice?: true
    retailPrice?: true
    minStockLevel?: true
    reorderPoint?: true
    leadTime?: true
    condition?: true
    createdById?: true
    updatedById?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sku?: true
    barcode?: true
    name?: true
    description?: true
    unit?: true
    categoryId?: true
    supplierId?: true
    costPrice?: true
    wholesalePrice?: true
    retailPrice?: true
    minStockLevel?: true
    reorderPoint?: true
    leadTime?: true
    condition?: true
    createdById?: true
    updatedById?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sku?: true
    barcode?: true
    name?: true
    description?: true
    unit?: true
    categoryId?: true
    supplierId?: true
    costPrice?: true
    wholesalePrice?: true
    retailPrice?: true
    minStockLevel?: true
    reorderPoint?: true
    leadTime?: true
    condition?: true
    createdById?: true
    updatedById?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    sku: string
    barcode: string | null
    name: string
    description: string | null
    unit: string
    categoryId: string | null
    supplierId: string | null
    costPrice: number
    wholesalePrice: number
    retailPrice: number
    minStockLevel: number
    reorderPoint: number
    leadTime: number | null
    condition: $Enums.ProductCondition
    createdById: string | null
    updatedById: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    barcode?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    categoryId?: boolean
    supplierId?: boolean
    costPrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    minStockLevel?: boolean
    reorderPoint?: boolean
    leadTime?: boolean
    condition?: boolean
    createdById?: boolean
    updatedById?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Product$categoryArgs<ExtArgs>
    supplier?: boolean | Product$supplierArgs<ExtArgs>
    purchaseOrderItems?: boolean | Product$purchaseOrderItemsArgs<ExtArgs>
    qualityControlItems?: boolean | Product$qualityControlItemsArgs<ExtArgs>
    returnItems?: boolean | Product$returnItemsArgs<ExtArgs>
    inventoryItems?: boolean | Product$inventoryItemsArgs<ExtArgs>
    saleItems?: boolean | Product$saleItemsArgs<ExtArgs>
    transferItems?: boolean | Product$transferItemsArgs<ExtArgs>
    auditItems?: boolean | Product$auditItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    barcode?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    categoryId?: boolean
    supplierId?: boolean
    costPrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    minStockLevel?: boolean
    reorderPoint?: boolean
    leadTime?: boolean
    condition?: boolean
    createdById?: boolean
    updatedById?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Product$categoryArgs<ExtArgs>
    supplier?: boolean | Product$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    barcode?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    categoryId?: boolean
    supplierId?: boolean
    costPrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    minStockLevel?: boolean
    reorderPoint?: boolean
    leadTime?: boolean
    condition?: boolean
    createdById?: boolean
    updatedById?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Product$categoryArgs<ExtArgs>
    supplier?: boolean | Product$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    sku?: boolean
    barcode?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    categoryId?: boolean
    supplierId?: boolean
    costPrice?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    minStockLevel?: boolean
    reorderPoint?: boolean
    leadTime?: boolean
    condition?: boolean
    createdById?: boolean
    updatedById?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "barcode" | "name" | "description" | "unit" | "categoryId" | "supplierId" | "costPrice" | "wholesalePrice" | "retailPrice" | "minStockLevel" | "reorderPoint" | "leadTime" | "condition" | "createdById" | "updatedById" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Product$categoryArgs<ExtArgs>
    supplier?: boolean | Product$supplierArgs<ExtArgs>
    purchaseOrderItems?: boolean | Product$purchaseOrderItemsArgs<ExtArgs>
    qualityControlItems?: boolean | Product$qualityControlItemsArgs<ExtArgs>
    returnItems?: boolean | Product$returnItemsArgs<ExtArgs>
    inventoryItems?: boolean | Product$inventoryItemsArgs<ExtArgs>
    saleItems?: boolean | Product$saleItemsArgs<ExtArgs>
    transferItems?: boolean | Product$transferItemsArgs<ExtArgs>
    auditItems?: boolean | Product$auditItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Product$categoryArgs<ExtArgs>
    supplier?: boolean | Product$supplierArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Product$categoryArgs<ExtArgs>
    supplier?: boolean | Product$supplierArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs> | null
      supplier: Prisma.$SupplierPayload<ExtArgs> | null
      purchaseOrderItems: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
      qualityControlItems: Prisma.$QualityControlItemPayload<ExtArgs>[]
      returnItems: Prisma.$ReturnItemPayload<ExtArgs>[]
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      saleItems: Prisma.$SaleItemPayload<ExtArgs>[]
      transferItems: Prisma.$TransferItemPayload<ExtArgs>[]
      auditItems: Prisma.$AuditItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: string
      barcode: string | null
      name: string
      description: string | null
      unit: string
      categoryId: string | null
      supplierId: string | null
      costPrice: number
      wholesalePrice: number
      retailPrice: number
      minStockLevel: number
      reorderPoint: number
      leadTime: number | null
      condition: $Enums.ProductCondition
      createdById: string | null
      updatedById: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends Product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    supplier<T extends Product$supplierArgs<ExtArgs> = {}>(args?: Subset<T, Product$supplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    purchaseOrderItems<T extends Product$purchaseOrderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchaseOrderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qualityControlItems<T extends Product$qualityControlItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$qualityControlItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityControlItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    returnItems<T extends Product$returnItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$returnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryItems<T extends Product$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    saleItems<T extends Product$saleItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$saleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transferItems<T extends Product$transferItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$transferItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditItems<T extends Product$auditItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$auditItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly barcode: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly unit: FieldRef<"Product", 'String'>
    readonly categoryId: FieldRef<"Product", 'String'>
    readonly supplierId: FieldRef<"Product", 'String'>
    readonly costPrice: FieldRef<"Product", 'Float'>
    readonly wholesalePrice: FieldRef<"Product", 'Float'>
    readonly retailPrice: FieldRef<"Product", 'Float'>
    readonly minStockLevel: FieldRef<"Product", 'Int'>
    readonly reorderPoint: FieldRef<"Product", 'Int'>
    readonly leadTime: FieldRef<"Product", 'Int'>
    readonly condition: FieldRef<"Product", 'ProductCondition'>
    readonly createdById: FieldRef<"Product", 'String'>
    readonly updatedById: FieldRef<"Product", 'String'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.category
   */
  export type Product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Product.supplier
   */
  export type Product$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * Product.purchaseOrderItems
   */
  export type Product$purchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * Product.qualityControlItems
   */
  export type Product$qualityControlItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControlItem
     */
    select?: QualityControlItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControlItem
     */
    omit?: QualityControlItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlItemInclude<ExtArgs> | null
    where?: QualityControlItemWhereInput
    orderBy?: QualityControlItemOrderByWithRelationInput | QualityControlItemOrderByWithRelationInput[]
    cursor?: QualityControlItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QualityControlItemScalarFieldEnum | QualityControlItemScalarFieldEnum[]
  }

  /**
   * Product.returnItems
   */
  export type Product$returnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnItem
     */
    select?: ReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnItem
     */
    omit?: ReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnItemInclude<ExtArgs> | null
    where?: ReturnItemWhereInput
    orderBy?: ReturnItemOrderByWithRelationInput | ReturnItemOrderByWithRelationInput[]
    cursor?: ReturnItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnItemScalarFieldEnum | ReturnItemScalarFieldEnum[]
  }

  /**
   * Product.inventoryItems
   */
  export type Product$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Product.saleItems
   */
  export type Product$saleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    cursor?: SaleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * Product.transferItems
   */
  export type Product$transferItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    where?: TransferItemWhereInput
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    cursor?: TransferItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * Product.auditItems
   */
  export type Product$auditItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    where?: AuditItemWhereInput
    orderBy?: AuditItemOrderByWithRelationInput | AuditItemOrderByWithRelationInput[]
    cursor?: AuditItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditItemScalarFieldEnum | AuditItemScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    priceRules?: boolean | Category$priceRulesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    priceRules?: boolean | Category$priceRulesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      priceRules: Prisma.$CategoryPriceRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    priceRules<T extends Category$priceRulesArgs<ExtArgs> = {}>(args?: Subset<T, Category$priceRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPriceRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly isActive: FieldRef<"Category", 'Boolean'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category.priceRules
   */
  export type Category$priceRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryPriceRule
     */
    select?: CategoryPriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryPriceRule
     */
    omit?: CategoryPriceRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryPriceRuleInclude<ExtArgs> | null
    where?: CategoryPriceRuleWhereInput
    orderBy?: CategoryPriceRuleOrderByWithRelationInput | CategoryPriceRuleOrderByWithRelationInput[]
    cursor?: CategoryPriceRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryPriceRuleScalarFieldEnum | CategoryPriceRuleScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model CategoryPriceRule
   */

  export type AggregateCategoryPriceRule = {
    _count: CategoryPriceRuleCountAggregateOutputType | null
    _avg: CategoryPriceRuleAvgAggregateOutputType | null
    _sum: CategoryPriceRuleSumAggregateOutputType | null
    _min: CategoryPriceRuleMinAggregateOutputType | null
    _max: CategoryPriceRuleMaxAggregateOutputType | null
  }

  export type CategoryPriceRuleAvgAggregateOutputType = {
    adjustmentValue: number | null
  }

  export type CategoryPriceRuleSumAggregateOutputType = {
    adjustmentValue: number | null
  }

  export type CategoryPriceRuleMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    adjustmentType: string | null
    adjustmentValue: number | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryPriceRuleMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    adjustmentType: string | null
    adjustmentValue: number | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryPriceRuleCountAggregateOutputType = {
    id: number
    categoryId: number
    adjustmentType: number
    adjustmentValue: number
    isDefault: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryPriceRuleAvgAggregateInputType = {
    adjustmentValue?: true
  }

  export type CategoryPriceRuleSumAggregateInputType = {
    adjustmentValue?: true
  }

  export type CategoryPriceRuleMinAggregateInputType = {
    id?: true
    categoryId?: true
    adjustmentType?: true
    adjustmentValue?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryPriceRuleMaxAggregateInputType = {
    id?: true
    categoryId?: true
    adjustmentType?: true
    adjustmentValue?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryPriceRuleCountAggregateInputType = {
    id?: true
    categoryId?: true
    adjustmentType?: true
    adjustmentValue?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryPriceRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryPriceRule to aggregate.
     */
    where?: CategoryPriceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryPriceRules to fetch.
     */
    orderBy?: CategoryPriceRuleOrderByWithRelationInput | CategoryPriceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryPriceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryPriceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryPriceRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoryPriceRules
    **/
    _count?: true | CategoryPriceRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryPriceRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoryPriceRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryPriceRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryPriceRuleMaxAggregateInputType
  }

  export type GetCategoryPriceRuleAggregateType<T extends CategoryPriceRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoryPriceRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoryPriceRule[P]>
      : GetScalarType<T[P], AggregateCategoryPriceRule[P]>
  }




  export type CategoryPriceRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryPriceRuleWhereInput
    orderBy?: CategoryPriceRuleOrderByWithAggregationInput | CategoryPriceRuleOrderByWithAggregationInput[]
    by: CategoryPriceRuleScalarFieldEnum[] | CategoryPriceRuleScalarFieldEnum
    having?: CategoryPriceRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryPriceRuleCountAggregateInputType | true
    _avg?: CategoryPriceRuleAvgAggregateInputType
    _sum?: CategoryPriceRuleSumAggregateInputType
    _min?: CategoryPriceRuleMinAggregateInputType
    _max?: CategoryPriceRuleMaxAggregateInputType
  }

  export type CategoryPriceRuleGroupByOutputType = {
    id: string
    categoryId: string
    adjustmentType: string
    adjustmentValue: number
    isDefault: boolean
    createdAt: Date
    updatedAt: Date
    _count: CategoryPriceRuleCountAggregateOutputType | null
    _avg: CategoryPriceRuleAvgAggregateOutputType | null
    _sum: CategoryPriceRuleSumAggregateOutputType | null
    _min: CategoryPriceRuleMinAggregateOutputType | null
    _max: CategoryPriceRuleMaxAggregateOutputType | null
  }

  type GetCategoryPriceRuleGroupByPayload<T extends CategoryPriceRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryPriceRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryPriceRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryPriceRuleGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryPriceRuleGroupByOutputType[P]>
        }
      >
    >


  export type CategoryPriceRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    adjustmentType?: boolean
    adjustmentValue?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryPriceRule"]>

  export type CategoryPriceRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    adjustmentType?: boolean
    adjustmentValue?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryPriceRule"]>

  export type CategoryPriceRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    adjustmentType?: boolean
    adjustmentValue?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoryPriceRule"]>

  export type CategoryPriceRuleSelectScalar = {
    id?: boolean
    categoryId?: boolean
    adjustmentType?: boolean
    adjustmentValue?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryPriceRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoryId" | "adjustmentType" | "adjustmentValue" | "isDefault" | "createdAt" | "updatedAt", ExtArgs["result"]["categoryPriceRule"]>
  export type CategoryPriceRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type CategoryPriceRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type CategoryPriceRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $CategoryPriceRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CategoryPriceRule"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      adjustmentType: string
      adjustmentValue: number
      isDefault: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["categoryPriceRule"]>
    composites: {}
  }

  type CategoryPriceRuleGetPayload<S extends boolean | null | undefined | CategoryPriceRuleDefaultArgs> = $Result.GetResult<Prisma.$CategoryPriceRulePayload, S>

  type CategoryPriceRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryPriceRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryPriceRuleCountAggregateInputType | true
    }

  export interface CategoryPriceRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoryPriceRule'], meta: { name: 'CategoryPriceRule' } }
    /**
     * Find zero or one CategoryPriceRule that matches the filter.
     * @param {CategoryPriceRuleFindUniqueArgs} args - Arguments to find a CategoryPriceRule
     * @example
     * // Get one CategoryPriceRule
     * const categoryPriceRule = await prisma.categoryPriceRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryPriceRuleFindUniqueArgs>(args: SelectSubset<T, CategoryPriceRuleFindUniqueArgs<ExtArgs>>): Prisma__CategoryPriceRuleClient<$Result.GetResult<Prisma.$CategoryPriceRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CategoryPriceRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryPriceRuleFindUniqueOrThrowArgs} args - Arguments to find a CategoryPriceRule
     * @example
     * // Get one CategoryPriceRule
     * const categoryPriceRule = await prisma.categoryPriceRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryPriceRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryPriceRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryPriceRuleClient<$Result.GetResult<Prisma.$CategoryPriceRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoryPriceRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryPriceRuleFindFirstArgs} args - Arguments to find a CategoryPriceRule
     * @example
     * // Get one CategoryPriceRule
     * const categoryPriceRule = await prisma.categoryPriceRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryPriceRuleFindFirstArgs>(args?: SelectSubset<T, CategoryPriceRuleFindFirstArgs<ExtArgs>>): Prisma__CategoryPriceRuleClient<$Result.GetResult<Prisma.$CategoryPriceRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoryPriceRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryPriceRuleFindFirstOrThrowArgs} args - Arguments to find a CategoryPriceRule
     * @example
     * // Get one CategoryPriceRule
     * const categoryPriceRule = await prisma.categoryPriceRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryPriceRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryPriceRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryPriceRuleClient<$Result.GetResult<Prisma.$CategoryPriceRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CategoryPriceRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryPriceRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoryPriceRules
     * const categoryPriceRules = await prisma.categoryPriceRule.findMany()
     * 
     * // Get first 10 CategoryPriceRules
     * const categoryPriceRules = await prisma.categoryPriceRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryPriceRuleWithIdOnly = await prisma.categoryPriceRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryPriceRuleFindManyArgs>(args?: SelectSubset<T, CategoryPriceRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPriceRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CategoryPriceRule.
     * @param {CategoryPriceRuleCreateArgs} args - Arguments to create a CategoryPriceRule.
     * @example
     * // Create one CategoryPriceRule
     * const CategoryPriceRule = await prisma.categoryPriceRule.create({
     *   data: {
     *     // ... data to create a CategoryPriceRule
     *   }
     * })
     * 
     */
    create<T extends CategoryPriceRuleCreateArgs>(args: SelectSubset<T, CategoryPriceRuleCreateArgs<ExtArgs>>): Prisma__CategoryPriceRuleClient<$Result.GetResult<Prisma.$CategoryPriceRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CategoryPriceRules.
     * @param {CategoryPriceRuleCreateManyArgs} args - Arguments to create many CategoryPriceRules.
     * @example
     * // Create many CategoryPriceRules
     * const categoryPriceRule = await prisma.categoryPriceRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryPriceRuleCreateManyArgs>(args?: SelectSubset<T, CategoryPriceRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CategoryPriceRules and returns the data saved in the database.
     * @param {CategoryPriceRuleCreateManyAndReturnArgs} args - Arguments to create many CategoryPriceRules.
     * @example
     * // Create many CategoryPriceRules
     * const categoryPriceRule = await prisma.categoryPriceRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CategoryPriceRules and only return the `id`
     * const categoryPriceRuleWithIdOnly = await prisma.categoryPriceRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryPriceRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryPriceRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPriceRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CategoryPriceRule.
     * @param {CategoryPriceRuleDeleteArgs} args - Arguments to delete one CategoryPriceRule.
     * @example
     * // Delete one CategoryPriceRule
     * const CategoryPriceRule = await prisma.categoryPriceRule.delete({
     *   where: {
     *     // ... filter to delete one CategoryPriceRule
     *   }
     * })
     * 
     */
    delete<T extends CategoryPriceRuleDeleteArgs>(args: SelectSubset<T, CategoryPriceRuleDeleteArgs<ExtArgs>>): Prisma__CategoryPriceRuleClient<$Result.GetResult<Prisma.$CategoryPriceRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CategoryPriceRule.
     * @param {CategoryPriceRuleUpdateArgs} args - Arguments to update one CategoryPriceRule.
     * @example
     * // Update one CategoryPriceRule
     * const categoryPriceRule = await prisma.categoryPriceRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryPriceRuleUpdateArgs>(args: SelectSubset<T, CategoryPriceRuleUpdateArgs<ExtArgs>>): Prisma__CategoryPriceRuleClient<$Result.GetResult<Prisma.$CategoryPriceRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CategoryPriceRules.
     * @param {CategoryPriceRuleDeleteManyArgs} args - Arguments to filter CategoryPriceRules to delete.
     * @example
     * // Delete a few CategoryPriceRules
     * const { count } = await prisma.categoryPriceRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryPriceRuleDeleteManyArgs>(args?: SelectSubset<T, CategoryPriceRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryPriceRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryPriceRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoryPriceRules
     * const categoryPriceRule = await prisma.categoryPriceRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryPriceRuleUpdateManyArgs>(args: SelectSubset<T, CategoryPriceRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoryPriceRules and returns the data updated in the database.
     * @param {CategoryPriceRuleUpdateManyAndReturnArgs} args - Arguments to update many CategoryPriceRules.
     * @example
     * // Update many CategoryPriceRules
     * const categoryPriceRule = await prisma.categoryPriceRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CategoryPriceRules and only return the `id`
     * const categoryPriceRuleWithIdOnly = await prisma.categoryPriceRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryPriceRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryPriceRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPriceRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CategoryPriceRule.
     * @param {CategoryPriceRuleUpsertArgs} args - Arguments to update or create a CategoryPriceRule.
     * @example
     * // Update or create a CategoryPriceRule
     * const categoryPriceRule = await prisma.categoryPriceRule.upsert({
     *   create: {
     *     // ... data to create a CategoryPriceRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoryPriceRule we want to update
     *   }
     * })
     */
    upsert<T extends CategoryPriceRuleUpsertArgs>(args: SelectSubset<T, CategoryPriceRuleUpsertArgs<ExtArgs>>): Prisma__CategoryPriceRuleClient<$Result.GetResult<Prisma.$CategoryPriceRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CategoryPriceRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryPriceRuleCountArgs} args - Arguments to filter CategoryPriceRules to count.
     * @example
     * // Count the number of CategoryPriceRules
     * const count = await prisma.categoryPriceRule.count({
     *   where: {
     *     // ... the filter for the CategoryPriceRules we want to count
     *   }
     * })
    **/
    count<T extends CategoryPriceRuleCountArgs>(
      args?: Subset<T, CategoryPriceRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryPriceRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoryPriceRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryPriceRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryPriceRuleAggregateArgs>(args: Subset<T, CategoryPriceRuleAggregateArgs>): Prisma.PrismaPromise<GetCategoryPriceRuleAggregateType<T>>

    /**
     * Group by CategoryPriceRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryPriceRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryPriceRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryPriceRuleGroupByArgs['orderBy'] }
        : { orderBy?: CategoryPriceRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryPriceRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryPriceRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoryPriceRule model
   */
  readonly fields: CategoryPriceRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoryPriceRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryPriceRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CategoryPriceRule model
   */
  interface CategoryPriceRuleFieldRefs {
    readonly id: FieldRef<"CategoryPriceRule", 'String'>
    readonly categoryId: FieldRef<"CategoryPriceRule", 'String'>
    readonly adjustmentType: FieldRef<"CategoryPriceRule", 'String'>
    readonly adjustmentValue: FieldRef<"CategoryPriceRule", 'Float'>
    readonly isDefault: FieldRef<"CategoryPriceRule", 'Boolean'>
    readonly createdAt: FieldRef<"CategoryPriceRule", 'DateTime'>
    readonly updatedAt: FieldRef<"CategoryPriceRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CategoryPriceRule findUnique
   */
  export type CategoryPriceRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryPriceRule
     */
    select?: CategoryPriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryPriceRule
     */
    omit?: CategoryPriceRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryPriceRuleInclude<ExtArgs> | null
    /**
     * Filter, which CategoryPriceRule to fetch.
     */
    where: CategoryPriceRuleWhereUniqueInput
  }

  /**
   * CategoryPriceRule findUniqueOrThrow
   */
  export type CategoryPriceRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryPriceRule
     */
    select?: CategoryPriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryPriceRule
     */
    omit?: CategoryPriceRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryPriceRuleInclude<ExtArgs> | null
    /**
     * Filter, which CategoryPriceRule to fetch.
     */
    where: CategoryPriceRuleWhereUniqueInput
  }

  /**
   * CategoryPriceRule findFirst
   */
  export type CategoryPriceRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryPriceRule
     */
    select?: CategoryPriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryPriceRule
     */
    omit?: CategoryPriceRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryPriceRuleInclude<ExtArgs> | null
    /**
     * Filter, which CategoryPriceRule to fetch.
     */
    where?: CategoryPriceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryPriceRules to fetch.
     */
    orderBy?: CategoryPriceRuleOrderByWithRelationInput | CategoryPriceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryPriceRules.
     */
    cursor?: CategoryPriceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryPriceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryPriceRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryPriceRules.
     */
    distinct?: CategoryPriceRuleScalarFieldEnum | CategoryPriceRuleScalarFieldEnum[]
  }

  /**
   * CategoryPriceRule findFirstOrThrow
   */
  export type CategoryPriceRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryPriceRule
     */
    select?: CategoryPriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryPriceRule
     */
    omit?: CategoryPriceRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryPriceRuleInclude<ExtArgs> | null
    /**
     * Filter, which CategoryPriceRule to fetch.
     */
    where?: CategoryPriceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryPriceRules to fetch.
     */
    orderBy?: CategoryPriceRuleOrderByWithRelationInput | CategoryPriceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoryPriceRules.
     */
    cursor?: CategoryPriceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryPriceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryPriceRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoryPriceRules.
     */
    distinct?: CategoryPriceRuleScalarFieldEnum | CategoryPriceRuleScalarFieldEnum[]
  }

  /**
   * CategoryPriceRule findMany
   */
  export type CategoryPriceRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryPriceRule
     */
    select?: CategoryPriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryPriceRule
     */
    omit?: CategoryPriceRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryPriceRuleInclude<ExtArgs> | null
    /**
     * Filter, which CategoryPriceRules to fetch.
     */
    where?: CategoryPriceRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoryPriceRules to fetch.
     */
    orderBy?: CategoryPriceRuleOrderByWithRelationInput | CategoryPriceRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoryPriceRules.
     */
    cursor?: CategoryPriceRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoryPriceRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoryPriceRules.
     */
    skip?: number
    distinct?: CategoryPriceRuleScalarFieldEnum | CategoryPriceRuleScalarFieldEnum[]
  }

  /**
   * CategoryPriceRule create
   */
  export type CategoryPriceRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryPriceRule
     */
    select?: CategoryPriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryPriceRule
     */
    omit?: CategoryPriceRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryPriceRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoryPriceRule.
     */
    data: XOR<CategoryPriceRuleCreateInput, CategoryPriceRuleUncheckedCreateInput>
  }

  /**
   * CategoryPriceRule createMany
   */
  export type CategoryPriceRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoryPriceRules.
     */
    data: CategoryPriceRuleCreateManyInput | CategoryPriceRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CategoryPriceRule createManyAndReturn
   */
  export type CategoryPriceRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryPriceRule
     */
    select?: CategoryPriceRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryPriceRule
     */
    omit?: CategoryPriceRuleOmit<ExtArgs> | null
    /**
     * The data used to create many CategoryPriceRules.
     */
    data: CategoryPriceRuleCreateManyInput | CategoryPriceRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryPriceRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CategoryPriceRule update
   */
  export type CategoryPriceRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryPriceRule
     */
    select?: CategoryPriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryPriceRule
     */
    omit?: CategoryPriceRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryPriceRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoryPriceRule.
     */
    data: XOR<CategoryPriceRuleUpdateInput, CategoryPriceRuleUncheckedUpdateInput>
    /**
     * Choose, which CategoryPriceRule to update.
     */
    where: CategoryPriceRuleWhereUniqueInput
  }

  /**
   * CategoryPriceRule updateMany
   */
  export type CategoryPriceRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoryPriceRules.
     */
    data: XOR<CategoryPriceRuleUpdateManyMutationInput, CategoryPriceRuleUncheckedUpdateManyInput>
    /**
     * Filter which CategoryPriceRules to update
     */
    where?: CategoryPriceRuleWhereInput
    /**
     * Limit how many CategoryPriceRules to update.
     */
    limit?: number
  }

  /**
   * CategoryPriceRule updateManyAndReturn
   */
  export type CategoryPriceRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryPriceRule
     */
    select?: CategoryPriceRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryPriceRule
     */
    omit?: CategoryPriceRuleOmit<ExtArgs> | null
    /**
     * The data used to update CategoryPriceRules.
     */
    data: XOR<CategoryPriceRuleUpdateManyMutationInput, CategoryPriceRuleUncheckedUpdateManyInput>
    /**
     * Filter which CategoryPriceRules to update
     */
    where?: CategoryPriceRuleWhereInput
    /**
     * Limit how many CategoryPriceRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryPriceRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CategoryPriceRule upsert
   */
  export type CategoryPriceRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryPriceRule
     */
    select?: CategoryPriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryPriceRule
     */
    omit?: CategoryPriceRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryPriceRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoryPriceRule to update in case it exists.
     */
    where: CategoryPriceRuleWhereUniqueInput
    /**
     * In case the CategoryPriceRule found by the `where` argument doesn't exist, create a new CategoryPriceRule with this data.
     */
    create: XOR<CategoryPriceRuleCreateInput, CategoryPriceRuleUncheckedCreateInput>
    /**
     * In case the CategoryPriceRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryPriceRuleUpdateInput, CategoryPriceRuleUncheckedUpdateInput>
  }

  /**
   * CategoryPriceRule delete
   */
  export type CategoryPriceRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryPriceRule
     */
    select?: CategoryPriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryPriceRule
     */
    omit?: CategoryPriceRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryPriceRuleInclude<ExtArgs> | null
    /**
     * Filter which CategoryPriceRule to delete.
     */
    where: CategoryPriceRuleWhereUniqueInput
  }

  /**
   * CategoryPriceRule deleteMany
   */
  export type CategoryPriceRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoryPriceRules to delete
     */
    where?: CategoryPriceRuleWhereInput
    /**
     * Limit how many CategoryPriceRules to delete.
     */
    limit?: number
  }

  /**
   * CategoryPriceRule without action
   */
  export type CategoryPriceRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryPriceRule
     */
    select?: CategoryPriceRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CategoryPriceRule
     */
    omit?: CategoryPriceRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryPriceRuleInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    quantity: number | null
    reservedQuantity: number | null
    costPrice: number | null
    retailPrice: number | null
  }

  export type InventoryItemSumAggregateOutputType = {
    quantity: number | null
    reservedQuantity: number | null
    costPrice: number | null
    retailPrice: number | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: string | null
    productId: string | null
    storeId: string | null
    warehouseId: string | null
    binId: string | null
    batchNumber: string | null
    lotNumber: string | null
    serialNumber: string | null
    expiryDate: Date | null
    manufacturingDate: Date | null
    quantity: number | null
    reservedQuantity: number | null
    costPrice: number | null
    retailPrice: number | null
    status: $Enums.InventoryStatus | null
    condition: $Enums.ProductCondition | null
    inventoryMethod: $Enums.InventoryMethod | null
    receivedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    storeId: string | null
    warehouseId: string | null
    binId: string | null
    batchNumber: string | null
    lotNumber: string | null
    serialNumber: string | null
    expiryDate: Date | null
    manufacturingDate: Date | null
    quantity: number | null
    reservedQuantity: number | null
    costPrice: number | null
    retailPrice: number | null
    status: $Enums.InventoryStatus | null
    condition: $Enums.ProductCondition | null
    inventoryMethod: $Enums.InventoryMethod | null
    receivedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    productId: number
    storeId: number
    warehouseId: number
    binId: number
    batchNumber: number
    lotNumber: number
    serialNumber: number
    expiryDate: number
    manufacturingDate: number
    quantity: number
    reservedQuantity: number
    costPrice: number
    retailPrice: number
    status: number
    condition: number
    inventoryMethod: number
    receivedDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    quantity?: true
    reservedQuantity?: true
    costPrice?: true
    retailPrice?: true
  }

  export type InventoryItemSumAggregateInputType = {
    quantity?: true
    reservedQuantity?: true
    costPrice?: true
    retailPrice?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    productId?: true
    storeId?: true
    warehouseId?: true
    binId?: true
    batchNumber?: true
    lotNumber?: true
    serialNumber?: true
    expiryDate?: true
    manufacturingDate?: true
    quantity?: true
    reservedQuantity?: true
    costPrice?: true
    retailPrice?: true
    status?: true
    condition?: true
    inventoryMethod?: true
    receivedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    productId?: true
    storeId?: true
    warehouseId?: true
    binId?: true
    batchNumber?: true
    lotNumber?: true
    serialNumber?: true
    expiryDate?: true
    manufacturingDate?: true
    quantity?: true
    reservedQuantity?: true
    costPrice?: true
    retailPrice?: true
    status?: true
    condition?: true
    inventoryMethod?: true
    receivedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    productId?: true
    storeId?: true
    warehouseId?: true
    binId?: true
    batchNumber?: true
    lotNumber?: true
    serialNumber?: true
    expiryDate?: true
    manufacturingDate?: true
    quantity?: true
    reservedQuantity?: true
    costPrice?: true
    retailPrice?: true
    status?: true
    condition?: true
    inventoryMethod?: true
    receivedDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: string
    productId: string
    storeId: string | null
    warehouseId: string | null
    binId: string | null
    batchNumber: string | null
    lotNumber: string | null
    serialNumber: string | null
    expiryDate: Date | null
    manufacturingDate: Date | null
    quantity: number
    reservedQuantity: number
    costPrice: number
    retailPrice: number
    status: $Enums.InventoryStatus
    condition: $Enums.ProductCondition
    inventoryMethod: $Enums.InventoryMethod | null
    receivedDate: Date
    createdAt: Date
    updatedAt: Date
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    storeId?: boolean
    warehouseId?: boolean
    binId?: boolean
    batchNumber?: boolean
    lotNumber?: boolean
    serialNumber?: boolean
    expiryDate?: boolean
    manufacturingDate?: boolean
    quantity?: boolean
    reservedQuantity?: boolean
    costPrice?: boolean
    retailPrice?: boolean
    status?: boolean
    condition?: boolean
    inventoryMethod?: boolean
    receivedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | InventoryItem$storeArgs<ExtArgs>
    warehouse?: boolean | InventoryItem$warehouseArgs<ExtArgs>
    bin?: boolean | InventoryItem$binArgs<ExtArgs>
    saleItems?: boolean | InventoryItem$saleItemsArgs<ExtArgs>
    auditItems?: boolean | InventoryItem$auditItemsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    storeId?: boolean
    warehouseId?: boolean
    binId?: boolean
    batchNumber?: boolean
    lotNumber?: boolean
    serialNumber?: boolean
    expiryDate?: boolean
    manufacturingDate?: boolean
    quantity?: boolean
    reservedQuantity?: boolean
    costPrice?: boolean
    retailPrice?: boolean
    status?: boolean
    condition?: boolean
    inventoryMethod?: boolean
    receivedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | InventoryItem$storeArgs<ExtArgs>
    warehouse?: boolean | InventoryItem$warehouseArgs<ExtArgs>
    bin?: boolean | InventoryItem$binArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    storeId?: boolean
    warehouseId?: boolean
    binId?: boolean
    batchNumber?: boolean
    lotNumber?: boolean
    serialNumber?: boolean
    expiryDate?: boolean
    manufacturingDate?: boolean
    quantity?: boolean
    reservedQuantity?: boolean
    costPrice?: boolean
    retailPrice?: boolean
    status?: boolean
    condition?: boolean
    inventoryMethod?: boolean
    receivedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | InventoryItem$storeArgs<ExtArgs>
    warehouse?: boolean | InventoryItem$warehouseArgs<ExtArgs>
    bin?: boolean | InventoryItem$binArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    productId?: boolean
    storeId?: boolean
    warehouseId?: boolean
    binId?: boolean
    batchNumber?: boolean
    lotNumber?: boolean
    serialNumber?: boolean
    expiryDate?: boolean
    manufacturingDate?: boolean
    quantity?: boolean
    reservedQuantity?: boolean
    costPrice?: boolean
    retailPrice?: boolean
    status?: boolean
    condition?: boolean
    inventoryMethod?: boolean
    receivedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "storeId" | "warehouseId" | "binId" | "batchNumber" | "lotNumber" | "serialNumber" | "expiryDate" | "manufacturingDate" | "quantity" | "reservedQuantity" | "costPrice" | "retailPrice" | "status" | "condition" | "inventoryMethod" | "receivedDate" | "createdAt" | "updatedAt", ExtArgs["result"]["inventoryItem"]>
  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | InventoryItem$storeArgs<ExtArgs>
    warehouse?: boolean | InventoryItem$warehouseArgs<ExtArgs>
    bin?: boolean | InventoryItem$binArgs<ExtArgs>
    saleItems?: boolean | InventoryItem$saleItemsArgs<ExtArgs>
    auditItems?: boolean | InventoryItem$auditItemsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | InventoryItem$storeArgs<ExtArgs>
    warehouse?: boolean | InventoryItem$warehouseArgs<ExtArgs>
    bin?: boolean | InventoryItem$binArgs<ExtArgs>
  }
  export type InventoryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | InventoryItem$storeArgs<ExtArgs>
    warehouse?: boolean | InventoryItem$warehouseArgs<ExtArgs>
    bin?: boolean | InventoryItem$binArgs<ExtArgs>
  }

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      store: Prisma.$StorePayload<ExtArgs> | null
      warehouse: Prisma.$WarehousePayload<ExtArgs> | null
      bin: Prisma.$WarehouseBinPayload<ExtArgs> | null
      saleItems: Prisma.$SaleItemPayload<ExtArgs>[]
      auditItems: Prisma.$AuditItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      storeId: string | null
      warehouseId: string | null
      binId: string | null
      batchNumber: string | null
      lotNumber: string | null
      serialNumber: string | null
      expiryDate: Date | null
      manufacturingDate: Date | null
      quantity: number
      reservedQuantity: number
      costPrice: number
      retailPrice: number
      status: $Enums.InventoryStatus
      condition: $Enums.ProductCondition
      inventoryMethod: $Enums.InventoryMethod | null
      receivedDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems and returns the data updated in the database.
     * @param {InventoryItemUpdateManyAndReturnArgs} args - Arguments to update many InventoryItems.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    store<T extends InventoryItem$storeArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$storeArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends InventoryItem$warehouseArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$warehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bin<T extends InventoryItem$binArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$binArgs<ExtArgs>>): Prisma__WarehouseBinClient<$Result.GetResult<Prisma.$WarehouseBinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    saleItems<T extends InventoryItem$saleItemsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$saleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditItems<T extends InventoryItem$auditItemsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$auditItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'String'>
    readonly productId: FieldRef<"InventoryItem", 'String'>
    readonly storeId: FieldRef<"InventoryItem", 'String'>
    readonly warehouseId: FieldRef<"InventoryItem", 'String'>
    readonly binId: FieldRef<"InventoryItem", 'String'>
    readonly batchNumber: FieldRef<"InventoryItem", 'String'>
    readonly lotNumber: FieldRef<"InventoryItem", 'String'>
    readonly serialNumber: FieldRef<"InventoryItem", 'String'>
    readonly expiryDate: FieldRef<"InventoryItem", 'DateTime'>
    readonly manufacturingDate: FieldRef<"InventoryItem", 'DateTime'>
    readonly quantity: FieldRef<"InventoryItem", 'Int'>
    readonly reservedQuantity: FieldRef<"InventoryItem", 'Int'>
    readonly costPrice: FieldRef<"InventoryItem", 'Float'>
    readonly retailPrice: FieldRef<"InventoryItem", 'Float'>
    readonly status: FieldRef<"InventoryItem", 'InventoryStatus'>
    readonly condition: FieldRef<"InventoryItem", 'ProductCondition'>
    readonly inventoryMethod: FieldRef<"InventoryItem", 'InventoryMethod'>
    readonly receivedDate: FieldRef<"InventoryItem", 'DateTime'>
    readonly createdAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
  }

  /**
   * InventoryItem updateManyAndReturn
   */
  export type InventoryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to delete.
     */
    limit?: number
  }

  /**
   * InventoryItem.store
   */
  export type InventoryItem$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * InventoryItem.warehouse
   */
  export type InventoryItem$warehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * InventoryItem.bin
   */
  export type InventoryItem$binArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseBin
     */
    select?: WarehouseBinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarehouseBin
     */
    omit?: WarehouseBinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseBinInclude<ExtArgs> | null
    where?: WarehouseBinWhereInput
  }

  /**
   * InventoryItem.saleItems
   */
  export type InventoryItem$saleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    cursor?: SaleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * InventoryItem.auditItems
   */
  export type InventoryItem$auditItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    where?: AuditItemWhereInput
    orderBy?: AuditItemOrderByWithRelationInput | AuditItemOrderByWithRelationInput[]
    cursor?: AuditItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditItemScalarFieldEnum | AuditItemScalarFieldEnum[]
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model Sale
   */

  export type AggregateSale = {
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  export type SaleAvgAggregateOutputType = {
    subtotal: number | null
    taxAmount: number | null
    discountAmount: number | null
    totalAmount: number | null
  }

  export type SaleSumAggregateOutputType = {
    subtotal: number | null
    taxAmount: number | null
    discountAmount: number | null
    totalAmount: number | null
  }

  export type SaleMinAggregateOutputType = {
    id: string | null
    receiptNumber: string | null
    storeId: string | null
    customerId: string | null
    createdById: string | null
    saleDate: Date | null
    subtotal: number | null
    taxAmount: number | null
    discountAmount: number | null
    totalAmount: number | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentStatus: $Enums.PaymentStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleMaxAggregateOutputType = {
    id: string | null
    receiptNumber: string | null
    storeId: string | null
    customerId: string | null
    createdById: string | null
    saleDate: Date | null
    subtotal: number | null
    taxAmount: number | null
    discountAmount: number | null
    totalAmount: number | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentStatus: $Enums.PaymentStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleCountAggregateOutputType = {
    id: number
    receiptNumber: number
    storeId: number
    customerId: number
    createdById: number
    saleDate: number
    subtotal: number
    taxAmount: number
    discountAmount: number
    totalAmount: number
    paymentMethod: number
    paymentStatus: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaleAvgAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    totalAmount?: true
  }

  export type SaleSumAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    totalAmount?: true
  }

  export type SaleMinAggregateInputType = {
    id?: true
    receiptNumber?: true
    storeId?: true
    customerId?: true
    createdById?: true
    saleDate?: true
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    totalAmount?: true
    paymentMethod?: true
    paymentStatus?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleMaxAggregateInputType = {
    id?: true
    receiptNumber?: true
    storeId?: true
    customerId?: true
    createdById?: true
    saleDate?: true
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    totalAmount?: true
    paymentMethod?: true
    paymentStatus?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleCountAggregateInputType = {
    id?: true
    receiptNumber?: true
    storeId?: true
    customerId?: true
    createdById?: true
    saleDate?: true
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    totalAmount?: true
    paymentMethod?: true
    paymentStatus?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sale to aggregate.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sales
    **/
    _count?: true | SaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMaxAggregateInputType
  }

  export type GetSaleAggregateType<T extends SaleAggregateArgs> = {
        [P in keyof T & keyof AggregateSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale[P]>
      : GetScalarType<T[P], AggregateSale[P]>
  }




  export type SaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithAggregationInput | SaleOrderByWithAggregationInput[]
    by: SaleScalarFieldEnum[] | SaleScalarFieldEnum
    having?: SaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleCountAggregateInputType | true
    _avg?: SaleAvgAggregateInputType
    _sum?: SaleSumAggregateInputType
    _min?: SaleMinAggregateInputType
    _max?: SaleMaxAggregateInputType
  }

  export type SaleGroupByOutputType = {
    id: string
    receiptNumber: string
    storeId: string
    customerId: string | null
    createdById: string
    saleDate: Date
    subtotal: number
    taxAmount: number
    discountAmount: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus: $Enums.PaymentStatus
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  type GetSaleGroupByPayload<T extends SaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleGroupByOutputType[P]>
            : GetScalarType<T[P], SaleGroupByOutputType[P]>
        }
      >
    >


  export type SaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNumber?: boolean
    storeId?: boolean
    customerId?: boolean
    createdById?: boolean
    saleDate?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    totalAmount?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Sale$itemsArgs<ExtArgs>
    payments?: boolean | Sale$paymentsArgs<ExtArgs>
    returns?: boolean | Sale$returnsArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNumber?: boolean
    storeId?: boolean
    customerId?: boolean
    createdById?: boolean
    saleDate?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    totalAmount?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNumber?: boolean
    storeId?: boolean
    customerId?: boolean
    createdById?: boolean
    saleDate?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    totalAmount?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectScalar = {
    id?: boolean
    receiptNumber?: boolean
    storeId?: boolean
    customerId?: boolean
    createdById?: boolean
    saleDate?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    totalAmount?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "receiptNumber" | "storeId" | "customerId" | "createdById" | "saleDate" | "subtotal" | "taxAmount" | "discountAmount" | "totalAmount" | "paymentMethod" | "paymentStatus" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["sale"]>
  export type SaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Sale$itemsArgs<ExtArgs>
    payments?: boolean | Sale$paymentsArgs<ExtArgs>
    returns?: boolean | Sale$returnsArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sale"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$SaleItemPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      returns: Prisma.$ReturnPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      receiptNumber: string
      storeId: string
      customerId: string | null
      createdById: string
      saleDate: Date
      subtotal: number
      taxAmount: number
      discountAmount: number
      totalAmount: number
      paymentMethod: $Enums.PaymentMethod
      paymentStatus: $Enums.PaymentStatus
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sale"]>
    composites: {}
  }

  type SaleGetPayload<S extends boolean | null | undefined | SaleDefaultArgs> = $Result.GetResult<Prisma.$SalePayload, S>

  type SaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleCountAggregateInputType | true
    }

  export interface SaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sale'], meta: { name: 'Sale' } }
    /**
     * Find zero or one Sale that matches the filter.
     * @param {SaleFindUniqueArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleFindUniqueArgs>(args: SelectSubset<T, SaleFindUniqueArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleFindUniqueOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleFindFirstArgs>(args?: SelectSubset<T, SaleFindFirstArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sale.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleWithIdOnly = await prisma.sale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleFindManyArgs>(args?: SelectSubset<T, SaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sale.
     * @param {SaleCreateArgs} args - Arguments to create a Sale.
     * @example
     * // Create one Sale
     * const Sale = await prisma.sale.create({
     *   data: {
     *     // ... data to create a Sale
     *   }
     * })
     * 
     */
    create<T extends SaleCreateArgs>(args: SelectSubset<T, SaleCreateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sales.
     * @param {SaleCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleCreateManyArgs>(args?: SelectSubset<T, SaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sales and returns the data saved in the database.
     * @param {SaleCreateManyAndReturnArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sale.
     * @param {SaleDeleteArgs} args - Arguments to delete one Sale.
     * @example
     * // Delete one Sale
     * const Sale = await prisma.sale.delete({
     *   where: {
     *     // ... filter to delete one Sale
     *   }
     * })
     * 
     */
    delete<T extends SaleDeleteArgs>(args: SelectSubset<T, SaleDeleteArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sale.
     * @param {SaleUpdateArgs} args - Arguments to update one Sale.
     * @example
     * // Update one Sale
     * const sale = await prisma.sale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleUpdateArgs>(args: SelectSubset<T, SaleUpdateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sales.
     * @param {SaleDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleDeleteManyArgs>(args?: SelectSubset<T, SaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleUpdateManyArgs>(args: SelectSubset<T, SaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales and returns the data updated in the database.
     * @param {SaleUpdateManyAndReturnArgs} args - Arguments to update many Sales.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sale.
     * @param {SaleUpsertArgs} args - Arguments to update or create a Sale.
     * @example
     * // Update or create a Sale
     * const sale = await prisma.sale.upsert({
     *   create: {
     *     // ... data to create a Sale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale we want to update
     *   }
     * })
     */
    upsert<T extends SaleUpsertArgs>(args: SelectSubset<T, SaleUpsertArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sale.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends SaleCountArgs>(
      args?: Subset<T, SaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleAggregateArgs>(args: Subset<T, SaleAggregateArgs>): Prisma.PrismaPromise<GetSaleAggregateType<T>>

    /**
     * Group by Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleGroupByArgs['orderBy'] }
        : { orderBy?: SaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sale model
   */
  readonly fields: SaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends Sale$customerArgs<ExtArgs> = {}>(args?: Subset<T, Sale$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Sale$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Sale$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Sale$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Sale$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    returns<T extends Sale$returnsArgs<ExtArgs> = {}>(args?: Subset<T, Sale$returnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sale model
   */
  interface SaleFieldRefs {
    readonly id: FieldRef<"Sale", 'String'>
    readonly receiptNumber: FieldRef<"Sale", 'String'>
    readonly storeId: FieldRef<"Sale", 'String'>
    readonly customerId: FieldRef<"Sale", 'String'>
    readonly createdById: FieldRef<"Sale", 'String'>
    readonly saleDate: FieldRef<"Sale", 'DateTime'>
    readonly subtotal: FieldRef<"Sale", 'Float'>
    readonly taxAmount: FieldRef<"Sale", 'Float'>
    readonly discountAmount: FieldRef<"Sale", 'Float'>
    readonly totalAmount: FieldRef<"Sale", 'Float'>
    readonly paymentMethod: FieldRef<"Sale", 'PaymentMethod'>
    readonly paymentStatus: FieldRef<"Sale", 'PaymentStatus'>
    readonly notes: FieldRef<"Sale", 'String'>
    readonly createdAt: FieldRef<"Sale", 'DateTime'>
    readonly updatedAt: FieldRef<"Sale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sale findUnique
   */
  export type SaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findUniqueOrThrow
   */
  export type SaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findFirst
   */
  export type SaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findFirstOrThrow
   */
  export type SaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findMany
   */
  export type SaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale create
   */
  export type SaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to create a Sale.
     */
    data: XOR<SaleCreateInput, SaleUncheckedCreateInput>
  }

  /**
   * Sale createMany
   */
  export type SaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sale createManyAndReturn
   */
  export type SaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale update
   */
  export type SaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to update a Sale.
     */
    data: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
    /**
     * Choose, which Sale to update.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale updateMany
   */
  export type SaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
  }

  /**
   * Sale updateManyAndReturn
   */
  export type SaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale upsert
   */
  export type SaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The filter to search for the Sale to update in case it exists.
     */
    where: SaleWhereUniqueInput
    /**
     * In case the Sale found by the `where` argument doesn't exist, create a new Sale with this data.
     */
    create: XOR<SaleCreateInput, SaleUncheckedCreateInput>
    /**
     * In case the Sale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
  }

  /**
   * Sale delete
   */
  export type SaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter which Sale to delete.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale deleteMany
   */
  export type SaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sales to delete
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to delete.
     */
    limit?: number
  }

  /**
   * Sale.customer
   */
  export type Sale$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Sale.items
   */
  export type Sale$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    cursor?: SaleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * Sale.payments
   */
  export type Sale$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Sale.returns
   */
  export type Sale$returnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnInclude<ExtArgs> | null
    where?: ReturnWhereInput
    orderBy?: ReturnOrderByWithRelationInput | ReturnOrderByWithRelationInput[]
    cursor?: ReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnScalarFieldEnum | ReturnScalarFieldEnum[]
  }

  /**
   * Sale without action
   */
  export type SaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
  }


  /**
   * Model SaleItem
   */

  export type AggregateSaleItem = {
    _count: SaleItemCountAggregateOutputType | null
    _avg: SaleItemAvgAggregateOutputType | null
    _sum: SaleItemSumAggregateOutputType | null
    _min: SaleItemMinAggregateOutputType | null
    _max: SaleItemMaxAggregateOutputType | null
  }

  export type SaleItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    discountAmount: number | null
    taxAmount: number | null
    totalPrice: number | null
  }

  export type SaleItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    discountAmount: number | null
    taxAmount: number | null
    totalPrice: number | null
  }

  export type SaleItemMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    productId: string | null
    inventoryItemId: string | null
    quantity: number | null
    unitPrice: number | null
    discountAmount: number | null
    taxAmount: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleItemMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    productId: string | null
    inventoryItemId: string | null
    quantity: number | null
    unitPrice: number | null
    discountAmount: number | null
    taxAmount: number | null
    totalPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleItemCountAggregateOutputType = {
    id: number
    saleId: number
    productId: number
    inventoryItemId: number
    quantity: number
    unitPrice: number
    discountAmount: number
    taxAmount: number
    totalPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaleItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    discountAmount?: true
    taxAmount?: true
    totalPrice?: true
  }

  export type SaleItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    discountAmount?: true
    taxAmount?: true
    totalPrice?: true
  }

  export type SaleItemMinAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    inventoryItemId?: true
    quantity?: true
    unitPrice?: true
    discountAmount?: true
    taxAmount?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleItemMaxAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    inventoryItemId?: true
    quantity?: true
    unitPrice?: true
    discountAmount?: true
    taxAmount?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleItemCountAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    inventoryItemId?: true
    quantity?: true
    unitPrice?: true
    discountAmount?: true
    taxAmount?: true
    totalPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaleItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleItem to aggregate.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleItems
    **/
    _count?: true | SaleItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleItemMaxAggregateInputType
  }

  export type GetSaleItemAggregateType<T extends SaleItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleItem[P]>
      : GetScalarType<T[P], AggregateSaleItem[P]>
  }




  export type SaleItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithAggregationInput | SaleItemOrderByWithAggregationInput[]
    by: SaleItemScalarFieldEnum[] | SaleItemScalarFieldEnum
    having?: SaleItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleItemCountAggregateInputType | true
    _avg?: SaleItemAvgAggregateInputType
    _sum?: SaleItemSumAggregateInputType
    _min?: SaleItemMinAggregateInputType
    _max?: SaleItemMaxAggregateInputType
  }

  export type SaleItemGroupByOutputType = {
    id: string
    saleId: string
    productId: string
    inventoryItemId: string
    quantity: number
    unitPrice: number
    discountAmount: number
    taxAmount: number
    totalPrice: number
    createdAt: Date
    updatedAt: Date
    _count: SaleItemCountAggregateOutputType | null
    _avg: SaleItemAvgAggregateOutputType | null
    _sum: SaleItemSumAggregateOutputType | null
    _min: SaleItemMinAggregateOutputType | null
    _max: SaleItemMaxAggregateOutputType | null
  }

  type GetSaleItemGroupByPayload<T extends SaleItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleItemGroupByOutputType[P]>
            : GetScalarType<T[P], SaleItemGroupByOutputType[P]>
        }
      >
    >


  export type SaleItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    returnItems?: boolean | SaleItem$returnItemsArgs<ExtArgs>
    _count?: boolean | SaleItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleItem"]>

  export type SaleItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleItem"]>

  export type SaleItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleItem"]>

  export type SaleItemSelectScalar = {
    id?: boolean
    saleId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    totalPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SaleItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saleId" | "productId" | "inventoryItemId" | "quantity" | "unitPrice" | "discountAmount" | "taxAmount" | "totalPrice" | "createdAt" | "updatedAt", ExtArgs["result"]["saleItem"]>
  export type SaleItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
    returnItems?: boolean | SaleItem$returnItemsArgs<ExtArgs>
    _count?: boolean | SaleItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SaleItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type SaleItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }

  export type $SaleItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleItem"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      inventoryItem: Prisma.$InventoryItemPayload<ExtArgs>
      returnItems: Prisma.$ReturnItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      productId: string
      inventoryItemId: string
      quantity: number
      unitPrice: number
      discountAmount: number
      taxAmount: number
      totalPrice: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["saleItem"]>
    composites: {}
  }

  type SaleItemGetPayload<S extends boolean | null | undefined | SaleItemDefaultArgs> = $Result.GetResult<Prisma.$SaleItemPayload, S>

  type SaleItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleItemCountAggregateInputType | true
    }

  export interface SaleItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleItem'], meta: { name: 'SaleItem' } }
    /**
     * Find zero or one SaleItem that matches the filter.
     * @param {SaleItemFindUniqueArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleItemFindUniqueArgs>(args: SelectSubset<T, SaleItemFindUniqueArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleItemFindUniqueOrThrowArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemFindFirstArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleItemFindFirstArgs>(args?: SelectSubset<T, SaleItemFindFirstArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemFindFirstOrThrowArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleItems
     * const saleItems = await prisma.saleItem.findMany()
     * 
     * // Get first 10 SaleItems
     * const saleItems = await prisma.saleItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleItemWithIdOnly = await prisma.saleItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleItemFindManyArgs>(args?: SelectSubset<T, SaleItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleItem.
     * @param {SaleItemCreateArgs} args - Arguments to create a SaleItem.
     * @example
     * // Create one SaleItem
     * const SaleItem = await prisma.saleItem.create({
     *   data: {
     *     // ... data to create a SaleItem
     *   }
     * })
     * 
     */
    create<T extends SaleItemCreateArgs>(args: SelectSubset<T, SaleItemCreateArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleItems.
     * @param {SaleItemCreateManyArgs} args - Arguments to create many SaleItems.
     * @example
     * // Create many SaleItems
     * const saleItem = await prisma.saleItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleItemCreateManyArgs>(args?: SelectSubset<T, SaleItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleItems and returns the data saved in the database.
     * @param {SaleItemCreateManyAndReturnArgs} args - Arguments to create many SaleItems.
     * @example
     * // Create many SaleItems
     * const saleItem = await prisma.saleItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleItems and only return the `id`
     * const saleItemWithIdOnly = await prisma.saleItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleItem.
     * @param {SaleItemDeleteArgs} args - Arguments to delete one SaleItem.
     * @example
     * // Delete one SaleItem
     * const SaleItem = await prisma.saleItem.delete({
     *   where: {
     *     // ... filter to delete one SaleItem
     *   }
     * })
     * 
     */
    delete<T extends SaleItemDeleteArgs>(args: SelectSubset<T, SaleItemDeleteArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleItem.
     * @param {SaleItemUpdateArgs} args - Arguments to update one SaleItem.
     * @example
     * // Update one SaleItem
     * const saleItem = await prisma.saleItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleItemUpdateArgs>(args: SelectSubset<T, SaleItemUpdateArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleItems.
     * @param {SaleItemDeleteManyArgs} args - Arguments to filter SaleItems to delete.
     * @example
     * // Delete a few SaleItems
     * const { count } = await prisma.saleItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleItemDeleteManyArgs>(args?: SelectSubset<T, SaleItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleItems
     * const saleItem = await prisma.saleItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleItemUpdateManyArgs>(args: SelectSubset<T, SaleItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleItems and returns the data updated in the database.
     * @param {SaleItemUpdateManyAndReturnArgs} args - Arguments to update many SaleItems.
     * @example
     * // Update many SaleItems
     * const saleItem = await prisma.saleItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleItems and only return the `id`
     * const saleItemWithIdOnly = await prisma.saleItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleItemUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleItem.
     * @param {SaleItemUpsertArgs} args - Arguments to update or create a SaleItem.
     * @example
     * // Update or create a SaleItem
     * const saleItem = await prisma.saleItem.upsert({
     *   create: {
     *     // ... data to create a SaleItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleItem we want to update
     *   }
     * })
     */
    upsert<T extends SaleItemUpsertArgs>(args: SelectSubset<T, SaleItemUpsertArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemCountArgs} args - Arguments to filter SaleItems to count.
     * @example
     * // Count the number of SaleItems
     * const count = await prisma.saleItem.count({
     *   where: {
     *     // ... the filter for the SaleItems we want to count
     *   }
     * })
    **/
    count<T extends SaleItemCountArgs>(
      args?: Subset<T, SaleItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleItemAggregateArgs>(args: Subset<T, SaleItemAggregateArgs>): Prisma.PrismaPromise<GetSaleItemAggregateType<T>>

    /**
     * Group by SaleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleItemGroupByArgs['orderBy'] }
        : { orderBy?: SaleItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleItem model
   */
  readonly fields: SaleItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventoryItem<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    returnItems<T extends SaleItem$returnItemsArgs<ExtArgs> = {}>(args?: Subset<T, SaleItem$returnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleItem model
   */
  interface SaleItemFieldRefs {
    readonly id: FieldRef<"SaleItem", 'String'>
    readonly saleId: FieldRef<"SaleItem", 'String'>
    readonly productId: FieldRef<"SaleItem", 'String'>
    readonly inventoryItemId: FieldRef<"SaleItem", 'String'>
    readonly quantity: FieldRef<"SaleItem", 'Int'>
    readonly unitPrice: FieldRef<"SaleItem", 'Float'>
    readonly discountAmount: FieldRef<"SaleItem", 'Float'>
    readonly taxAmount: FieldRef<"SaleItem", 'Float'>
    readonly totalPrice: FieldRef<"SaleItem", 'Float'>
    readonly createdAt: FieldRef<"SaleItem", 'DateTime'>
    readonly updatedAt: FieldRef<"SaleItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleItem findUnique
   */
  export type SaleItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem findUniqueOrThrow
   */
  export type SaleItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem findFirst
   */
  export type SaleItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleItems.
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleItems.
     */
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * SaleItem findFirstOrThrow
   */
  export type SaleItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleItems.
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleItems.
     */
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * SaleItem findMany
   */
  export type SaleItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItems to fetch.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleItems.
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * SaleItem create
   */
  export type SaleItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleItem.
     */
    data: XOR<SaleItemCreateInput, SaleItemUncheckedCreateInput>
  }

  /**
   * SaleItem createMany
   */
  export type SaleItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleItems.
     */
    data: SaleItemCreateManyInput | SaleItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleItem createManyAndReturn
   */
  export type SaleItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * The data used to create many SaleItems.
     */
    data: SaleItemCreateManyInput | SaleItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleItem update
   */
  export type SaleItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleItem.
     */
    data: XOR<SaleItemUpdateInput, SaleItemUncheckedUpdateInput>
    /**
     * Choose, which SaleItem to update.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem updateMany
   */
  export type SaleItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleItems.
     */
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyInput>
    /**
     * Filter which SaleItems to update
     */
    where?: SaleItemWhereInput
    /**
     * Limit how many SaleItems to update.
     */
    limit?: number
  }

  /**
   * SaleItem updateManyAndReturn
   */
  export type SaleItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * The data used to update SaleItems.
     */
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyInput>
    /**
     * Filter which SaleItems to update
     */
    where?: SaleItemWhereInput
    /**
     * Limit how many SaleItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleItem upsert
   */
  export type SaleItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleItem to update in case it exists.
     */
    where: SaleItemWhereUniqueInput
    /**
     * In case the SaleItem found by the `where` argument doesn't exist, create a new SaleItem with this data.
     */
    create: XOR<SaleItemCreateInput, SaleItemUncheckedCreateInput>
    /**
     * In case the SaleItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleItemUpdateInput, SaleItemUncheckedUpdateInput>
  }

  /**
   * SaleItem delete
   */
  export type SaleItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter which SaleItem to delete.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem deleteMany
   */
  export type SaleItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleItems to delete
     */
    where?: SaleItemWhereInput
    /**
     * Limit how many SaleItems to delete.
     */
    limit?: number
  }

  /**
   * SaleItem.returnItems
   */
  export type SaleItem$returnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnItem
     */
    select?: ReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnItem
     */
    omit?: ReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnItemInclude<ExtArgs> | null
    where?: ReturnItemWhereInput
    orderBy?: ReturnItemOrderByWithRelationInput | ReturnItemOrderByWithRelationInput[]
    cursor?: ReturnItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnItemScalarFieldEnum | ReturnItemScalarFieldEnum[]
  }

  /**
   * SaleItem without action
   */
  export type SaleItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    amount: number | null
    paymentMethod: $Enums.PaymentMethod | null
    referenceNumber: string | null
    notes: string | null
    processedById: string | null
    processedByName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    amount: number | null
    paymentMethod: $Enums.PaymentMethod | null
    referenceNumber: string | null
    notes: string | null
    processedById: string | null
    processedByName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    saleId: number
    amount: number
    paymentMethod: number
    referenceNumber: number
    notes: number
    processedById: number
    processedByName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    saleId?: true
    amount?: true
    paymentMethod?: true
    referenceNumber?: true
    notes?: true
    processedById?: true
    processedByName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    saleId?: true
    amount?: true
    paymentMethod?: true
    referenceNumber?: true
    notes?: true
    processedById?: true
    processedByName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    saleId?: true
    amount?: true
    paymentMethod?: true
    referenceNumber?: true
    notes?: true
    processedById?: true
    processedByName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    saleId: string
    amount: number
    paymentMethod: $Enums.PaymentMethod
    referenceNumber: string | null
    notes: string | null
    processedById: string
    processedByName: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    referenceNumber?: boolean
    notes?: boolean
    processedById?: boolean
    processedByName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    referenceNumber?: boolean
    notes?: boolean
    processedById?: boolean
    processedByName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    referenceNumber?: boolean
    notes?: boolean
    processedById?: boolean
    processedByName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    saleId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    referenceNumber?: boolean
    notes?: boolean
    processedById?: boolean
    processedByName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saleId" | "amount" | "paymentMethod" | "referenceNumber" | "notes" | "processedById" | "processedByName" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      amount: number
      paymentMethod: $Enums.PaymentMethod
      referenceNumber: string | null
      notes: string | null
      processedById: string
      processedByName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly saleId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly paymentMethod: FieldRef<"Payment", 'PaymentMethod'>
    readonly referenceNumber: FieldRef<"Payment", 'String'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly processedById: FieldRef<"Payment", 'String'>
    readonly processedByName: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Return
   */

  export type AggregateReturn = {
    _count: ReturnCountAggregateOutputType | null
    _avg: ReturnAvgAggregateOutputType | null
    _sum: ReturnSumAggregateOutputType | null
    _min: ReturnMinAggregateOutputType | null
    _max: ReturnMaxAggregateOutputType | null
  }

  export type ReturnAvgAggregateOutputType = {
    subtotal: number | null
    taxAmount: number | null
    totalAmount: number | null
  }

  export type ReturnSumAggregateOutputType = {
    subtotal: number | null
    taxAmount: number | null
    totalAmount: number | null
  }

  export type ReturnMinAggregateOutputType = {
    id: string | null
    returnNumber: string | null
    saleId: string | null
    storeId: string | null
    customerId: string | null
    returnDate: Date | null
    status: $Enums.ReturnStatus | null
    subtotal: number | null
    taxAmount: number | null
    totalAmount: number | null
    refundMethod: $Enums.RefundMethod | null
    refundStatus: $Enums.RefundStatus | null
    reason: string | null
    notes: string | null
    processedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReturnMaxAggregateOutputType = {
    id: string | null
    returnNumber: string | null
    saleId: string | null
    storeId: string | null
    customerId: string | null
    returnDate: Date | null
    status: $Enums.ReturnStatus | null
    subtotal: number | null
    taxAmount: number | null
    totalAmount: number | null
    refundMethod: $Enums.RefundMethod | null
    refundStatus: $Enums.RefundStatus | null
    reason: string | null
    notes: string | null
    processedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReturnCountAggregateOutputType = {
    id: number
    returnNumber: number
    saleId: number
    storeId: number
    customerId: number
    returnDate: number
    status: number
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod: number
    refundStatus: number
    reason: number
    notes: number
    processedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReturnAvgAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type ReturnSumAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type ReturnMinAggregateInputType = {
    id?: true
    returnNumber?: true
    saleId?: true
    storeId?: true
    customerId?: true
    returnDate?: true
    status?: true
    subtotal?: true
    taxAmount?: true
    totalAmount?: true
    refundMethod?: true
    refundStatus?: true
    reason?: true
    notes?: true
    processedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReturnMaxAggregateInputType = {
    id?: true
    returnNumber?: true
    saleId?: true
    storeId?: true
    customerId?: true
    returnDate?: true
    status?: true
    subtotal?: true
    taxAmount?: true
    totalAmount?: true
    refundMethod?: true
    refundStatus?: true
    reason?: true
    notes?: true
    processedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReturnCountAggregateInputType = {
    id?: true
    returnNumber?: true
    saleId?: true
    storeId?: true
    customerId?: true
    returnDate?: true
    status?: true
    subtotal?: true
    taxAmount?: true
    totalAmount?: true
    refundMethod?: true
    refundStatus?: true
    reason?: true
    notes?: true
    processedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReturnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Return to aggregate.
     */
    where?: ReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Returns to fetch.
     */
    orderBy?: ReturnOrderByWithRelationInput | ReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Returns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Returns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Returns
    **/
    _count?: true | ReturnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReturnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReturnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReturnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReturnMaxAggregateInputType
  }

  export type GetReturnAggregateType<T extends ReturnAggregateArgs> = {
        [P in keyof T & keyof AggregateReturn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturn[P]>
      : GetScalarType<T[P], AggregateReturn[P]>
  }




  export type ReturnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnWhereInput
    orderBy?: ReturnOrderByWithAggregationInput | ReturnOrderByWithAggregationInput[]
    by: ReturnScalarFieldEnum[] | ReturnScalarFieldEnum
    having?: ReturnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReturnCountAggregateInputType | true
    _avg?: ReturnAvgAggregateInputType
    _sum?: ReturnSumAggregateInputType
    _min?: ReturnMinAggregateInputType
    _max?: ReturnMaxAggregateInputType
  }

  export type ReturnGroupByOutputType = {
    id: string
    returnNumber: string
    saleId: string | null
    storeId: string
    customerId: string | null
    returnDate: Date
    status: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod: $Enums.RefundMethod | null
    refundStatus: $Enums.RefundStatus
    reason: string | null
    notes: string | null
    processedById: string
    createdAt: Date
    updatedAt: Date
    _count: ReturnCountAggregateOutputType | null
    _avg: ReturnAvgAggregateOutputType | null
    _sum: ReturnSumAggregateOutputType | null
    _min: ReturnMinAggregateOutputType | null
    _max: ReturnMaxAggregateOutputType | null
  }

  type GetReturnGroupByPayload<T extends ReturnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReturnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReturnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReturnGroupByOutputType[P]>
            : GetScalarType<T[P], ReturnGroupByOutputType[P]>
        }
      >
    >


  export type ReturnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnNumber?: boolean
    saleId?: boolean
    storeId?: boolean
    customerId?: boolean
    returnDate?: boolean
    status?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    refundMethod?: boolean
    refundStatus?: boolean
    reason?: boolean
    notes?: boolean
    processedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sale?: boolean | Return$saleArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Return$customerArgs<ExtArgs>
    processedBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Return$itemsArgs<ExtArgs>
    qualityControls?: boolean | Return$qualityControlsArgs<ExtArgs>
    _count?: boolean | ReturnCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["return"]>

  export type ReturnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnNumber?: boolean
    saleId?: boolean
    storeId?: boolean
    customerId?: boolean
    returnDate?: boolean
    status?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    refundMethod?: boolean
    refundStatus?: boolean
    reason?: boolean
    notes?: boolean
    processedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sale?: boolean | Return$saleArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Return$customerArgs<ExtArgs>
    processedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["return"]>

  export type ReturnSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnNumber?: boolean
    saleId?: boolean
    storeId?: boolean
    customerId?: boolean
    returnDate?: boolean
    status?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    refundMethod?: boolean
    refundStatus?: boolean
    reason?: boolean
    notes?: boolean
    processedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sale?: boolean | Return$saleArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Return$customerArgs<ExtArgs>
    processedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["return"]>

  export type ReturnSelectScalar = {
    id?: boolean
    returnNumber?: boolean
    saleId?: boolean
    storeId?: boolean
    customerId?: boolean
    returnDate?: boolean
    status?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    refundMethod?: boolean
    refundStatus?: boolean
    reason?: boolean
    notes?: boolean
    processedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReturnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "returnNumber" | "saleId" | "storeId" | "customerId" | "returnDate" | "status" | "subtotal" | "taxAmount" | "totalAmount" | "refundMethod" | "refundStatus" | "reason" | "notes" | "processedById" | "createdAt" | "updatedAt", ExtArgs["result"]["return"]>
  export type ReturnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | Return$saleArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Return$customerArgs<ExtArgs>
    processedBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Return$itemsArgs<ExtArgs>
    qualityControls?: boolean | Return$qualityControlsArgs<ExtArgs>
    _count?: boolean | ReturnCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReturnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | Return$saleArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Return$customerArgs<ExtArgs>
    processedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReturnIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | Return$saleArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Return$customerArgs<ExtArgs>
    processedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReturnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Return"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs> | null
      store: Prisma.$StorePayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      processedBy: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$ReturnItemPayload<ExtArgs>[]
      qualityControls: Prisma.$QualityControlPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      returnNumber: string
      saleId: string | null
      storeId: string
      customerId: string | null
      returnDate: Date
      status: $Enums.ReturnStatus
      subtotal: number
      taxAmount: number
      totalAmount: number
      refundMethod: $Enums.RefundMethod | null
      refundStatus: $Enums.RefundStatus
      reason: string | null
      notes: string | null
      processedById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["return"]>
    composites: {}
  }

  type ReturnGetPayload<S extends boolean | null | undefined | ReturnDefaultArgs> = $Result.GetResult<Prisma.$ReturnPayload, S>

  type ReturnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReturnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReturnCountAggregateInputType | true
    }

  export interface ReturnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Return'], meta: { name: 'Return' } }
    /**
     * Find zero or one Return that matches the filter.
     * @param {ReturnFindUniqueArgs} args - Arguments to find a Return
     * @example
     * // Get one Return
     * const return = await prisma.return.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReturnFindUniqueArgs>(args: SelectSubset<T, ReturnFindUniqueArgs<ExtArgs>>): Prisma__ReturnClient<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Return that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReturnFindUniqueOrThrowArgs} args - Arguments to find a Return
     * @example
     * // Get one Return
     * const return = await prisma.return.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReturnFindUniqueOrThrowArgs>(args: SelectSubset<T, ReturnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReturnClient<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Return that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnFindFirstArgs} args - Arguments to find a Return
     * @example
     * // Get one Return
     * const return = await prisma.return.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReturnFindFirstArgs>(args?: SelectSubset<T, ReturnFindFirstArgs<ExtArgs>>): Prisma__ReturnClient<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Return that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnFindFirstOrThrowArgs} args - Arguments to find a Return
     * @example
     * // Get one Return
     * const return = await prisma.return.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReturnFindFirstOrThrowArgs>(args?: SelectSubset<T, ReturnFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReturnClient<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Returns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Returns
     * const returns = await prisma.return.findMany()
     * 
     * // Get first 10 Returns
     * const returns = await prisma.return.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const returnWithIdOnly = await prisma.return.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReturnFindManyArgs>(args?: SelectSubset<T, ReturnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Return.
     * @param {ReturnCreateArgs} args - Arguments to create a Return.
     * @example
     * // Create one Return
     * const Return = await prisma.return.create({
     *   data: {
     *     // ... data to create a Return
     *   }
     * })
     * 
     */
    create<T extends ReturnCreateArgs>(args: SelectSubset<T, ReturnCreateArgs<ExtArgs>>): Prisma__ReturnClient<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Returns.
     * @param {ReturnCreateManyArgs} args - Arguments to create many Returns.
     * @example
     * // Create many Returns
     * const return = await prisma.return.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReturnCreateManyArgs>(args?: SelectSubset<T, ReturnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Returns and returns the data saved in the database.
     * @param {ReturnCreateManyAndReturnArgs} args - Arguments to create many Returns.
     * @example
     * // Create many Returns
     * const return = await prisma.return.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Returns and only return the `id`
     * const returnWithIdOnly = await prisma.return.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReturnCreateManyAndReturnArgs>(args?: SelectSubset<T, ReturnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Return.
     * @param {ReturnDeleteArgs} args - Arguments to delete one Return.
     * @example
     * // Delete one Return
     * const Return = await prisma.return.delete({
     *   where: {
     *     // ... filter to delete one Return
     *   }
     * })
     * 
     */
    delete<T extends ReturnDeleteArgs>(args: SelectSubset<T, ReturnDeleteArgs<ExtArgs>>): Prisma__ReturnClient<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Return.
     * @param {ReturnUpdateArgs} args - Arguments to update one Return.
     * @example
     * // Update one Return
     * const return = await prisma.return.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReturnUpdateArgs>(args: SelectSubset<T, ReturnUpdateArgs<ExtArgs>>): Prisma__ReturnClient<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Returns.
     * @param {ReturnDeleteManyArgs} args - Arguments to filter Returns to delete.
     * @example
     * // Delete a few Returns
     * const { count } = await prisma.return.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReturnDeleteManyArgs>(args?: SelectSubset<T, ReturnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Returns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Returns
     * const return = await prisma.return.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReturnUpdateManyArgs>(args: SelectSubset<T, ReturnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Returns and returns the data updated in the database.
     * @param {ReturnUpdateManyAndReturnArgs} args - Arguments to update many Returns.
     * @example
     * // Update many Returns
     * const return = await prisma.return.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Returns and only return the `id`
     * const returnWithIdOnly = await prisma.return.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReturnUpdateManyAndReturnArgs>(args: SelectSubset<T, ReturnUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Return.
     * @param {ReturnUpsertArgs} args - Arguments to update or create a Return.
     * @example
     * // Update or create a Return
     * const return = await prisma.return.upsert({
     *   create: {
     *     // ... data to create a Return
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Return we want to update
     *   }
     * })
     */
    upsert<T extends ReturnUpsertArgs>(args: SelectSubset<T, ReturnUpsertArgs<ExtArgs>>): Prisma__ReturnClient<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Returns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnCountArgs} args - Arguments to filter Returns to count.
     * @example
     * // Count the number of Returns
     * const count = await prisma.return.count({
     *   where: {
     *     // ... the filter for the Returns we want to count
     *   }
     * })
    **/
    count<T extends ReturnCountArgs>(
      args?: Subset<T, ReturnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReturnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Return.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReturnAggregateArgs>(args: Subset<T, ReturnAggregateArgs>): Prisma.PrismaPromise<GetReturnAggregateType<T>>

    /**
     * Group by Return.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReturnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReturnGroupByArgs['orderBy'] }
        : { orderBy?: ReturnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReturnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Return model
   */
  readonly fields: ReturnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Return.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReturnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends Return$saleArgs<ExtArgs> = {}>(args?: Subset<T, Return$saleArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends Return$customerArgs<ExtArgs> = {}>(args?: Subset<T, Return$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    processedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Return$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Return$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    qualityControls<T extends Return$qualityControlsArgs<ExtArgs> = {}>(args?: Subset<T, Return$qualityControlsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Return model
   */
  interface ReturnFieldRefs {
    readonly id: FieldRef<"Return", 'String'>
    readonly returnNumber: FieldRef<"Return", 'String'>
    readonly saleId: FieldRef<"Return", 'String'>
    readonly storeId: FieldRef<"Return", 'String'>
    readonly customerId: FieldRef<"Return", 'String'>
    readonly returnDate: FieldRef<"Return", 'DateTime'>
    readonly status: FieldRef<"Return", 'ReturnStatus'>
    readonly subtotal: FieldRef<"Return", 'Float'>
    readonly taxAmount: FieldRef<"Return", 'Float'>
    readonly totalAmount: FieldRef<"Return", 'Float'>
    readonly refundMethod: FieldRef<"Return", 'RefundMethod'>
    readonly refundStatus: FieldRef<"Return", 'RefundStatus'>
    readonly reason: FieldRef<"Return", 'String'>
    readonly notes: FieldRef<"Return", 'String'>
    readonly processedById: FieldRef<"Return", 'String'>
    readonly createdAt: FieldRef<"Return", 'DateTime'>
    readonly updatedAt: FieldRef<"Return", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Return findUnique
   */
  export type ReturnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnInclude<ExtArgs> | null
    /**
     * Filter, which Return to fetch.
     */
    where: ReturnWhereUniqueInput
  }

  /**
   * Return findUniqueOrThrow
   */
  export type ReturnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnInclude<ExtArgs> | null
    /**
     * Filter, which Return to fetch.
     */
    where: ReturnWhereUniqueInput
  }

  /**
   * Return findFirst
   */
  export type ReturnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnInclude<ExtArgs> | null
    /**
     * Filter, which Return to fetch.
     */
    where?: ReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Returns to fetch.
     */
    orderBy?: ReturnOrderByWithRelationInput | ReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Returns.
     */
    cursor?: ReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Returns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Returns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Returns.
     */
    distinct?: ReturnScalarFieldEnum | ReturnScalarFieldEnum[]
  }

  /**
   * Return findFirstOrThrow
   */
  export type ReturnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnInclude<ExtArgs> | null
    /**
     * Filter, which Return to fetch.
     */
    where?: ReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Returns to fetch.
     */
    orderBy?: ReturnOrderByWithRelationInput | ReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Returns.
     */
    cursor?: ReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Returns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Returns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Returns.
     */
    distinct?: ReturnScalarFieldEnum | ReturnScalarFieldEnum[]
  }

  /**
   * Return findMany
   */
  export type ReturnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnInclude<ExtArgs> | null
    /**
     * Filter, which Returns to fetch.
     */
    where?: ReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Returns to fetch.
     */
    orderBy?: ReturnOrderByWithRelationInput | ReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Returns.
     */
    cursor?: ReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Returns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Returns.
     */
    skip?: number
    distinct?: ReturnScalarFieldEnum | ReturnScalarFieldEnum[]
  }

  /**
   * Return create
   */
  export type ReturnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnInclude<ExtArgs> | null
    /**
     * The data needed to create a Return.
     */
    data: XOR<ReturnCreateInput, ReturnUncheckedCreateInput>
  }

  /**
   * Return createMany
   */
  export type ReturnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Returns.
     */
    data: ReturnCreateManyInput | ReturnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Return createManyAndReturn
   */
  export type ReturnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * The data used to create many Returns.
     */
    data: ReturnCreateManyInput | ReturnCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Return update
   */
  export type ReturnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnInclude<ExtArgs> | null
    /**
     * The data needed to update a Return.
     */
    data: XOR<ReturnUpdateInput, ReturnUncheckedUpdateInput>
    /**
     * Choose, which Return to update.
     */
    where: ReturnWhereUniqueInput
  }

  /**
   * Return updateMany
   */
  export type ReturnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Returns.
     */
    data: XOR<ReturnUpdateManyMutationInput, ReturnUncheckedUpdateManyInput>
    /**
     * Filter which Returns to update
     */
    where?: ReturnWhereInput
    /**
     * Limit how many Returns to update.
     */
    limit?: number
  }

  /**
   * Return updateManyAndReturn
   */
  export type ReturnUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * The data used to update Returns.
     */
    data: XOR<ReturnUpdateManyMutationInput, ReturnUncheckedUpdateManyInput>
    /**
     * Filter which Returns to update
     */
    where?: ReturnWhereInput
    /**
     * Limit how many Returns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Return upsert
   */
  export type ReturnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnInclude<ExtArgs> | null
    /**
     * The filter to search for the Return to update in case it exists.
     */
    where: ReturnWhereUniqueInput
    /**
     * In case the Return found by the `where` argument doesn't exist, create a new Return with this data.
     */
    create: XOR<ReturnCreateInput, ReturnUncheckedCreateInput>
    /**
     * In case the Return was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReturnUpdateInput, ReturnUncheckedUpdateInput>
  }

  /**
   * Return delete
   */
  export type ReturnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnInclude<ExtArgs> | null
    /**
     * Filter which Return to delete.
     */
    where: ReturnWhereUniqueInput
  }

  /**
   * Return deleteMany
   */
  export type ReturnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Returns to delete
     */
    where?: ReturnWhereInput
    /**
     * Limit how many Returns to delete.
     */
    limit?: number
  }

  /**
   * Return.sale
   */
  export type Return$saleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
  }

  /**
   * Return.customer
   */
  export type Return$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Return.items
   */
  export type Return$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnItem
     */
    select?: ReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnItem
     */
    omit?: ReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnItemInclude<ExtArgs> | null
    where?: ReturnItemWhereInput
    orderBy?: ReturnItemOrderByWithRelationInput | ReturnItemOrderByWithRelationInput[]
    cursor?: ReturnItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnItemScalarFieldEnum | ReturnItemScalarFieldEnum[]
  }

  /**
   * Return.qualityControls
   */
  export type Return$qualityControlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlInclude<ExtArgs> | null
    where?: QualityControlWhereInput
    orderBy?: QualityControlOrderByWithRelationInput | QualityControlOrderByWithRelationInput[]
    cursor?: QualityControlWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QualityControlScalarFieldEnum | QualityControlScalarFieldEnum[]
  }

  /**
   * Return without action
   */
  export type ReturnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnInclude<ExtArgs> | null
  }


  /**
   * Model ReturnItem
   */

  export type AggregateReturnItem = {
    _count: ReturnItemCountAggregateOutputType | null
    _avg: ReturnItemAvgAggregateOutputType | null
    _sum: ReturnItemSumAggregateOutputType | null
    _min: ReturnItemMinAggregateOutputType | null
    _max: ReturnItemMaxAggregateOutputType | null
  }

  export type ReturnItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type ReturnItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
  }

  export type ReturnItemMinAggregateOutputType = {
    id: string | null
    returnId: string | null
    productId: string | null
    saleItemId: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    reason: $Enums.ReturnReason | null
    condition: $Enums.ItemCondition | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReturnItemMaxAggregateOutputType = {
    id: string | null
    returnId: string | null
    productId: string | null
    saleItemId: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    reason: $Enums.ReturnReason | null
    condition: $Enums.ItemCondition | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReturnItemCountAggregateOutputType = {
    id: number
    returnId: number
    productId: number
    saleItemId: number
    quantity: number
    unitPrice: number
    totalPrice: number
    reason: number
    condition: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReturnItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type ReturnItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type ReturnItemMinAggregateInputType = {
    id?: true
    returnId?: true
    productId?: true
    saleItemId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    reason?: true
    condition?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReturnItemMaxAggregateInputType = {
    id?: true
    returnId?: true
    productId?: true
    saleItemId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    reason?: true
    condition?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReturnItemCountAggregateInputType = {
    id?: true
    returnId?: true
    productId?: true
    saleItemId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    reason?: true
    condition?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReturnItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnItem to aggregate.
     */
    where?: ReturnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnItems to fetch.
     */
    orderBy?: ReturnItemOrderByWithRelationInput | ReturnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReturnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReturnItems
    **/
    _count?: true | ReturnItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReturnItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReturnItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReturnItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReturnItemMaxAggregateInputType
  }

  export type GetReturnItemAggregateType<T extends ReturnItemAggregateArgs> = {
        [P in keyof T & keyof AggregateReturnItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturnItem[P]>
      : GetScalarType<T[P], AggregateReturnItem[P]>
  }




  export type ReturnItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnItemWhereInput
    orderBy?: ReturnItemOrderByWithAggregationInput | ReturnItemOrderByWithAggregationInput[]
    by: ReturnItemScalarFieldEnum[] | ReturnItemScalarFieldEnum
    having?: ReturnItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReturnItemCountAggregateInputType | true
    _avg?: ReturnItemAvgAggregateInputType
    _sum?: ReturnItemSumAggregateInputType
    _min?: ReturnItemMinAggregateInputType
    _max?: ReturnItemMaxAggregateInputType
  }

  export type ReturnItemGroupByOutputType = {
    id: string
    returnId: string
    productId: string
    saleItemId: string | null
    quantity: number
    unitPrice: number
    totalPrice: number
    reason: $Enums.ReturnReason
    condition: $Enums.ItemCondition
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReturnItemCountAggregateOutputType | null
    _avg: ReturnItemAvgAggregateOutputType | null
    _sum: ReturnItemSumAggregateOutputType | null
    _min: ReturnItemMinAggregateOutputType | null
    _max: ReturnItemMaxAggregateOutputType | null
  }

  type GetReturnItemGroupByPayload<T extends ReturnItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReturnItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReturnItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReturnItemGroupByOutputType[P]>
            : GetScalarType<T[P], ReturnItemGroupByOutputType[P]>
        }
      >
    >


  export type ReturnItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnId?: boolean
    productId?: boolean
    saleItemId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    reason?: boolean
    condition?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    return?: boolean | ReturnDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    saleItem?: boolean | ReturnItem$saleItemArgs<ExtArgs>
  }, ExtArgs["result"]["returnItem"]>

  export type ReturnItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnId?: boolean
    productId?: boolean
    saleItemId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    reason?: boolean
    condition?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    return?: boolean | ReturnDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    saleItem?: boolean | ReturnItem$saleItemArgs<ExtArgs>
  }, ExtArgs["result"]["returnItem"]>

  export type ReturnItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnId?: boolean
    productId?: boolean
    saleItemId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    reason?: boolean
    condition?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    return?: boolean | ReturnDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    saleItem?: boolean | ReturnItem$saleItemArgs<ExtArgs>
  }, ExtArgs["result"]["returnItem"]>

  export type ReturnItemSelectScalar = {
    id?: boolean
    returnId?: boolean
    productId?: boolean
    saleItemId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    reason?: boolean
    condition?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReturnItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "returnId" | "productId" | "saleItemId" | "quantity" | "unitPrice" | "totalPrice" | "reason" | "condition" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["returnItem"]>
  export type ReturnItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    return?: boolean | ReturnDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    saleItem?: boolean | ReturnItem$saleItemArgs<ExtArgs>
  }
  export type ReturnItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    return?: boolean | ReturnDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    saleItem?: boolean | ReturnItem$saleItemArgs<ExtArgs>
  }
  export type ReturnItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    return?: boolean | ReturnDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    saleItem?: boolean | ReturnItem$saleItemArgs<ExtArgs>
  }

  export type $ReturnItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReturnItem"
    objects: {
      return: Prisma.$ReturnPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      saleItem: Prisma.$SaleItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      returnId: string
      productId: string
      saleItemId: string | null
      quantity: number
      unitPrice: number
      totalPrice: number
      reason: $Enums.ReturnReason
      condition: $Enums.ItemCondition
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["returnItem"]>
    composites: {}
  }

  type ReturnItemGetPayload<S extends boolean | null | undefined | ReturnItemDefaultArgs> = $Result.GetResult<Prisma.$ReturnItemPayload, S>

  type ReturnItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReturnItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReturnItemCountAggregateInputType | true
    }

  export interface ReturnItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReturnItem'], meta: { name: 'ReturnItem' } }
    /**
     * Find zero or one ReturnItem that matches the filter.
     * @param {ReturnItemFindUniqueArgs} args - Arguments to find a ReturnItem
     * @example
     * // Get one ReturnItem
     * const returnItem = await prisma.returnItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReturnItemFindUniqueArgs>(args: SelectSubset<T, ReturnItemFindUniqueArgs<ExtArgs>>): Prisma__ReturnItemClient<$Result.GetResult<Prisma.$ReturnItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReturnItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReturnItemFindUniqueOrThrowArgs} args - Arguments to find a ReturnItem
     * @example
     * // Get one ReturnItem
     * const returnItem = await prisma.returnItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReturnItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ReturnItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReturnItemClient<$Result.GetResult<Prisma.$ReturnItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReturnItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnItemFindFirstArgs} args - Arguments to find a ReturnItem
     * @example
     * // Get one ReturnItem
     * const returnItem = await prisma.returnItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReturnItemFindFirstArgs>(args?: SelectSubset<T, ReturnItemFindFirstArgs<ExtArgs>>): Prisma__ReturnItemClient<$Result.GetResult<Prisma.$ReturnItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReturnItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnItemFindFirstOrThrowArgs} args - Arguments to find a ReturnItem
     * @example
     * // Get one ReturnItem
     * const returnItem = await prisma.returnItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReturnItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ReturnItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReturnItemClient<$Result.GetResult<Prisma.$ReturnItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReturnItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReturnItems
     * const returnItems = await prisma.returnItem.findMany()
     * 
     * // Get first 10 ReturnItems
     * const returnItems = await prisma.returnItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const returnItemWithIdOnly = await prisma.returnItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReturnItemFindManyArgs>(args?: SelectSubset<T, ReturnItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReturnItem.
     * @param {ReturnItemCreateArgs} args - Arguments to create a ReturnItem.
     * @example
     * // Create one ReturnItem
     * const ReturnItem = await prisma.returnItem.create({
     *   data: {
     *     // ... data to create a ReturnItem
     *   }
     * })
     * 
     */
    create<T extends ReturnItemCreateArgs>(args: SelectSubset<T, ReturnItemCreateArgs<ExtArgs>>): Prisma__ReturnItemClient<$Result.GetResult<Prisma.$ReturnItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReturnItems.
     * @param {ReturnItemCreateManyArgs} args - Arguments to create many ReturnItems.
     * @example
     * // Create many ReturnItems
     * const returnItem = await prisma.returnItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReturnItemCreateManyArgs>(args?: SelectSubset<T, ReturnItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReturnItems and returns the data saved in the database.
     * @param {ReturnItemCreateManyAndReturnArgs} args - Arguments to create many ReturnItems.
     * @example
     * // Create many ReturnItems
     * const returnItem = await prisma.returnItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReturnItems and only return the `id`
     * const returnItemWithIdOnly = await prisma.returnItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReturnItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ReturnItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReturnItem.
     * @param {ReturnItemDeleteArgs} args - Arguments to delete one ReturnItem.
     * @example
     * // Delete one ReturnItem
     * const ReturnItem = await prisma.returnItem.delete({
     *   where: {
     *     // ... filter to delete one ReturnItem
     *   }
     * })
     * 
     */
    delete<T extends ReturnItemDeleteArgs>(args: SelectSubset<T, ReturnItemDeleteArgs<ExtArgs>>): Prisma__ReturnItemClient<$Result.GetResult<Prisma.$ReturnItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReturnItem.
     * @param {ReturnItemUpdateArgs} args - Arguments to update one ReturnItem.
     * @example
     * // Update one ReturnItem
     * const returnItem = await prisma.returnItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReturnItemUpdateArgs>(args: SelectSubset<T, ReturnItemUpdateArgs<ExtArgs>>): Prisma__ReturnItemClient<$Result.GetResult<Prisma.$ReturnItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReturnItems.
     * @param {ReturnItemDeleteManyArgs} args - Arguments to filter ReturnItems to delete.
     * @example
     * // Delete a few ReturnItems
     * const { count } = await prisma.returnItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReturnItemDeleteManyArgs>(args?: SelectSubset<T, ReturnItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReturnItems
     * const returnItem = await prisma.returnItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReturnItemUpdateManyArgs>(args: SelectSubset<T, ReturnItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnItems and returns the data updated in the database.
     * @param {ReturnItemUpdateManyAndReturnArgs} args - Arguments to update many ReturnItems.
     * @example
     * // Update many ReturnItems
     * const returnItem = await prisma.returnItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReturnItems and only return the `id`
     * const returnItemWithIdOnly = await prisma.returnItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReturnItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ReturnItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReturnItem.
     * @param {ReturnItemUpsertArgs} args - Arguments to update or create a ReturnItem.
     * @example
     * // Update or create a ReturnItem
     * const returnItem = await prisma.returnItem.upsert({
     *   create: {
     *     // ... data to create a ReturnItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReturnItem we want to update
     *   }
     * })
     */
    upsert<T extends ReturnItemUpsertArgs>(args: SelectSubset<T, ReturnItemUpsertArgs<ExtArgs>>): Prisma__ReturnItemClient<$Result.GetResult<Prisma.$ReturnItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReturnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnItemCountArgs} args - Arguments to filter ReturnItems to count.
     * @example
     * // Count the number of ReturnItems
     * const count = await prisma.returnItem.count({
     *   where: {
     *     // ... the filter for the ReturnItems we want to count
     *   }
     * })
    **/
    count<T extends ReturnItemCountArgs>(
      args?: Subset<T, ReturnItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReturnItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReturnItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReturnItemAggregateArgs>(args: Subset<T, ReturnItemAggregateArgs>): Prisma.PrismaPromise<GetReturnItemAggregateType<T>>

    /**
     * Group by ReturnItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReturnItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReturnItemGroupByArgs['orderBy'] }
        : { orderBy?: ReturnItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReturnItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturnItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReturnItem model
   */
  readonly fields: ReturnItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReturnItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReturnItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    return<T extends ReturnDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReturnDefaultArgs<ExtArgs>>): Prisma__ReturnClient<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    saleItem<T extends ReturnItem$saleItemArgs<ExtArgs> = {}>(args?: Subset<T, ReturnItem$saleItemArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReturnItem model
   */
  interface ReturnItemFieldRefs {
    readonly id: FieldRef<"ReturnItem", 'String'>
    readonly returnId: FieldRef<"ReturnItem", 'String'>
    readonly productId: FieldRef<"ReturnItem", 'String'>
    readonly saleItemId: FieldRef<"ReturnItem", 'String'>
    readonly quantity: FieldRef<"ReturnItem", 'Int'>
    readonly unitPrice: FieldRef<"ReturnItem", 'Float'>
    readonly totalPrice: FieldRef<"ReturnItem", 'Float'>
    readonly reason: FieldRef<"ReturnItem", 'ReturnReason'>
    readonly condition: FieldRef<"ReturnItem", 'ItemCondition'>
    readonly notes: FieldRef<"ReturnItem", 'String'>
    readonly createdAt: FieldRef<"ReturnItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ReturnItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReturnItem findUnique
   */
  export type ReturnItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnItem
     */
    select?: ReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnItem
     */
    omit?: ReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnItemInclude<ExtArgs> | null
    /**
     * Filter, which ReturnItem to fetch.
     */
    where: ReturnItemWhereUniqueInput
  }

  /**
   * ReturnItem findUniqueOrThrow
   */
  export type ReturnItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnItem
     */
    select?: ReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnItem
     */
    omit?: ReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnItemInclude<ExtArgs> | null
    /**
     * Filter, which ReturnItem to fetch.
     */
    where: ReturnItemWhereUniqueInput
  }

  /**
   * ReturnItem findFirst
   */
  export type ReturnItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnItem
     */
    select?: ReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnItem
     */
    omit?: ReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnItemInclude<ExtArgs> | null
    /**
     * Filter, which ReturnItem to fetch.
     */
    where?: ReturnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnItems to fetch.
     */
    orderBy?: ReturnItemOrderByWithRelationInput | ReturnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnItems.
     */
    cursor?: ReturnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnItems.
     */
    distinct?: ReturnItemScalarFieldEnum | ReturnItemScalarFieldEnum[]
  }

  /**
   * ReturnItem findFirstOrThrow
   */
  export type ReturnItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnItem
     */
    select?: ReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnItem
     */
    omit?: ReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnItemInclude<ExtArgs> | null
    /**
     * Filter, which ReturnItem to fetch.
     */
    where?: ReturnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnItems to fetch.
     */
    orderBy?: ReturnItemOrderByWithRelationInput | ReturnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnItems.
     */
    cursor?: ReturnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnItems.
     */
    distinct?: ReturnItemScalarFieldEnum | ReturnItemScalarFieldEnum[]
  }

  /**
   * ReturnItem findMany
   */
  export type ReturnItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnItem
     */
    select?: ReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnItem
     */
    omit?: ReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnItemInclude<ExtArgs> | null
    /**
     * Filter, which ReturnItems to fetch.
     */
    where?: ReturnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnItems to fetch.
     */
    orderBy?: ReturnItemOrderByWithRelationInput | ReturnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReturnItems.
     */
    cursor?: ReturnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnItems.
     */
    skip?: number
    distinct?: ReturnItemScalarFieldEnum | ReturnItemScalarFieldEnum[]
  }

  /**
   * ReturnItem create
   */
  export type ReturnItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnItem
     */
    select?: ReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnItem
     */
    omit?: ReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ReturnItem.
     */
    data: XOR<ReturnItemCreateInput, ReturnItemUncheckedCreateInput>
  }

  /**
   * ReturnItem createMany
   */
  export type ReturnItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReturnItems.
     */
    data: ReturnItemCreateManyInput | ReturnItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReturnItem createManyAndReturn
   */
  export type ReturnItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnItem
     */
    select?: ReturnItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnItem
     */
    omit?: ReturnItemOmit<ExtArgs> | null
    /**
     * The data used to create many ReturnItems.
     */
    data: ReturnItemCreateManyInput | ReturnItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReturnItem update
   */
  export type ReturnItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnItem
     */
    select?: ReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnItem
     */
    omit?: ReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ReturnItem.
     */
    data: XOR<ReturnItemUpdateInput, ReturnItemUncheckedUpdateInput>
    /**
     * Choose, which ReturnItem to update.
     */
    where: ReturnItemWhereUniqueInput
  }

  /**
   * ReturnItem updateMany
   */
  export type ReturnItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReturnItems.
     */
    data: XOR<ReturnItemUpdateManyMutationInput, ReturnItemUncheckedUpdateManyInput>
    /**
     * Filter which ReturnItems to update
     */
    where?: ReturnItemWhereInput
    /**
     * Limit how many ReturnItems to update.
     */
    limit?: number
  }

  /**
   * ReturnItem updateManyAndReturn
   */
  export type ReturnItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnItem
     */
    select?: ReturnItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnItem
     */
    omit?: ReturnItemOmit<ExtArgs> | null
    /**
     * The data used to update ReturnItems.
     */
    data: XOR<ReturnItemUpdateManyMutationInput, ReturnItemUncheckedUpdateManyInput>
    /**
     * Filter which ReturnItems to update
     */
    where?: ReturnItemWhereInput
    /**
     * Limit how many ReturnItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReturnItem upsert
   */
  export type ReturnItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnItem
     */
    select?: ReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnItem
     */
    omit?: ReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ReturnItem to update in case it exists.
     */
    where: ReturnItemWhereUniqueInput
    /**
     * In case the ReturnItem found by the `where` argument doesn't exist, create a new ReturnItem with this data.
     */
    create: XOR<ReturnItemCreateInput, ReturnItemUncheckedCreateInput>
    /**
     * In case the ReturnItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReturnItemUpdateInput, ReturnItemUncheckedUpdateInput>
  }

  /**
   * ReturnItem delete
   */
  export type ReturnItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnItem
     */
    select?: ReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnItem
     */
    omit?: ReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnItemInclude<ExtArgs> | null
    /**
     * Filter which ReturnItem to delete.
     */
    where: ReturnItemWhereUniqueInput
  }

  /**
   * ReturnItem deleteMany
   */
  export type ReturnItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnItems to delete
     */
    where?: ReturnItemWhereInput
    /**
     * Limit how many ReturnItems to delete.
     */
    limit?: number
  }

  /**
   * ReturnItem.saleItem
   */
  export type ReturnItem$saleItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    where?: SaleItemWhereInput
  }

  /**
   * ReturnItem without action
   */
  export type ReturnItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnItem
     */
    select?: ReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnItem
     */
    omit?: ReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnItemInclude<ExtArgs> | null
  }


  /**
   * Model QualityControl
   */

  export type AggregateQualityControl = {
    _count: QualityControlCountAggregateOutputType | null
    _min: QualityControlMinAggregateOutputType | null
    _max: QualityControlMaxAggregateOutputType | null
  }

  export type QualityControlMinAggregateOutputType = {
    id: string | null
    referenceNumber: string | null
    type: $Enums.QCType | null
    status: $Enums.QCStatus | null
    warehouseId: string | null
    purchaseOrderId: string | null
    returnId: string | null
    inspectionDate: Date | null
    completedDate: Date | null
    inspectedById: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QualityControlMaxAggregateOutputType = {
    id: string | null
    referenceNumber: string | null
    type: $Enums.QCType | null
    status: $Enums.QCStatus | null
    warehouseId: string | null
    purchaseOrderId: string | null
    returnId: string | null
    inspectionDate: Date | null
    completedDate: Date | null
    inspectedById: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QualityControlCountAggregateOutputType = {
    id: number
    referenceNumber: number
    type: number
    status: number
    warehouseId: number
    purchaseOrderId: number
    returnId: number
    inspectionDate: number
    completedDate: number
    inspectedById: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QualityControlMinAggregateInputType = {
    id?: true
    referenceNumber?: true
    type?: true
    status?: true
    warehouseId?: true
    purchaseOrderId?: true
    returnId?: true
    inspectionDate?: true
    completedDate?: true
    inspectedById?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QualityControlMaxAggregateInputType = {
    id?: true
    referenceNumber?: true
    type?: true
    status?: true
    warehouseId?: true
    purchaseOrderId?: true
    returnId?: true
    inspectionDate?: true
    completedDate?: true
    inspectedById?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QualityControlCountAggregateInputType = {
    id?: true
    referenceNumber?: true
    type?: true
    status?: true
    warehouseId?: true
    purchaseOrderId?: true
    returnId?: true
    inspectionDate?: true
    completedDate?: true
    inspectedById?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QualityControlAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QualityControl to aggregate.
     */
    where?: QualityControlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityControls to fetch.
     */
    orderBy?: QualityControlOrderByWithRelationInput | QualityControlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QualityControlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityControls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityControls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QualityControls
    **/
    _count?: true | QualityControlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QualityControlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QualityControlMaxAggregateInputType
  }

  export type GetQualityControlAggregateType<T extends QualityControlAggregateArgs> = {
        [P in keyof T & keyof AggregateQualityControl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQualityControl[P]>
      : GetScalarType<T[P], AggregateQualityControl[P]>
  }




  export type QualityControlGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QualityControlWhereInput
    orderBy?: QualityControlOrderByWithAggregationInput | QualityControlOrderByWithAggregationInput[]
    by: QualityControlScalarFieldEnum[] | QualityControlScalarFieldEnum
    having?: QualityControlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QualityControlCountAggregateInputType | true
    _min?: QualityControlMinAggregateInputType
    _max?: QualityControlMaxAggregateInputType
  }

  export type QualityControlGroupByOutputType = {
    id: string
    referenceNumber: string
    type: $Enums.QCType
    status: $Enums.QCStatus
    warehouseId: string
    purchaseOrderId: string | null
    returnId: string | null
    inspectionDate: Date
    completedDate: Date | null
    inspectedById: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: QualityControlCountAggregateOutputType | null
    _min: QualityControlMinAggregateOutputType | null
    _max: QualityControlMaxAggregateOutputType | null
  }

  type GetQualityControlGroupByPayload<T extends QualityControlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QualityControlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QualityControlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QualityControlGroupByOutputType[P]>
            : GetScalarType<T[P], QualityControlGroupByOutputType[P]>
        }
      >
    >


  export type QualityControlSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    type?: boolean
    status?: boolean
    warehouseId?: boolean
    purchaseOrderId?: boolean
    returnId?: boolean
    inspectionDate?: boolean
    completedDate?: boolean
    inspectedById?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | QualityControl$purchaseOrderArgs<ExtArgs>
    return?: boolean | QualityControl$returnArgs<ExtArgs>
    inspectedBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | QualityControl$itemsArgs<ExtArgs>
    _count?: boolean | QualityControlCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qualityControl"]>

  export type QualityControlSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    type?: boolean
    status?: boolean
    warehouseId?: boolean
    purchaseOrderId?: boolean
    returnId?: boolean
    inspectionDate?: boolean
    completedDate?: boolean
    inspectedById?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | QualityControl$purchaseOrderArgs<ExtArgs>
    return?: boolean | QualityControl$returnArgs<ExtArgs>
    inspectedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qualityControl"]>

  export type QualityControlSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    type?: boolean
    status?: boolean
    warehouseId?: boolean
    purchaseOrderId?: boolean
    returnId?: boolean
    inspectionDate?: boolean
    completedDate?: boolean
    inspectedById?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | QualityControl$purchaseOrderArgs<ExtArgs>
    return?: boolean | QualityControl$returnArgs<ExtArgs>
    inspectedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qualityControl"]>

  export type QualityControlSelectScalar = {
    id?: boolean
    referenceNumber?: boolean
    type?: boolean
    status?: boolean
    warehouseId?: boolean
    purchaseOrderId?: boolean
    returnId?: boolean
    inspectionDate?: boolean
    completedDate?: boolean
    inspectedById?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QualityControlOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referenceNumber" | "type" | "status" | "warehouseId" | "purchaseOrderId" | "returnId" | "inspectionDate" | "completedDate" | "inspectedById" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["qualityControl"]>
  export type QualityControlInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | QualityControl$purchaseOrderArgs<ExtArgs>
    return?: boolean | QualityControl$returnArgs<ExtArgs>
    inspectedBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | QualityControl$itemsArgs<ExtArgs>
    _count?: boolean | QualityControlCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QualityControlIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | QualityControl$purchaseOrderArgs<ExtArgs>
    return?: boolean | QualityControl$returnArgs<ExtArgs>
    inspectedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QualityControlIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | QualityControl$purchaseOrderArgs<ExtArgs>
    return?: boolean | QualityControl$returnArgs<ExtArgs>
    inspectedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QualityControlPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QualityControl"
    objects: {
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs> | null
      return: Prisma.$ReturnPayload<ExtArgs> | null
      inspectedBy: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$QualityControlItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referenceNumber: string
      type: $Enums.QCType
      status: $Enums.QCStatus
      warehouseId: string
      purchaseOrderId: string | null
      returnId: string | null
      inspectionDate: Date
      completedDate: Date | null
      inspectedById: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["qualityControl"]>
    composites: {}
  }

  type QualityControlGetPayload<S extends boolean | null | undefined | QualityControlDefaultArgs> = $Result.GetResult<Prisma.$QualityControlPayload, S>

  type QualityControlCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QualityControlFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QualityControlCountAggregateInputType | true
    }

  export interface QualityControlDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QualityControl'], meta: { name: 'QualityControl' } }
    /**
     * Find zero or one QualityControl that matches the filter.
     * @param {QualityControlFindUniqueArgs} args - Arguments to find a QualityControl
     * @example
     * // Get one QualityControl
     * const qualityControl = await prisma.qualityControl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QualityControlFindUniqueArgs>(args: SelectSubset<T, QualityControlFindUniqueArgs<ExtArgs>>): Prisma__QualityControlClient<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QualityControl that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QualityControlFindUniqueOrThrowArgs} args - Arguments to find a QualityControl
     * @example
     * // Get one QualityControl
     * const qualityControl = await prisma.qualityControl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QualityControlFindUniqueOrThrowArgs>(args: SelectSubset<T, QualityControlFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QualityControlClient<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QualityControl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityControlFindFirstArgs} args - Arguments to find a QualityControl
     * @example
     * // Get one QualityControl
     * const qualityControl = await prisma.qualityControl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QualityControlFindFirstArgs>(args?: SelectSubset<T, QualityControlFindFirstArgs<ExtArgs>>): Prisma__QualityControlClient<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QualityControl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityControlFindFirstOrThrowArgs} args - Arguments to find a QualityControl
     * @example
     * // Get one QualityControl
     * const qualityControl = await prisma.qualityControl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QualityControlFindFirstOrThrowArgs>(args?: SelectSubset<T, QualityControlFindFirstOrThrowArgs<ExtArgs>>): Prisma__QualityControlClient<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QualityControls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityControlFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QualityControls
     * const qualityControls = await prisma.qualityControl.findMany()
     * 
     * // Get first 10 QualityControls
     * const qualityControls = await prisma.qualityControl.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qualityControlWithIdOnly = await prisma.qualityControl.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QualityControlFindManyArgs>(args?: SelectSubset<T, QualityControlFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QualityControl.
     * @param {QualityControlCreateArgs} args - Arguments to create a QualityControl.
     * @example
     * // Create one QualityControl
     * const QualityControl = await prisma.qualityControl.create({
     *   data: {
     *     // ... data to create a QualityControl
     *   }
     * })
     * 
     */
    create<T extends QualityControlCreateArgs>(args: SelectSubset<T, QualityControlCreateArgs<ExtArgs>>): Prisma__QualityControlClient<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QualityControls.
     * @param {QualityControlCreateManyArgs} args - Arguments to create many QualityControls.
     * @example
     * // Create many QualityControls
     * const qualityControl = await prisma.qualityControl.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QualityControlCreateManyArgs>(args?: SelectSubset<T, QualityControlCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QualityControls and returns the data saved in the database.
     * @param {QualityControlCreateManyAndReturnArgs} args - Arguments to create many QualityControls.
     * @example
     * // Create many QualityControls
     * const qualityControl = await prisma.qualityControl.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QualityControls and only return the `id`
     * const qualityControlWithIdOnly = await prisma.qualityControl.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QualityControlCreateManyAndReturnArgs>(args?: SelectSubset<T, QualityControlCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QualityControl.
     * @param {QualityControlDeleteArgs} args - Arguments to delete one QualityControl.
     * @example
     * // Delete one QualityControl
     * const QualityControl = await prisma.qualityControl.delete({
     *   where: {
     *     // ... filter to delete one QualityControl
     *   }
     * })
     * 
     */
    delete<T extends QualityControlDeleteArgs>(args: SelectSubset<T, QualityControlDeleteArgs<ExtArgs>>): Prisma__QualityControlClient<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QualityControl.
     * @param {QualityControlUpdateArgs} args - Arguments to update one QualityControl.
     * @example
     * // Update one QualityControl
     * const qualityControl = await prisma.qualityControl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QualityControlUpdateArgs>(args: SelectSubset<T, QualityControlUpdateArgs<ExtArgs>>): Prisma__QualityControlClient<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QualityControls.
     * @param {QualityControlDeleteManyArgs} args - Arguments to filter QualityControls to delete.
     * @example
     * // Delete a few QualityControls
     * const { count } = await prisma.qualityControl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QualityControlDeleteManyArgs>(args?: SelectSubset<T, QualityControlDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QualityControls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityControlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QualityControls
     * const qualityControl = await prisma.qualityControl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QualityControlUpdateManyArgs>(args: SelectSubset<T, QualityControlUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QualityControls and returns the data updated in the database.
     * @param {QualityControlUpdateManyAndReturnArgs} args - Arguments to update many QualityControls.
     * @example
     * // Update many QualityControls
     * const qualityControl = await prisma.qualityControl.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QualityControls and only return the `id`
     * const qualityControlWithIdOnly = await prisma.qualityControl.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QualityControlUpdateManyAndReturnArgs>(args: SelectSubset<T, QualityControlUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QualityControl.
     * @param {QualityControlUpsertArgs} args - Arguments to update or create a QualityControl.
     * @example
     * // Update or create a QualityControl
     * const qualityControl = await prisma.qualityControl.upsert({
     *   create: {
     *     // ... data to create a QualityControl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QualityControl we want to update
     *   }
     * })
     */
    upsert<T extends QualityControlUpsertArgs>(args: SelectSubset<T, QualityControlUpsertArgs<ExtArgs>>): Prisma__QualityControlClient<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QualityControls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityControlCountArgs} args - Arguments to filter QualityControls to count.
     * @example
     * // Count the number of QualityControls
     * const count = await prisma.qualityControl.count({
     *   where: {
     *     // ... the filter for the QualityControls we want to count
     *   }
     * })
    **/
    count<T extends QualityControlCountArgs>(
      args?: Subset<T, QualityControlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QualityControlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QualityControl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityControlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QualityControlAggregateArgs>(args: Subset<T, QualityControlAggregateArgs>): Prisma.PrismaPromise<GetQualityControlAggregateType<T>>

    /**
     * Group by QualityControl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityControlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QualityControlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QualityControlGroupByArgs['orderBy'] }
        : { orderBy?: QualityControlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QualityControlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQualityControlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QualityControl model
   */
  readonly fields: QualityControlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QualityControl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QualityControlClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseOrder<T extends QualityControl$purchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, QualityControl$purchaseOrderArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    return<T extends QualityControl$returnArgs<ExtArgs> = {}>(args?: Subset<T, QualityControl$returnArgs<ExtArgs>>): Prisma__ReturnClient<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inspectedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends QualityControl$itemsArgs<ExtArgs> = {}>(args?: Subset<T, QualityControl$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityControlItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QualityControl model
   */
  interface QualityControlFieldRefs {
    readonly id: FieldRef<"QualityControl", 'String'>
    readonly referenceNumber: FieldRef<"QualityControl", 'String'>
    readonly type: FieldRef<"QualityControl", 'QCType'>
    readonly status: FieldRef<"QualityControl", 'QCStatus'>
    readonly warehouseId: FieldRef<"QualityControl", 'String'>
    readonly purchaseOrderId: FieldRef<"QualityControl", 'String'>
    readonly returnId: FieldRef<"QualityControl", 'String'>
    readonly inspectionDate: FieldRef<"QualityControl", 'DateTime'>
    readonly completedDate: FieldRef<"QualityControl", 'DateTime'>
    readonly inspectedById: FieldRef<"QualityControl", 'String'>
    readonly notes: FieldRef<"QualityControl", 'String'>
    readonly createdAt: FieldRef<"QualityControl", 'DateTime'>
    readonly updatedAt: FieldRef<"QualityControl", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QualityControl findUnique
   */
  export type QualityControlFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlInclude<ExtArgs> | null
    /**
     * Filter, which QualityControl to fetch.
     */
    where: QualityControlWhereUniqueInput
  }

  /**
   * QualityControl findUniqueOrThrow
   */
  export type QualityControlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlInclude<ExtArgs> | null
    /**
     * Filter, which QualityControl to fetch.
     */
    where: QualityControlWhereUniqueInput
  }

  /**
   * QualityControl findFirst
   */
  export type QualityControlFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlInclude<ExtArgs> | null
    /**
     * Filter, which QualityControl to fetch.
     */
    where?: QualityControlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityControls to fetch.
     */
    orderBy?: QualityControlOrderByWithRelationInput | QualityControlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QualityControls.
     */
    cursor?: QualityControlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityControls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityControls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QualityControls.
     */
    distinct?: QualityControlScalarFieldEnum | QualityControlScalarFieldEnum[]
  }

  /**
   * QualityControl findFirstOrThrow
   */
  export type QualityControlFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlInclude<ExtArgs> | null
    /**
     * Filter, which QualityControl to fetch.
     */
    where?: QualityControlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityControls to fetch.
     */
    orderBy?: QualityControlOrderByWithRelationInput | QualityControlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QualityControls.
     */
    cursor?: QualityControlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityControls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityControls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QualityControls.
     */
    distinct?: QualityControlScalarFieldEnum | QualityControlScalarFieldEnum[]
  }

  /**
   * QualityControl findMany
   */
  export type QualityControlFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlInclude<ExtArgs> | null
    /**
     * Filter, which QualityControls to fetch.
     */
    where?: QualityControlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityControls to fetch.
     */
    orderBy?: QualityControlOrderByWithRelationInput | QualityControlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QualityControls.
     */
    cursor?: QualityControlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityControls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityControls.
     */
    skip?: number
    distinct?: QualityControlScalarFieldEnum | QualityControlScalarFieldEnum[]
  }

  /**
   * QualityControl create
   */
  export type QualityControlCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlInclude<ExtArgs> | null
    /**
     * The data needed to create a QualityControl.
     */
    data: XOR<QualityControlCreateInput, QualityControlUncheckedCreateInput>
  }

  /**
   * QualityControl createMany
   */
  export type QualityControlCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QualityControls.
     */
    data: QualityControlCreateManyInput | QualityControlCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QualityControl createManyAndReturn
   */
  export type QualityControlCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * The data used to create many QualityControls.
     */
    data: QualityControlCreateManyInput | QualityControlCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QualityControl update
   */
  export type QualityControlUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlInclude<ExtArgs> | null
    /**
     * The data needed to update a QualityControl.
     */
    data: XOR<QualityControlUpdateInput, QualityControlUncheckedUpdateInput>
    /**
     * Choose, which QualityControl to update.
     */
    where: QualityControlWhereUniqueInput
  }

  /**
   * QualityControl updateMany
   */
  export type QualityControlUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QualityControls.
     */
    data: XOR<QualityControlUpdateManyMutationInput, QualityControlUncheckedUpdateManyInput>
    /**
     * Filter which QualityControls to update
     */
    where?: QualityControlWhereInput
    /**
     * Limit how many QualityControls to update.
     */
    limit?: number
  }

  /**
   * QualityControl updateManyAndReturn
   */
  export type QualityControlUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * The data used to update QualityControls.
     */
    data: XOR<QualityControlUpdateManyMutationInput, QualityControlUncheckedUpdateManyInput>
    /**
     * Filter which QualityControls to update
     */
    where?: QualityControlWhereInput
    /**
     * Limit how many QualityControls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QualityControl upsert
   */
  export type QualityControlUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlInclude<ExtArgs> | null
    /**
     * The filter to search for the QualityControl to update in case it exists.
     */
    where: QualityControlWhereUniqueInput
    /**
     * In case the QualityControl found by the `where` argument doesn't exist, create a new QualityControl with this data.
     */
    create: XOR<QualityControlCreateInput, QualityControlUncheckedCreateInput>
    /**
     * In case the QualityControl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QualityControlUpdateInput, QualityControlUncheckedUpdateInput>
  }

  /**
   * QualityControl delete
   */
  export type QualityControlDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlInclude<ExtArgs> | null
    /**
     * Filter which QualityControl to delete.
     */
    where: QualityControlWhereUniqueInput
  }

  /**
   * QualityControl deleteMany
   */
  export type QualityControlDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QualityControls to delete
     */
    where?: QualityControlWhereInput
    /**
     * Limit how many QualityControls to delete.
     */
    limit?: number
  }

  /**
   * QualityControl.purchaseOrder
   */
  export type QualityControl$purchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
  }

  /**
   * QualityControl.return
   */
  export type QualityControl$returnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnInclude<ExtArgs> | null
    where?: ReturnWhereInput
  }

  /**
   * QualityControl.items
   */
  export type QualityControl$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControlItem
     */
    select?: QualityControlItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControlItem
     */
    omit?: QualityControlItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlItemInclude<ExtArgs> | null
    where?: QualityControlItemWhereInput
    orderBy?: QualityControlItemOrderByWithRelationInput | QualityControlItemOrderByWithRelationInput[]
    cursor?: QualityControlItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QualityControlItemScalarFieldEnum | QualityControlItemScalarFieldEnum[]
  }

  /**
   * QualityControl without action
   */
  export type QualityControlDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControl
     */
    select?: QualityControlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControl
     */
    omit?: QualityControlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlInclude<ExtArgs> | null
  }


  /**
   * Model QualityControlItem
   */

  export type AggregateQualityControlItem = {
    _count: QualityControlItemCountAggregateOutputType | null
    _avg: QualityControlItemAvgAggregateOutputType | null
    _sum: QualityControlItemSumAggregateOutputType | null
    _min: QualityControlItemMinAggregateOutputType | null
    _max: QualityControlItemMaxAggregateOutputType | null
  }

  export type QualityControlItemAvgAggregateOutputType = {
    quantity: number | null
    passedQuantity: number | null
    failedQuantity: number | null
    pendingQuantity: number | null
  }

  export type QualityControlItemSumAggregateOutputType = {
    quantity: number | null
    passedQuantity: number | null
    failedQuantity: number | null
    pendingQuantity: number | null
  }

  export type QualityControlItemMinAggregateOutputType = {
    id: string | null
    qualityControlId: string | null
    productId: string | null
    quantity: number | null
    passedQuantity: number | null
    failedQuantity: number | null
    pendingQuantity: number | null
    status: $Enums.QCItemStatus | null
    reason: string | null
    action: $Enums.QCAction | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QualityControlItemMaxAggregateOutputType = {
    id: string | null
    qualityControlId: string | null
    productId: string | null
    quantity: number | null
    passedQuantity: number | null
    failedQuantity: number | null
    pendingQuantity: number | null
    status: $Enums.QCItemStatus | null
    reason: string | null
    action: $Enums.QCAction | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QualityControlItemCountAggregateOutputType = {
    id: number
    qualityControlId: number
    productId: number
    quantity: number
    passedQuantity: number
    failedQuantity: number
    pendingQuantity: number
    status: number
    reason: number
    action: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QualityControlItemAvgAggregateInputType = {
    quantity?: true
    passedQuantity?: true
    failedQuantity?: true
    pendingQuantity?: true
  }

  export type QualityControlItemSumAggregateInputType = {
    quantity?: true
    passedQuantity?: true
    failedQuantity?: true
    pendingQuantity?: true
  }

  export type QualityControlItemMinAggregateInputType = {
    id?: true
    qualityControlId?: true
    productId?: true
    quantity?: true
    passedQuantity?: true
    failedQuantity?: true
    pendingQuantity?: true
    status?: true
    reason?: true
    action?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QualityControlItemMaxAggregateInputType = {
    id?: true
    qualityControlId?: true
    productId?: true
    quantity?: true
    passedQuantity?: true
    failedQuantity?: true
    pendingQuantity?: true
    status?: true
    reason?: true
    action?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QualityControlItemCountAggregateInputType = {
    id?: true
    qualityControlId?: true
    productId?: true
    quantity?: true
    passedQuantity?: true
    failedQuantity?: true
    pendingQuantity?: true
    status?: true
    reason?: true
    action?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QualityControlItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QualityControlItem to aggregate.
     */
    where?: QualityControlItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityControlItems to fetch.
     */
    orderBy?: QualityControlItemOrderByWithRelationInput | QualityControlItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QualityControlItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityControlItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityControlItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QualityControlItems
    **/
    _count?: true | QualityControlItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QualityControlItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QualityControlItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QualityControlItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QualityControlItemMaxAggregateInputType
  }

  export type GetQualityControlItemAggregateType<T extends QualityControlItemAggregateArgs> = {
        [P in keyof T & keyof AggregateQualityControlItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQualityControlItem[P]>
      : GetScalarType<T[P], AggregateQualityControlItem[P]>
  }




  export type QualityControlItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QualityControlItemWhereInput
    orderBy?: QualityControlItemOrderByWithAggregationInput | QualityControlItemOrderByWithAggregationInput[]
    by: QualityControlItemScalarFieldEnum[] | QualityControlItemScalarFieldEnum
    having?: QualityControlItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QualityControlItemCountAggregateInputType | true
    _avg?: QualityControlItemAvgAggregateInputType
    _sum?: QualityControlItemSumAggregateInputType
    _min?: QualityControlItemMinAggregateInputType
    _max?: QualityControlItemMaxAggregateInputType
  }

  export type QualityControlItemGroupByOutputType = {
    id: string
    qualityControlId: string
    productId: string
    quantity: number
    passedQuantity: number
    failedQuantity: number
    pendingQuantity: number
    status: $Enums.QCItemStatus
    reason: string | null
    action: $Enums.QCAction | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: QualityControlItemCountAggregateOutputType | null
    _avg: QualityControlItemAvgAggregateOutputType | null
    _sum: QualityControlItemSumAggregateOutputType | null
    _min: QualityControlItemMinAggregateOutputType | null
    _max: QualityControlItemMaxAggregateOutputType | null
  }

  type GetQualityControlItemGroupByPayload<T extends QualityControlItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QualityControlItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QualityControlItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QualityControlItemGroupByOutputType[P]>
            : GetScalarType<T[P], QualityControlItemGroupByOutputType[P]>
        }
      >
    >


  export type QualityControlItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qualityControlId?: boolean
    productId?: boolean
    quantity?: boolean
    passedQuantity?: boolean
    failedQuantity?: boolean
    pendingQuantity?: boolean
    status?: boolean
    reason?: boolean
    action?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    qualityControl?: boolean | QualityControlDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qualityControlItem"]>

  export type QualityControlItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qualityControlId?: boolean
    productId?: boolean
    quantity?: boolean
    passedQuantity?: boolean
    failedQuantity?: boolean
    pendingQuantity?: boolean
    status?: boolean
    reason?: boolean
    action?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    qualityControl?: boolean | QualityControlDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qualityControlItem"]>

  export type QualityControlItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qualityControlId?: boolean
    productId?: boolean
    quantity?: boolean
    passedQuantity?: boolean
    failedQuantity?: boolean
    pendingQuantity?: boolean
    status?: boolean
    reason?: boolean
    action?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    qualityControl?: boolean | QualityControlDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qualityControlItem"]>

  export type QualityControlItemSelectScalar = {
    id?: boolean
    qualityControlId?: boolean
    productId?: boolean
    quantity?: boolean
    passedQuantity?: boolean
    failedQuantity?: boolean
    pendingQuantity?: boolean
    status?: boolean
    reason?: boolean
    action?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QualityControlItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "qualityControlId" | "productId" | "quantity" | "passedQuantity" | "failedQuantity" | "pendingQuantity" | "status" | "reason" | "action" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["qualityControlItem"]>
  export type QualityControlItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qualityControl?: boolean | QualityControlDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type QualityControlItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qualityControl?: boolean | QualityControlDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type QualityControlItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qualityControl?: boolean | QualityControlDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $QualityControlItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QualityControlItem"
    objects: {
      qualityControl: Prisma.$QualityControlPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      qualityControlId: string
      productId: string
      quantity: number
      passedQuantity: number
      failedQuantity: number
      pendingQuantity: number
      status: $Enums.QCItemStatus
      reason: string | null
      action: $Enums.QCAction | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["qualityControlItem"]>
    composites: {}
  }

  type QualityControlItemGetPayload<S extends boolean | null | undefined | QualityControlItemDefaultArgs> = $Result.GetResult<Prisma.$QualityControlItemPayload, S>

  type QualityControlItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QualityControlItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QualityControlItemCountAggregateInputType | true
    }

  export interface QualityControlItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QualityControlItem'], meta: { name: 'QualityControlItem' } }
    /**
     * Find zero or one QualityControlItem that matches the filter.
     * @param {QualityControlItemFindUniqueArgs} args - Arguments to find a QualityControlItem
     * @example
     * // Get one QualityControlItem
     * const qualityControlItem = await prisma.qualityControlItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QualityControlItemFindUniqueArgs>(args: SelectSubset<T, QualityControlItemFindUniqueArgs<ExtArgs>>): Prisma__QualityControlItemClient<$Result.GetResult<Prisma.$QualityControlItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QualityControlItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QualityControlItemFindUniqueOrThrowArgs} args - Arguments to find a QualityControlItem
     * @example
     * // Get one QualityControlItem
     * const qualityControlItem = await prisma.qualityControlItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QualityControlItemFindUniqueOrThrowArgs>(args: SelectSubset<T, QualityControlItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QualityControlItemClient<$Result.GetResult<Prisma.$QualityControlItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QualityControlItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityControlItemFindFirstArgs} args - Arguments to find a QualityControlItem
     * @example
     * // Get one QualityControlItem
     * const qualityControlItem = await prisma.qualityControlItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QualityControlItemFindFirstArgs>(args?: SelectSubset<T, QualityControlItemFindFirstArgs<ExtArgs>>): Prisma__QualityControlItemClient<$Result.GetResult<Prisma.$QualityControlItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QualityControlItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityControlItemFindFirstOrThrowArgs} args - Arguments to find a QualityControlItem
     * @example
     * // Get one QualityControlItem
     * const qualityControlItem = await prisma.qualityControlItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QualityControlItemFindFirstOrThrowArgs>(args?: SelectSubset<T, QualityControlItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__QualityControlItemClient<$Result.GetResult<Prisma.$QualityControlItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QualityControlItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityControlItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QualityControlItems
     * const qualityControlItems = await prisma.qualityControlItem.findMany()
     * 
     * // Get first 10 QualityControlItems
     * const qualityControlItems = await prisma.qualityControlItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qualityControlItemWithIdOnly = await prisma.qualityControlItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QualityControlItemFindManyArgs>(args?: SelectSubset<T, QualityControlItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityControlItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QualityControlItem.
     * @param {QualityControlItemCreateArgs} args - Arguments to create a QualityControlItem.
     * @example
     * // Create one QualityControlItem
     * const QualityControlItem = await prisma.qualityControlItem.create({
     *   data: {
     *     // ... data to create a QualityControlItem
     *   }
     * })
     * 
     */
    create<T extends QualityControlItemCreateArgs>(args: SelectSubset<T, QualityControlItemCreateArgs<ExtArgs>>): Prisma__QualityControlItemClient<$Result.GetResult<Prisma.$QualityControlItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QualityControlItems.
     * @param {QualityControlItemCreateManyArgs} args - Arguments to create many QualityControlItems.
     * @example
     * // Create many QualityControlItems
     * const qualityControlItem = await prisma.qualityControlItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QualityControlItemCreateManyArgs>(args?: SelectSubset<T, QualityControlItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QualityControlItems and returns the data saved in the database.
     * @param {QualityControlItemCreateManyAndReturnArgs} args - Arguments to create many QualityControlItems.
     * @example
     * // Create many QualityControlItems
     * const qualityControlItem = await prisma.qualityControlItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QualityControlItems and only return the `id`
     * const qualityControlItemWithIdOnly = await prisma.qualityControlItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QualityControlItemCreateManyAndReturnArgs>(args?: SelectSubset<T, QualityControlItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityControlItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QualityControlItem.
     * @param {QualityControlItemDeleteArgs} args - Arguments to delete one QualityControlItem.
     * @example
     * // Delete one QualityControlItem
     * const QualityControlItem = await prisma.qualityControlItem.delete({
     *   where: {
     *     // ... filter to delete one QualityControlItem
     *   }
     * })
     * 
     */
    delete<T extends QualityControlItemDeleteArgs>(args: SelectSubset<T, QualityControlItemDeleteArgs<ExtArgs>>): Prisma__QualityControlItemClient<$Result.GetResult<Prisma.$QualityControlItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QualityControlItem.
     * @param {QualityControlItemUpdateArgs} args - Arguments to update one QualityControlItem.
     * @example
     * // Update one QualityControlItem
     * const qualityControlItem = await prisma.qualityControlItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QualityControlItemUpdateArgs>(args: SelectSubset<T, QualityControlItemUpdateArgs<ExtArgs>>): Prisma__QualityControlItemClient<$Result.GetResult<Prisma.$QualityControlItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QualityControlItems.
     * @param {QualityControlItemDeleteManyArgs} args - Arguments to filter QualityControlItems to delete.
     * @example
     * // Delete a few QualityControlItems
     * const { count } = await prisma.qualityControlItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QualityControlItemDeleteManyArgs>(args?: SelectSubset<T, QualityControlItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QualityControlItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityControlItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QualityControlItems
     * const qualityControlItem = await prisma.qualityControlItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QualityControlItemUpdateManyArgs>(args: SelectSubset<T, QualityControlItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QualityControlItems and returns the data updated in the database.
     * @param {QualityControlItemUpdateManyAndReturnArgs} args - Arguments to update many QualityControlItems.
     * @example
     * // Update many QualityControlItems
     * const qualityControlItem = await prisma.qualityControlItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QualityControlItems and only return the `id`
     * const qualityControlItemWithIdOnly = await prisma.qualityControlItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QualityControlItemUpdateManyAndReturnArgs>(args: SelectSubset<T, QualityControlItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityControlItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QualityControlItem.
     * @param {QualityControlItemUpsertArgs} args - Arguments to update or create a QualityControlItem.
     * @example
     * // Update or create a QualityControlItem
     * const qualityControlItem = await prisma.qualityControlItem.upsert({
     *   create: {
     *     // ... data to create a QualityControlItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QualityControlItem we want to update
     *   }
     * })
     */
    upsert<T extends QualityControlItemUpsertArgs>(args: SelectSubset<T, QualityControlItemUpsertArgs<ExtArgs>>): Prisma__QualityControlItemClient<$Result.GetResult<Prisma.$QualityControlItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QualityControlItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityControlItemCountArgs} args - Arguments to filter QualityControlItems to count.
     * @example
     * // Count the number of QualityControlItems
     * const count = await prisma.qualityControlItem.count({
     *   where: {
     *     // ... the filter for the QualityControlItems we want to count
     *   }
     * })
    **/
    count<T extends QualityControlItemCountArgs>(
      args?: Subset<T, QualityControlItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QualityControlItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QualityControlItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityControlItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QualityControlItemAggregateArgs>(args: Subset<T, QualityControlItemAggregateArgs>): Prisma.PrismaPromise<GetQualityControlItemAggregateType<T>>

    /**
     * Group by QualityControlItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityControlItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QualityControlItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QualityControlItemGroupByArgs['orderBy'] }
        : { orderBy?: QualityControlItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QualityControlItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQualityControlItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QualityControlItem model
   */
  readonly fields: QualityControlItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QualityControlItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QualityControlItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    qualityControl<T extends QualityControlDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QualityControlDefaultArgs<ExtArgs>>): Prisma__QualityControlClient<$Result.GetResult<Prisma.$QualityControlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QualityControlItem model
   */
  interface QualityControlItemFieldRefs {
    readonly id: FieldRef<"QualityControlItem", 'String'>
    readonly qualityControlId: FieldRef<"QualityControlItem", 'String'>
    readonly productId: FieldRef<"QualityControlItem", 'String'>
    readonly quantity: FieldRef<"QualityControlItem", 'Int'>
    readonly passedQuantity: FieldRef<"QualityControlItem", 'Int'>
    readonly failedQuantity: FieldRef<"QualityControlItem", 'Int'>
    readonly pendingQuantity: FieldRef<"QualityControlItem", 'Int'>
    readonly status: FieldRef<"QualityControlItem", 'QCItemStatus'>
    readonly reason: FieldRef<"QualityControlItem", 'String'>
    readonly action: FieldRef<"QualityControlItem", 'QCAction'>
    readonly notes: FieldRef<"QualityControlItem", 'String'>
    readonly createdAt: FieldRef<"QualityControlItem", 'DateTime'>
    readonly updatedAt: FieldRef<"QualityControlItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QualityControlItem findUnique
   */
  export type QualityControlItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControlItem
     */
    select?: QualityControlItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControlItem
     */
    omit?: QualityControlItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlItemInclude<ExtArgs> | null
    /**
     * Filter, which QualityControlItem to fetch.
     */
    where: QualityControlItemWhereUniqueInput
  }

  /**
   * QualityControlItem findUniqueOrThrow
   */
  export type QualityControlItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControlItem
     */
    select?: QualityControlItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControlItem
     */
    omit?: QualityControlItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlItemInclude<ExtArgs> | null
    /**
     * Filter, which QualityControlItem to fetch.
     */
    where: QualityControlItemWhereUniqueInput
  }

  /**
   * QualityControlItem findFirst
   */
  export type QualityControlItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControlItem
     */
    select?: QualityControlItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControlItem
     */
    omit?: QualityControlItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlItemInclude<ExtArgs> | null
    /**
     * Filter, which QualityControlItem to fetch.
     */
    where?: QualityControlItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityControlItems to fetch.
     */
    orderBy?: QualityControlItemOrderByWithRelationInput | QualityControlItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QualityControlItems.
     */
    cursor?: QualityControlItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityControlItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityControlItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QualityControlItems.
     */
    distinct?: QualityControlItemScalarFieldEnum | QualityControlItemScalarFieldEnum[]
  }

  /**
   * QualityControlItem findFirstOrThrow
   */
  export type QualityControlItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControlItem
     */
    select?: QualityControlItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControlItem
     */
    omit?: QualityControlItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlItemInclude<ExtArgs> | null
    /**
     * Filter, which QualityControlItem to fetch.
     */
    where?: QualityControlItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityControlItems to fetch.
     */
    orderBy?: QualityControlItemOrderByWithRelationInput | QualityControlItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QualityControlItems.
     */
    cursor?: QualityControlItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityControlItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityControlItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QualityControlItems.
     */
    distinct?: QualityControlItemScalarFieldEnum | QualityControlItemScalarFieldEnum[]
  }

  /**
   * QualityControlItem findMany
   */
  export type QualityControlItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControlItem
     */
    select?: QualityControlItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControlItem
     */
    omit?: QualityControlItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlItemInclude<ExtArgs> | null
    /**
     * Filter, which QualityControlItems to fetch.
     */
    where?: QualityControlItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityControlItems to fetch.
     */
    orderBy?: QualityControlItemOrderByWithRelationInput | QualityControlItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QualityControlItems.
     */
    cursor?: QualityControlItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityControlItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityControlItems.
     */
    skip?: number
    distinct?: QualityControlItemScalarFieldEnum | QualityControlItemScalarFieldEnum[]
  }

  /**
   * QualityControlItem create
   */
  export type QualityControlItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControlItem
     */
    select?: QualityControlItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControlItem
     */
    omit?: QualityControlItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlItemInclude<ExtArgs> | null
    /**
     * The data needed to create a QualityControlItem.
     */
    data: XOR<QualityControlItemCreateInput, QualityControlItemUncheckedCreateInput>
  }

  /**
   * QualityControlItem createMany
   */
  export type QualityControlItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QualityControlItems.
     */
    data: QualityControlItemCreateManyInput | QualityControlItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QualityControlItem createManyAndReturn
   */
  export type QualityControlItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControlItem
     */
    select?: QualityControlItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControlItem
     */
    omit?: QualityControlItemOmit<ExtArgs> | null
    /**
     * The data used to create many QualityControlItems.
     */
    data: QualityControlItemCreateManyInput | QualityControlItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QualityControlItem update
   */
  export type QualityControlItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControlItem
     */
    select?: QualityControlItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControlItem
     */
    omit?: QualityControlItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlItemInclude<ExtArgs> | null
    /**
     * The data needed to update a QualityControlItem.
     */
    data: XOR<QualityControlItemUpdateInput, QualityControlItemUncheckedUpdateInput>
    /**
     * Choose, which QualityControlItem to update.
     */
    where: QualityControlItemWhereUniqueInput
  }

  /**
   * QualityControlItem updateMany
   */
  export type QualityControlItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QualityControlItems.
     */
    data: XOR<QualityControlItemUpdateManyMutationInput, QualityControlItemUncheckedUpdateManyInput>
    /**
     * Filter which QualityControlItems to update
     */
    where?: QualityControlItemWhereInput
    /**
     * Limit how many QualityControlItems to update.
     */
    limit?: number
  }

  /**
   * QualityControlItem updateManyAndReturn
   */
  export type QualityControlItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControlItem
     */
    select?: QualityControlItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControlItem
     */
    omit?: QualityControlItemOmit<ExtArgs> | null
    /**
     * The data used to update QualityControlItems.
     */
    data: XOR<QualityControlItemUpdateManyMutationInput, QualityControlItemUncheckedUpdateManyInput>
    /**
     * Filter which QualityControlItems to update
     */
    where?: QualityControlItemWhereInput
    /**
     * Limit how many QualityControlItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QualityControlItem upsert
   */
  export type QualityControlItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControlItem
     */
    select?: QualityControlItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControlItem
     */
    omit?: QualityControlItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlItemInclude<ExtArgs> | null
    /**
     * The filter to search for the QualityControlItem to update in case it exists.
     */
    where: QualityControlItemWhereUniqueInput
    /**
     * In case the QualityControlItem found by the `where` argument doesn't exist, create a new QualityControlItem with this data.
     */
    create: XOR<QualityControlItemCreateInput, QualityControlItemUncheckedCreateInput>
    /**
     * In case the QualityControlItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QualityControlItemUpdateInput, QualityControlItemUncheckedUpdateInput>
  }

  /**
   * QualityControlItem delete
   */
  export type QualityControlItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControlItem
     */
    select?: QualityControlItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControlItem
     */
    omit?: QualityControlItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlItemInclude<ExtArgs> | null
    /**
     * Filter which QualityControlItem to delete.
     */
    where: QualityControlItemWhereUniqueInput
  }

  /**
   * QualityControlItem deleteMany
   */
  export type QualityControlItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QualityControlItems to delete
     */
    where?: QualityControlItemWhereInput
    /**
     * Limit how many QualityControlItems to delete.
     */
    limit?: number
  }

  /**
   * QualityControlItem without action
   */
  export type QualityControlItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityControlItem
     */
    select?: QualityControlItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QualityControlItem
     */
    omit?: QualityControlItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QualityControlItemInclude<ExtArgs> | null
  }


  /**
   * Model Transfer
   */

  export type AggregateTransfer = {
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  export type TransferAvgAggregateOutputType = {
    totalItems: number | null
    totalCost: number | null
    totalRetail: number | null
  }

  export type TransferSumAggregateOutputType = {
    totalItems: number | null
    totalCost: number | null
    totalRetail: number | null
  }

  export type TransferMinAggregateOutputType = {
    id: string | null
    transferNumber: string | null
    fromWarehouseId: string | null
    fromStoreId: string | null
    toWarehouseId: string | null
    toStoreId: string | null
    status: $Enums.TransferStatus | null
    transferType: $Enums.TransferType | null
    priority: $Enums.TransferPriority | null
    requestedById: string | null
    approvedById: string | null
    rejectedById: string | null
    completedById: string | null
    requestedDate: Date | null
    approvedDate: Date | null
    rejectedDate: Date | null
    completedDate: Date | null
    expectedDeliveryDate: Date | null
    actualDeliveryDate: Date | null
    shippingMethod: string | null
    trackingNumber: string | null
    totalItems: number | null
    totalCost: number | null
    totalRetail: number | null
    rejectionReason: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferMaxAggregateOutputType = {
    id: string | null
    transferNumber: string | null
    fromWarehouseId: string | null
    fromStoreId: string | null
    toWarehouseId: string | null
    toStoreId: string | null
    status: $Enums.TransferStatus | null
    transferType: $Enums.TransferType | null
    priority: $Enums.TransferPriority | null
    requestedById: string | null
    approvedById: string | null
    rejectedById: string | null
    completedById: string | null
    requestedDate: Date | null
    approvedDate: Date | null
    rejectedDate: Date | null
    completedDate: Date | null
    expectedDeliveryDate: Date | null
    actualDeliveryDate: Date | null
    shippingMethod: string | null
    trackingNumber: string | null
    totalItems: number | null
    totalCost: number | null
    totalRetail: number | null
    rejectionReason: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferCountAggregateOutputType = {
    id: number
    transferNumber: number
    fromWarehouseId: number
    fromStoreId: number
    toWarehouseId: number
    toStoreId: number
    status: number
    transferType: number
    priority: number
    requestedById: number
    approvedById: number
    rejectedById: number
    completedById: number
    requestedDate: number
    approvedDate: number
    rejectedDate: number
    completedDate: number
    expectedDeliveryDate: number
    actualDeliveryDate: number
    shippingMethod: number
    trackingNumber: number
    totalItems: number
    totalCost: number
    totalRetail: number
    rejectionReason: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransferAvgAggregateInputType = {
    totalItems?: true
    totalCost?: true
    totalRetail?: true
  }

  export type TransferSumAggregateInputType = {
    totalItems?: true
    totalCost?: true
    totalRetail?: true
  }

  export type TransferMinAggregateInputType = {
    id?: true
    transferNumber?: true
    fromWarehouseId?: true
    fromStoreId?: true
    toWarehouseId?: true
    toStoreId?: true
    status?: true
    transferType?: true
    priority?: true
    requestedById?: true
    approvedById?: true
    rejectedById?: true
    completedById?: true
    requestedDate?: true
    approvedDate?: true
    rejectedDate?: true
    completedDate?: true
    expectedDeliveryDate?: true
    actualDeliveryDate?: true
    shippingMethod?: true
    trackingNumber?: true
    totalItems?: true
    totalCost?: true
    totalRetail?: true
    rejectionReason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferMaxAggregateInputType = {
    id?: true
    transferNumber?: true
    fromWarehouseId?: true
    fromStoreId?: true
    toWarehouseId?: true
    toStoreId?: true
    status?: true
    transferType?: true
    priority?: true
    requestedById?: true
    approvedById?: true
    rejectedById?: true
    completedById?: true
    requestedDate?: true
    approvedDate?: true
    rejectedDate?: true
    completedDate?: true
    expectedDeliveryDate?: true
    actualDeliveryDate?: true
    shippingMethod?: true
    trackingNumber?: true
    totalItems?: true
    totalCost?: true
    totalRetail?: true
    rejectionReason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferCountAggregateInputType = {
    id?: true
    transferNumber?: true
    fromWarehouseId?: true
    fromStoreId?: true
    toWarehouseId?: true
    toStoreId?: true
    status?: true
    transferType?: true
    priority?: true
    requestedById?: true
    approvedById?: true
    rejectedById?: true
    completedById?: true
    requestedDate?: true
    approvedDate?: true
    rejectedDate?: true
    completedDate?: true
    expectedDeliveryDate?: true
    actualDeliveryDate?: true
    shippingMethod?: true
    trackingNumber?: true
    totalItems?: true
    totalCost?: true
    totalRetail?: true
    rejectionReason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfer to aggregate.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transfers
    **/
    _count?: true | TransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferMaxAggregateInputType
  }

  export type GetTransferAggregateType<T extends TransferAggregateArgs> = {
        [P in keyof T & keyof AggregateTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransfer[P]>
      : GetScalarType<T[P], AggregateTransfer[P]>
  }




  export type TransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithAggregationInput | TransferOrderByWithAggregationInput[]
    by: TransferScalarFieldEnum[] | TransferScalarFieldEnum
    having?: TransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferCountAggregateInputType | true
    _avg?: TransferAvgAggregateInputType
    _sum?: TransferSumAggregateInputType
    _min?: TransferMinAggregateInputType
    _max?: TransferMaxAggregateInputType
  }

  export type TransferGroupByOutputType = {
    id: string
    transferNumber: string
    fromWarehouseId: string | null
    fromStoreId: string | null
    toWarehouseId: string | null
    toStoreId: string | null
    status: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority: $Enums.TransferPriority
    requestedById: string | null
    approvedById: string | null
    rejectedById: string | null
    completedById: string | null
    requestedDate: Date | null
    approvedDate: Date | null
    rejectedDate: Date | null
    completedDate: Date | null
    expectedDeliveryDate: Date | null
    actualDeliveryDate: Date | null
    shippingMethod: string | null
    trackingNumber: string | null
    totalItems: number
    totalCost: number
    totalRetail: number
    rejectionReason: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  type GetTransferGroupByPayload<T extends TransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferGroupByOutputType[P]>
            : GetScalarType<T[P], TransferGroupByOutputType[P]>
        }
      >
    >


  export type TransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferNumber?: boolean
    fromWarehouseId?: boolean
    fromStoreId?: boolean
    toWarehouseId?: boolean
    toStoreId?: boolean
    status?: boolean
    transferType?: boolean
    priority?: boolean
    requestedById?: boolean
    approvedById?: boolean
    rejectedById?: boolean
    completedById?: boolean
    requestedDate?: boolean
    approvedDate?: boolean
    rejectedDate?: boolean
    completedDate?: boolean
    expectedDeliveryDate?: boolean
    actualDeliveryDate?: boolean
    shippingMethod?: boolean
    trackingNumber?: boolean
    totalItems?: boolean
    totalCost?: boolean
    totalRetail?: boolean
    rejectionReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromWarehouse?: boolean | Transfer$fromWarehouseArgs<ExtArgs>
    fromStore?: boolean | Transfer$fromStoreArgs<ExtArgs>
    toWarehouse?: boolean | Transfer$toWarehouseArgs<ExtArgs>
    toStore?: boolean | Transfer$toStoreArgs<ExtArgs>
    items?: boolean | Transfer$itemsArgs<ExtArgs>
    documents?: boolean | Transfer$documentsArgs<ExtArgs>
    _count?: boolean | TransferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferNumber?: boolean
    fromWarehouseId?: boolean
    fromStoreId?: boolean
    toWarehouseId?: boolean
    toStoreId?: boolean
    status?: boolean
    transferType?: boolean
    priority?: boolean
    requestedById?: boolean
    approvedById?: boolean
    rejectedById?: boolean
    completedById?: boolean
    requestedDate?: boolean
    approvedDate?: boolean
    rejectedDate?: boolean
    completedDate?: boolean
    expectedDeliveryDate?: boolean
    actualDeliveryDate?: boolean
    shippingMethod?: boolean
    trackingNumber?: boolean
    totalItems?: boolean
    totalCost?: boolean
    totalRetail?: boolean
    rejectionReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromWarehouse?: boolean | Transfer$fromWarehouseArgs<ExtArgs>
    fromStore?: boolean | Transfer$fromStoreArgs<ExtArgs>
    toWarehouse?: boolean | Transfer$toWarehouseArgs<ExtArgs>
    toStore?: boolean | Transfer$toStoreArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferNumber?: boolean
    fromWarehouseId?: boolean
    fromStoreId?: boolean
    toWarehouseId?: boolean
    toStoreId?: boolean
    status?: boolean
    transferType?: boolean
    priority?: boolean
    requestedById?: boolean
    approvedById?: boolean
    rejectedById?: boolean
    completedById?: boolean
    requestedDate?: boolean
    approvedDate?: boolean
    rejectedDate?: boolean
    completedDate?: boolean
    expectedDeliveryDate?: boolean
    actualDeliveryDate?: boolean
    shippingMethod?: boolean
    trackingNumber?: boolean
    totalItems?: boolean
    totalCost?: boolean
    totalRetail?: boolean
    rejectionReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromWarehouse?: boolean | Transfer$fromWarehouseArgs<ExtArgs>
    fromStore?: boolean | Transfer$fromStoreArgs<ExtArgs>
    toWarehouse?: boolean | Transfer$toWarehouseArgs<ExtArgs>
    toStore?: boolean | Transfer$toStoreArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectScalar = {
    id?: boolean
    transferNumber?: boolean
    fromWarehouseId?: boolean
    fromStoreId?: boolean
    toWarehouseId?: boolean
    toStoreId?: boolean
    status?: boolean
    transferType?: boolean
    priority?: boolean
    requestedById?: boolean
    approvedById?: boolean
    rejectedById?: boolean
    completedById?: boolean
    requestedDate?: boolean
    approvedDate?: boolean
    rejectedDate?: boolean
    completedDate?: boolean
    expectedDeliveryDate?: boolean
    actualDeliveryDate?: boolean
    shippingMethod?: boolean
    trackingNumber?: boolean
    totalItems?: boolean
    totalCost?: boolean
    totalRetail?: boolean
    rejectionReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transferNumber" | "fromWarehouseId" | "fromStoreId" | "toWarehouseId" | "toStoreId" | "status" | "transferType" | "priority" | "requestedById" | "approvedById" | "rejectedById" | "completedById" | "requestedDate" | "approvedDate" | "rejectedDate" | "completedDate" | "expectedDeliveryDate" | "actualDeliveryDate" | "shippingMethod" | "trackingNumber" | "totalItems" | "totalCost" | "totalRetail" | "rejectionReason" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["transfer"]>
  export type TransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromWarehouse?: boolean | Transfer$fromWarehouseArgs<ExtArgs>
    fromStore?: boolean | Transfer$fromStoreArgs<ExtArgs>
    toWarehouse?: boolean | Transfer$toWarehouseArgs<ExtArgs>
    toStore?: boolean | Transfer$toStoreArgs<ExtArgs>
    items?: boolean | Transfer$itemsArgs<ExtArgs>
    documents?: boolean | Transfer$documentsArgs<ExtArgs>
    _count?: boolean | TransferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromWarehouse?: boolean | Transfer$fromWarehouseArgs<ExtArgs>
    fromStore?: boolean | Transfer$fromStoreArgs<ExtArgs>
    toWarehouse?: boolean | Transfer$toWarehouseArgs<ExtArgs>
    toStore?: boolean | Transfer$toStoreArgs<ExtArgs>
  }
  export type TransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromWarehouse?: boolean | Transfer$fromWarehouseArgs<ExtArgs>
    fromStore?: boolean | Transfer$fromStoreArgs<ExtArgs>
    toWarehouse?: boolean | Transfer$toWarehouseArgs<ExtArgs>
    toStore?: boolean | Transfer$toStoreArgs<ExtArgs>
  }

  export type $TransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transfer"
    objects: {
      fromWarehouse: Prisma.$WarehousePayload<ExtArgs> | null
      fromStore: Prisma.$StorePayload<ExtArgs> | null
      toWarehouse: Prisma.$WarehousePayload<ExtArgs> | null
      toStore: Prisma.$StorePayload<ExtArgs> | null
      items: Prisma.$TransferItemPayload<ExtArgs>[]
      documents: Prisma.$TransferDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transferNumber: string
      fromWarehouseId: string | null
      fromStoreId: string | null
      toWarehouseId: string | null
      toStoreId: string | null
      status: $Enums.TransferStatus
      transferType: $Enums.TransferType
      priority: $Enums.TransferPriority
      requestedById: string | null
      approvedById: string | null
      rejectedById: string | null
      completedById: string | null
      requestedDate: Date | null
      approvedDate: Date | null
      rejectedDate: Date | null
      completedDate: Date | null
      expectedDeliveryDate: Date | null
      actualDeliveryDate: Date | null
      shippingMethod: string | null
      trackingNumber: string | null
      totalItems: number
      totalCost: number
      totalRetail: number
      rejectionReason: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transfer"]>
    composites: {}
  }

  type TransferGetPayload<S extends boolean | null | undefined | TransferDefaultArgs> = $Result.GetResult<Prisma.$TransferPayload, S>

  type TransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferCountAggregateInputType | true
    }

  export interface TransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transfer'], meta: { name: 'Transfer' } }
    /**
     * Find zero or one Transfer that matches the filter.
     * @param {TransferFindUniqueArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferFindUniqueArgs>(args: SelectSubset<T, TransferFindUniqueArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferFindUniqueOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferFindFirstArgs>(args?: SelectSubset<T, TransferFindFirstArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transfers
     * const transfers = await prisma.transfer.findMany()
     * 
     * // Get first 10 Transfers
     * const transfers = await prisma.transfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferWithIdOnly = await prisma.transfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferFindManyArgs>(args?: SelectSubset<T, TransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transfer.
     * @param {TransferCreateArgs} args - Arguments to create a Transfer.
     * @example
     * // Create one Transfer
     * const Transfer = await prisma.transfer.create({
     *   data: {
     *     // ... data to create a Transfer
     *   }
     * })
     * 
     */
    create<T extends TransferCreateArgs>(args: SelectSubset<T, TransferCreateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transfers.
     * @param {TransferCreateManyArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferCreateManyArgs>(args?: SelectSubset<T, TransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transfers and returns the data saved in the database.
     * @param {TransferCreateManyAndReturnArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transfer.
     * @param {TransferDeleteArgs} args - Arguments to delete one Transfer.
     * @example
     * // Delete one Transfer
     * const Transfer = await prisma.transfer.delete({
     *   where: {
     *     // ... filter to delete one Transfer
     *   }
     * })
     * 
     */
    delete<T extends TransferDeleteArgs>(args: SelectSubset<T, TransferDeleteArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transfer.
     * @param {TransferUpdateArgs} args - Arguments to update one Transfer.
     * @example
     * // Update one Transfer
     * const transfer = await prisma.transfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferUpdateArgs>(args: SelectSubset<T, TransferUpdateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transfers.
     * @param {TransferDeleteManyArgs} args - Arguments to filter Transfers to delete.
     * @example
     * // Delete a few Transfers
     * const { count } = await prisma.transfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferDeleteManyArgs>(args?: SelectSubset<T, TransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferUpdateManyArgs>(args: SelectSubset<T, TransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers and returns the data updated in the database.
     * @param {TransferUpdateManyAndReturnArgs} args - Arguments to update many Transfers.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransferUpdateManyAndReturnArgs>(args: SelectSubset<T, TransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transfer.
     * @param {TransferUpsertArgs} args - Arguments to update or create a Transfer.
     * @example
     * // Update or create a Transfer
     * const transfer = await prisma.transfer.upsert({
     *   create: {
     *     // ... data to create a Transfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transfer we want to update
     *   }
     * })
     */
    upsert<T extends TransferUpsertArgs>(args: SelectSubset<T, TransferUpsertArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferCountArgs} args - Arguments to filter Transfers to count.
     * @example
     * // Count the number of Transfers
     * const count = await prisma.transfer.count({
     *   where: {
     *     // ... the filter for the Transfers we want to count
     *   }
     * })
    **/
    count<T extends TransferCountArgs>(
      args?: Subset<T, TransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferAggregateArgs>(args: Subset<T, TransferAggregateArgs>): Prisma.PrismaPromise<GetTransferAggregateType<T>>

    /**
     * Group by Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferGroupByArgs['orderBy'] }
        : { orderBy?: TransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transfer model
   */
  readonly fields: TransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromWarehouse<T extends Transfer$fromWarehouseArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$fromWarehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fromStore<T extends Transfer$fromStoreArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$fromStoreArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    toWarehouse<T extends Transfer$toWarehouseArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$toWarehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    toStore<T extends Transfer$toStoreArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$toStoreArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Transfer$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Transfer$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transfer model
   */
  interface TransferFieldRefs {
    readonly id: FieldRef<"Transfer", 'String'>
    readonly transferNumber: FieldRef<"Transfer", 'String'>
    readonly fromWarehouseId: FieldRef<"Transfer", 'String'>
    readonly fromStoreId: FieldRef<"Transfer", 'String'>
    readonly toWarehouseId: FieldRef<"Transfer", 'String'>
    readonly toStoreId: FieldRef<"Transfer", 'String'>
    readonly status: FieldRef<"Transfer", 'TransferStatus'>
    readonly transferType: FieldRef<"Transfer", 'TransferType'>
    readonly priority: FieldRef<"Transfer", 'TransferPriority'>
    readonly requestedById: FieldRef<"Transfer", 'String'>
    readonly approvedById: FieldRef<"Transfer", 'String'>
    readonly rejectedById: FieldRef<"Transfer", 'String'>
    readonly completedById: FieldRef<"Transfer", 'String'>
    readonly requestedDate: FieldRef<"Transfer", 'DateTime'>
    readonly approvedDate: FieldRef<"Transfer", 'DateTime'>
    readonly rejectedDate: FieldRef<"Transfer", 'DateTime'>
    readonly completedDate: FieldRef<"Transfer", 'DateTime'>
    readonly expectedDeliveryDate: FieldRef<"Transfer", 'DateTime'>
    readonly actualDeliveryDate: FieldRef<"Transfer", 'DateTime'>
    readonly shippingMethod: FieldRef<"Transfer", 'String'>
    readonly trackingNumber: FieldRef<"Transfer", 'String'>
    readonly totalItems: FieldRef<"Transfer", 'Int'>
    readonly totalCost: FieldRef<"Transfer", 'Float'>
    readonly totalRetail: FieldRef<"Transfer", 'Float'>
    readonly rejectionReason: FieldRef<"Transfer", 'String'>
    readonly notes: FieldRef<"Transfer", 'String'>
    readonly createdAt: FieldRef<"Transfer", 'DateTime'>
    readonly updatedAt: FieldRef<"Transfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transfer findUnique
   */
  export type TransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findUniqueOrThrow
   */
  export type TransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findFirst
   */
  export type TransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findFirstOrThrow
   */
  export type TransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findMany
   */
  export type TransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfers to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer create
   */
  export type TransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to create a Transfer.
     */
    data: XOR<TransferCreateInput, TransferUncheckedCreateInput>
  }

  /**
   * Transfer createMany
   */
  export type TransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transfer createManyAndReturn
   */
  export type TransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer update
   */
  export type TransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to update a Transfer.
     */
    data: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
    /**
     * Choose, which Transfer to update.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer updateMany
   */
  export type TransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
  }

  /**
   * Transfer updateManyAndReturn
   */
  export type TransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer upsert
   */
  export type TransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The filter to search for the Transfer to update in case it exists.
     */
    where: TransferWhereUniqueInput
    /**
     * In case the Transfer found by the `where` argument doesn't exist, create a new Transfer with this data.
     */
    create: XOR<TransferCreateInput, TransferUncheckedCreateInput>
    /**
     * In case the Transfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
  }

  /**
   * Transfer delete
   */
  export type TransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter which Transfer to delete.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer deleteMany
   */
  export type TransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfers to delete
     */
    where?: TransferWhereInput
    /**
     * Limit how many Transfers to delete.
     */
    limit?: number
  }

  /**
   * Transfer.fromWarehouse
   */
  export type Transfer$fromWarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * Transfer.fromStore
   */
  export type Transfer$fromStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * Transfer.toWarehouse
   */
  export type Transfer$toWarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * Transfer.toStore
   */
  export type Transfer$toStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * Transfer.items
   */
  export type Transfer$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    where?: TransferItemWhereInput
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    cursor?: TransferItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * Transfer.documents
   */
  export type Transfer$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDocument
     */
    select?: TransferDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDocument
     */
    omit?: TransferDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDocumentInclude<ExtArgs> | null
    where?: TransferDocumentWhereInput
    orderBy?: TransferDocumentOrderByWithRelationInput | TransferDocumentOrderByWithRelationInput[]
    cursor?: TransferDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferDocumentScalarFieldEnum | TransferDocumentScalarFieldEnum[]
  }

  /**
   * Transfer without action
   */
  export type TransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transfer
     */
    omit?: TransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
  }


  /**
   * Model TransferDocument
   */

  export type AggregateTransferDocument = {
    _count: TransferDocumentCountAggregateOutputType | null
    _min: TransferDocumentMinAggregateOutputType | null
    _max: TransferDocumentMaxAggregateOutputType | null
  }

  export type TransferDocumentMinAggregateOutputType = {
    id: string | null
    transferId: string | null
    name: string | null
    type: string | null
    url: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferDocumentMaxAggregateOutputType = {
    id: string | null
    transferId: string | null
    name: string | null
    type: string | null
    url: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferDocumentCountAggregateOutputType = {
    id: number
    transferId: number
    name: number
    type: number
    url: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransferDocumentMinAggregateInputType = {
    id?: true
    transferId?: true
    name?: true
    type?: true
    url?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferDocumentMaxAggregateInputType = {
    id?: true
    transferId?: true
    name?: true
    type?: true
    url?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferDocumentCountAggregateInputType = {
    id?: true
    transferId?: true
    name?: true
    type?: true
    url?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransferDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferDocument to aggregate.
     */
    where?: TransferDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferDocuments to fetch.
     */
    orderBy?: TransferDocumentOrderByWithRelationInput | TransferDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransferDocuments
    **/
    _count?: true | TransferDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferDocumentMaxAggregateInputType
  }

  export type GetTransferDocumentAggregateType<T extends TransferDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateTransferDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransferDocument[P]>
      : GetScalarType<T[P], AggregateTransferDocument[P]>
  }




  export type TransferDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferDocumentWhereInput
    orderBy?: TransferDocumentOrderByWithAggregationInput | TransferDocumentOrderByWithAggregationInput[]
    by: TransferDocumentScalarFieldEnum[] | TransferDocumentScalarFieldEnum
    having?: TransferDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferDocumentCountAggregateInputType | true
    _min?: TransferDocumentMinAggregateInputType
    _max?: TransferDocumentMaxAggregateInputType
  }

  export type TransferDocumentGroupByOutputType = {
    id: string
    transferId: string
    name: string
    type: string
    url: string
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransferDocumentCountAggregateOutputType | null
    _min: TransferDocumentMinAggregateOutputType | null
    _max: TransferDocumentMaxAggregateOutputType | null
  }

  type GetTransferDocumentGroupByPayload<T extends TransferDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], TransferDocumentGroupByOutputType[P]>
        }
      >
    >


  export type TransferDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferDocument"]>

  export type TransferDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferDocument"]>

  export type TransferDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferDocument"]>

  export type TransferDocumentSelectScalar = {
    id?: boolean
    transferId?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransferDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transferId" | "name" | "type" | "url" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["transferDocument"]>
  export type TransferDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }
  export type TransferDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }
  export type TransferDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
  }

  export type $TransferDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransferDocument"
    objects: {
      transfer: Prisma.$TransferPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transferId: string
      name: string
      type: string
      url: string
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transferDocument"]>
    composites: {}
  }

  type TransferDocumentGetPayload<S extends boolean | null | undefined | TransferDocumentDefaultArgs> = $Result.GetResult<Prisma.$TransferDocumentPayload, S>

  type TransferDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferDocumentCountAggregateInputType | true
    }

  export interface TransferDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransferDocument'], meta: { name: 'TransferDocument' } }
    /**
     * Find zero or one TransferDocument that matches the filter.
     * @param {TransferDocumentFindUniqueArgs} args - Arguments to find a TransferDocument
     * @example
     * // Get one TransferDocument
     * const transferDocument = await prisma.transferDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferDocumentFindUniqueArgs>(args: SelectSubset<T, TransferDocumentFindUniqueArgs<ExtArgs>>): Prisma__TransferDocumentClient<$Result.GetResult<Prisma.$TransferDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransferDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferDocumentFindUniqueOrThrowArgs} args - Arguments to find a TransferDocument
     * @example
     * // Get one TransferDocument
     * const transferDocument = await prisma.transferDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferDocumentClient<$Result.GetResult<Prisma.$TransferDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransferDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferDocumentFindFirstArgs} args - Arguments to find a TransferDocument
     * @example
     * // Get one TransferDocument
     * const transferDocument = await prisma.transferDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferDocumentFindFirstArgs>(args?: SelectSubset<T, TransferDocumentFindFirstArgs<ExtArgs>>): Prisma__TransferDocumentClient<$Result.GetResult<Prisma.$TransferDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransferDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferDocumentFindFirstOrThrowArgs} args - Arguments to find a TransferDocument
     * @example
     * // Get one TransferDocument
     * const transferDocument = await prisma.transferDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferDocumentClient<$Result.GetResult<Prisma.$TransferDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransferDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransferDocuments
     * const transferDocuments = await prisma.transferDocument.findMany()
     * 
     * // Get first 10 TransferDocuments
     * const transferDocuments = await prisma.transferDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferDocumentWithIdOnly = await prisma.transferDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferDocumentFindManyArgs>(args?: SelectSubset<T, TransferDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransferDocument.
     * @param {TransferDocumentCreateArgs} args - Arguments to create a TransferDocument.
     * @example
     * // Create one TransferDocument
     * const TransferDocument = await prisma.transferDocument.create({
     *   data: {
     *     // ... data to create a TransferDocument
     *   }
     * })
     * 
     */
    create<T extends TransferDocumentCreateArgs>(args: SelectSubset<T, TransferDocumentCreateArgs<ExtArgs>>): Prisma__TransferDocumentClient<$Result.GetResult<Prisma.$TransferDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransferDocuments.
     * @param {TransferDocumentCreateManyArgs} args - Arguments to create many TransferDocuments.
     * @example
     * // Create many TransferDocuments
     * const transferDocument = await prisma.transferDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferDocumentCreateManyArgs>(args?: SelectSubset<T, TransferDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransferDocuments and returns the data saved in the database.
     * @param {TransferDocumentCreateManyAndReturnArgs} args - Arguments to create many TransferDocuments.
     * @example
     * // Create many TransferDocuments
     * const transferDocument = await prisma.transferDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransferDocuments and only return the `id`
     * const transferDocumentWithIdOnly = await prisma.transferDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransferDocument.
     * @param {TransferDocumentDeleteArgs} args - Arguments to delete one TransferDocument.
     * @example
     * // Delete one TransferDocument
     * const TransferDocument = await prisma.transferDocument.delete({
     *   where: {
     *     // ... filter to delete one TransferDocument
     *   }
     * })
     * 
     */
    delete<T extends TransferDocumentDeleteArgs>(args: SelectSubset<T, TransferDocumentDeleteArgs<ExtArgs>>): Prisma__TransferDocumentClient<$Result.GetResult<Prisma.$TransferDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransferDocument.
     * @param {TransferDocumentUpdateArgs} args - Arguments to update one TransferDocument.
     * @example
     * // Update one TransferDocument
     * const transferDocument = await prisma.transferDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferDocumentUpdateArgs>(args: SelectSubset<T, TransferDocumentUpdateArgs<ExtArgs>>): Prisma__TransferDocumentClient<$Result.GetResult<Prisma.$TransferDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransferDocuments.
     * @param {TransferDocumentDeleteManyArgs} args - Arguments to filter TransferDocuments to delete.
     * @example
     * // Delete a few TransferDocuments
     * const { count } = await prisma.transferDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferDocumentDeleteManyArgs>(args?: SelectSubset<T, TransferDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransferDocuments
     * const transferDocument = await prisma.transferDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferDocumentUpdateManyArgs>(args: SelectSubset<T, TransferDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferDocuments and returns the data updated in the database.
     * @param {TransferDocumentUpdateManyAndReturnArgs} args - Arguments to update many TransferDocuments.
     * @example
     * // Update many TransferDocuments
     * const transferDocument = await prisma.transferDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransferDocuments and only return the `id`
     * const transferDocumentWithIdOnly = await prisma.transferDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransferDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, TransferDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransferDocument.
     * @param {TransferDocumentUpsertArgs} args - Arguments to update or create a TransferDocument.
     * @example
     * // Update or create a TransferDocument
     * const transferDocument = await prisma.transferDocument.upsert({
     *   create: {
     *     // ... data to create a TransferDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransferDocument we want to update
     *   }
     * })
     */
    upsert<T extends TransferDocumentUpsertArgs>(args: SelectSubset<T, TransferDocumentUpsertArgs<ExtArgs>>): Prisma__TransferDocumentClient<$Result.GetResult<Prisma.$TransferDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransferDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferDocumentCountArgs} args - Arguments to filter TransferDocuments to count.
     * @example
     * // Count the number of TransferDocuments
     * const count = await prisma.transferDocument.count({
     *   where: {
     *     // ... the filter for the TransferDocuments we want to count
     *   }
     * })
    **/
    count<T extends TransferDocumentCountArgs>(
      args?: Subset<T, TransferDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransferDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferDocumentAggregateArgs>(args: Subset<T, TransferDocumentAggregateArgs>): Prisma.PrismaPromise<GetTransferDocumentAggregateType<T>>

    /**
     * Group by TransferDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferDocumentGroupByArgs['orderBy'] }
        : { orderBy?: TransferDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransferDocument model
   */
  readonly fields: TransferDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransferDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transfer<T extends TransferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransferDefaultArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransferDocument model
   */
  interface TransferDocumentFieldRefs {
    readonly id: FieldRef<"TransferDocument", 'String'>
    readonly transferId: FieldRef<"TransferDocument", 'String'>
    readonly name: FieldRef<"TransferDocument", 'String'>
    readonly type: FieldRef<"TransferDocument", 'String'>
    readonly url: FieldRef<"TransferDocument", 'String'>
    readonly createdById: FieldRef<"TransferDocument", 'String'>
    readonly createdAt: FieldRef<"TransferDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"TransferDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransferDocument findUnique
   */
  export type TransferDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDocument
     */
    select?: TransferDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDocument
     */
    omit?: TransferDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TransferDocument to fetch.
     */
    where: TransferDocumentWhereUniqueInput
  }

  /**
   * TransferDocument findUniqueOrThrow
   */
  export type TransferDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDocument
     */
    select?: TransferDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDocument
     */
    omit?: TransferDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TransferDocument to fetch.
     */
    where: TransferDocumentWhereUniqueInput
  }

  /**
   * TransferDocument findFirst
   */
  export type TransferDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDocument
     */
    select?: TransferDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDocument
     */
    omit?: TransferDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TransferDocument to fetch.
     */
    where?: TransferDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferDocuments to fetch.
     */
    orderBy?: TransferDocumentOrderByWithRelationInput | TransferDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferDocuments.
     */
    cursor?: TransferDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferDocuments.
     */
    distinct?: TransferDocumentScalarFieldEnum | TransferDocumentScalarFieldEnum[]
  }

  /**
   * TransferDocument findFirstOrThrow
   */
  export type TransferDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDocument
     */
    select?: TransferDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDocument
     */
    omit?: TransferDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TransferDocument to fetch.
     */
    where?: TransferDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferDocuments to fetch.
     */
    orderBy?: TransferDocumentOrderByWithRelationInput | TransferDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferDocuments.
     */
    cursor?: TransferDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferDocuments.
     */
    distinct?: TransferDocumentScalarFieldEnum | TransferDocumentScalarFieldEnum[]
  }

  /**
   * TransferDocument findMany
   */
  export type TransferDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDocument
     */
    select?: TransferDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDocument
     */
    omit?: TransferDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TransferDocuments to fetch.
     */
    where?: TransferDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferDocuments to fetch.
     */
    orderBy?: TransferDocumentOrderByWithRelationInput | TransferDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransferDocuments.
     */
    cursor?: TransferDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferDocuments.
     */
    skip?: number
    distinct?: TransferDocumentScalarFieldEnum | TransferDocumentScalarFieldEnum[]
  }

  /**
   * TransferDocument create
   */
  export type TransferDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDocument
     */
    select?: TransferDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDocument
     */
    omit?: TransferDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a TransferDocument.
     */
    data: XOR<TransferDocumentCreateInput, TransferDocumentUncheckedCreateInput>
  }

  /**
   * TransferDocument createMany
   */
  export type TransferDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransferDocuments.
     */
    data: TransferDocumentCreateManyInput | TransferDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransferDocument createManyAndReturn
   */
  export type TransferDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDocument
     */
    select?: TransferDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDocument
     */
    omit?: TransferDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many TransferDocuments.
     */
    data: TransferDocumentCreateManyInput | TransferDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferDocument update
   */
  export type TransferDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDocument
     */
    select?: TransferDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDocument
     */
    omit?: TransferDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a TransferDocument.
     */
    data: XOR<TransferDocumentUpdateInput, TransferDocumentUncheckedUpdateInput>
    /**
     * Choose, which TransferDocument to update.
     */
    where: TransferDocumentWhereUniqueInput
  }

  /**
   * TransferDocument updateMany
   */
  export type TransferDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransferDocuments.
     */
    data: XOR<TransferDocumentUpdateManyMutationInput, TransferDocumentUncheckedUpdateManyInput>
    /**
     * Filter which TransferDocuments to update
     */
    where?: TransferDocumentWhereInput
    /**
     * Limit how many TransferDocuments to update.
     */
    limit?: number
  }

  /**
   * TransferDocument updateManyAndReturn
   */
  export type TransferDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDocument
     */
    select?: TransferDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDocument
     */
    omit?: TransferDocumentOmit<ExtArgs> | null
    /**
     * The data used to update TransferDocuments.
     */
    data: XOR<TransferDocumentUpdateManyMutationInput, TransferDocumentUncheckedUpdateManyInput>
    /**
     * Filter which TransferDocuments to update
     */
    where?: TransferDocumentWhereInput
    /**
     * Limit how many TransferDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferDocument upsert
   */
  export type TransferDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDocument
     */
    select?: TransferDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDocument
     */
    omit?: TransferDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the TransferDocument to update in case it exists.
     */
    where: TransferDocumentWhereUniqueInput
    /**
     * In case the TransferDocument found by the `where` argument doesn't exist, create a new TransferDocument with this data.
     */
    create: XOR<TransferDocumentCreateInput, TransferDocumentUncheckedCreateInput>
    /**
     * In case the TransferDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferDocumentUpdateInput, TransferDocumentUncheckedUpdateInput>
  }

  /**
   * TransferDocument delete
   */
  export type TransferDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDocument
     */
    select?: TransferDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDocument
     */
    omit?: TransferDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDocumentInclude<ExtArgs> | null
    /**
     * Filter which TransferDocument to delete.
     */
    where: TransferDocumentWhereUniqueInput
  }

  /**
   * TransferDocument deleteMany
   */
  export type TransferDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferDocuments to delete
     */
    where?: TransferDocumentWhereInput
    /**
     * Limit how many TransferDocuments to delete.
     */
    limit?: number
  }

  /**
   * TransferDocument without action
   */
  export type TransferDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferDocument
     */
    select?: TransferDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferDocument
     */
    omit?: TransferDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferDocumentInclude<ExtArgs> | null
  }


  /**
   * Model TransferItem
   */

  export type AggregateTransferItem = {
    _count: TransferItemCountAggregateOutputType | null
    _avg: TransferItemAvgAggregateOutputType | null
    _sum: TransferItemSumAggregateOutputType | null
    _min: TransferItemMinAggregateOutputType | null
    _max: TransferItemMaxAggregateOutputType | null
  }

  export type TransferItemAvgAggregateOutputType = {
    quantity: number | null
    sourceCostPrice: number | null
    sourceRetailPrice: number | null
    targetCostPrice: number | null
    targetRetailPrice: number | null
  }

  export type TransferItemSumAggregateOutputType = {
    quantity: number | null
    sourceCostPrice: number | null
    sourceRetailPrice: number | null
    targetCostPrice: number | null
    targetRetailPrice: number | null
  }

  export type TransferItemMinAggregateOutputType = {
    id: string | null
    transferId: string | null
    productId: string | null
    quantity: number | null
    sourceCostPrice: number | null
    sourceRetailPrice: number | null
    targetCostPrice: number | null
    targetRetailPrice: number | null
    condition: $Enums.ProductCondition | null
    adjustmentReason: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferItemMaxAggregateOutputType = {
    id: string | null
    transferId: string | null
    productId: string | null
    quantity: number | null
    sourceCostPrice: number | null
    sourceRetailPrice: number | null
    targetCostPrice: number | null
    targetRetailPrice: number | null
    condition: $Enums.ProductCondition | null
    adjustmentReason: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferItemCountAggregateOutputType = {
    id: number
    transferId: number
    productId: number
    quantity: number
    sourceCostPrice: number
    sourceRetailPrice: number
    targetCostPrice: number
    targetRetailPrice: number
    condition: number
    adjustmentReason: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransferItemAvgAggregateInputType = {
    quantity?: true
    sourceCostPrice?: true
    sourceRetailPrice?: true
    targetCostPrice?: true
    targetRetailPrice?: true
  }

  export type TransferItemSumAggregateInputType = {
    quantity?: true
    sourceCostPrice?: true
    sourceRetailPrice?: true
    targetCostPrice?: true
    targetRetailPrice?: true
  }

  export type TransferItemMinAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    quantity?: true
    sourceCostPrice?: true
    sourceRetailPrice?: true
    targetCostPrice?: true
    targetRetailPrice?: true
    condition?: true
    adjustmentReason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferItemMaxAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    quantity?: true
    sourceCostPrice?: true
    sourceRetailPrice?: true
    targetCostPrice?: true
    targetRetailPrice?: true
    condition?: true
    adjustmentReason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferItemCountAggregateInputType = {
    id?: true
    transferId?: true
    productId?: true
    quantity?: true
    sourceCostPrice?: true
    sourceRetailPrice?: true
    targetCostPrice?: true
    targetRetailPrice?: true
    condition?: true
    adjustmentReason?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransferItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferItem to aggregate.
     */
    where?: TransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferItems to fetch.
     */
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransferItems
    **/
    _count?: true | TransferItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferItemMaxAggregateInputType
  }

  export type GetTransferItemAggregateType<T extends TransferItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTransferItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransferItem[P]>
      : GetScalarType<T[P], AggregateTransferItem[P]>
  }




  export type TransferItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferItemWhereInput
    orderBy?: TransferItemOrderByWithAggregationInput | TransferItemOrderByWithAggregationInput[]
    by: TransferItemScalarFieldEnum[] | TransferItemScalarFieldEnum
    having?: TransferItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferItemCountAggregateInputType | true
    _avg?: TransferItemAvgAggregateInputType
    _sum?: TransferItemSumAggregateInputType
    _min?: TransferItemMinAggregateInputType
    _max?: TransferItemMaxAggregateInputType
  }

  export type TransferItemGroupByOutputType = {
    id: string
    transferId: string
    productId: string
    quantity: number
    sourceCostPrice: number
    sourceRetailPrice: number
    targetCostPrice: number
    targetRetailPrice: number
    condition: $Enums.ProductCondition
    adjustmentReason: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransferItemCountAggregateOutputType | null
    _avg: TransferItemAvgAggregateOutputType | null
    _sum: TransferItemSumAggregateOutputType | null
    _min: TransferItemMinAggregateOutputType | null
    _max: TransferItemMaxAggregateOutputType | null
  }

  type GetTransferItemGroupByPayload<T extends TransferItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferItemGroupByOutputType[P]>
            : GetScalarType<T[P], TransferItemGroupByOutputType[P]>
        }
      >
    >


  export type TransferItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    productId?: boolean
    quantity?: boolean
    sourceCostPrice?: boolean
    sourceRetailPrice?: boolean
    targetCostPrice?: boolean
    targetRetailPrice?: boolean
    condition?: boolean
    adjustmentReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferItem"]>

  export type TransferItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    productId?: boolean
    quantity?: boolean
    sourceCostPrice?: boolean
    sourceRetailPrice?: boolean
    targetCostPrice?: boolean
    targetRetailPrice?: boolean
    condition?: boolean
    adjustmentReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferItem"]>

  export type TransferItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    productId?: boolean
    quantity?: boolean
    sourceCostPrice?: boolean
    sourceRetailPrice?: boolean
    targetCostPrice?: boolean
    targetRetailPrice?: boolean
    condition?: boolean
    adjustmentReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferItem"]>

  export type TransferItemSelectScalar = {
    id?: boolean
    transferId?: boolean
    productId?: boolean
    quantity?: boolean
    sourceCostPrice?: boolean
    sourceRetailPrice?: boolean
    targetCostPrice?: boolean
    targetRetailPrice?: boolean
    condition?: boolean
    adjustmentReason?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransferItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transferId" | "productId" | "quantity" | "sourceCostPrice" | "sourceRetailPrice" | "targetCostPrice" | "targetRetailPrice" | "condition" | "adjustmentReason" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["transferItem"]>
  export type TransferItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type TransferItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type TransferItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | TransferDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $TransferItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransferItem"
    objects: {
      transfer: Prisma.$TransferPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transferId: string
      productId: string
      quantity: number
      sourceCostPrice: number
      sourceRetailPrice: number
      targetCostPrice: number
      targetRetailPrice: number
      condition: $Enums.ProductCondition
      adjustmentReason: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transferItem"]>
    composites: {}
  }

  type TransferItemGetPayload<S extends boolean | null | undefined | TransferItemDefaultArgs> = $Result.GetResult<Prisma.$TransferItemPayload, S>

  type TransferItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransferItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransferItemCountAggregateInputType | true
    }

  export interface TransferItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransferItem'], meta: { name: 'TransferItem' } }
    /**
     * Find zero or one TransferItem that matches the filter.
     * @param {TransferItemFindUniqueArgs} args - Arguments to find a TransferItem
     * @example
     * // Get one TransferItem
     * const transferItem = await prisma.transferItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferItemFindUniqueArgs>(args: SelectSubset<T, TransferItemFindUniqueArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransferItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransferItemFindUniqueOrThrowArgs} args - Arguments to find a TransferItem
     * @example
     * // Get one TransferItem
     * const transferItem = await prisma.transferItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransferItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemFindFirstArgs} args - Arguments to find a TransferItem
     * @example
     * // Get one TransferItem
     * const transferItem = await prisma.transferItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferItemFindFirstArgs>(args?: SelectSubset<T, TransferItemFindFirstArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransferItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemFindFirstOrThrowArgs} args - Arguments to find a TransferItem
     * @example
     * // Get one TransferItem
     * const transferItem = await prisma.transferItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransferItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransferItems
     * const transferItems = await prisma.transferItem.findMany()
     * 
     * // Get first 10 TransferItems
     * const transferItems = await prisma.transferItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferItemWithIdOnly = await prisma.transferItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferItemFindManyArgs>(args?: SelectSubset<T, TransferItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransferItem.
     * @param {TransferItemCreateArgs} args - Arguments to create a TransferItem.
     * @example
     * // Create one TransferItem
     * const TransferItem = await prisma.transferItem.create({
     *   data: {
     *     // ... data to create a TransferItem
     *   }
     * })
     * 
     */
    create<T extends TransferItemCreateArgs>(args: SelectSubset<T, TransferItemCreateArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransferItems.
     * @param {TransferItemCreateManyArgs} args - Arguments to create many TransferItems.
     * @example
     * // Create many TransferItems
     * const transferItem = await prisma.transferItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferItemCreateManyArgs>(args?: SelectSubset<T, TransferItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransferItems and returns the data saved in the database.
     * @param {TransferItemCreateManyAndReturnArgs} args - Arguments to create many TransferItems.
     * @example
     * // Create many TransferItems
     * const transferItem = await prisma.transferItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransferItems and only return the `id`
     * const transferItemWithIdOnly = await prisma.transferItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransferItem.
     * @param {TransferItemDeleteArgs} args - Arguments to delete one TransferItem.
     * @example
     * // Delete one TransferItem
     * const TransferItem = await prisma.transferItem.delete({
     *   where: {
     *     // ... filter to delete one TransferItem
     *   }
     * })
     * 
     */
    delete<T extends TransferItemDeleteArgs>(args: SelectSubset<T, TransferItemDeleteArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransferItem.
     * @param {TransferItemUpdateArgs} args - Arguments to update one TransferItem.
     * @example
     * // Update one TransferItem
     * const transferItem = await prisma.transferItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferItemUpdateArgs>(args: SelectSubset<T, TransferItemUpdateArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransferItems.
     * @param {TransferItemDeleteManyArgs} args - Arguments to filter TransferItems to delete.
     * @example
     * // Delete a few TransferItems
     * const { count } = await prisma.transferItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferItemDeleteManyArgs>(args?: SelectSubset<T, TransferItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransferItems
     * const transferItem = await prisma.transferItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferItemUpdateManyArgs>(args: SelectSubset<T, TransferItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferItems and returns the data updated in the database.
     * @param {TransferItemUpdateManyAndReturnArgs} args - Arguments to update many TransferItems.
     * @example
     * // Update many TransferItems
     * const transferItem = await prisma.transferItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransferItems and only return the `id`
     * const transferItemWithIdOnly = await prisma.transferItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransferItemUpdateManyAndReturnArgs>(args: SelectSubset<T, TransferItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransferItem.
     * @param {TransferItemUpsertArgs} args - Arguments to update or create a TransferItem.
     * @example
     * // Update or create a TransferItem
     * const transferItem = await prisma.transferItem.upsert({
     *   create: {
     *     // ... data to create a TransferItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransferItem we want to update
     *   }
     * })
     */
    upsert<T extends TransferItemUpsertArgs>(args: SelectSubset<T, TransferItemUpsertArgs<ExtArgs>>): Prisma__TransferItemClient<$Result.GetResult<Prisma.$TransferItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransferItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemCountArgs} args - Arguments to filter TransferItems to count.
     * @example
     * // Count the number of TransferItems
     * const count = await prisma.transferItem.count({
     *   where: {
     *     // ... the filter for the TransferItems we want to count
     *   }
     * })
    **/
    count<T extends TransferItemCountArgs>(
      args?: Subset<T, TransferItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransferItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferItemAggregateArgs>(args: Subset<T, TransferItemAggregateArgs>): Prisma.PrismaPromise<GetTransferItemAggregateType<T>>

    /**
     * Group by TransferItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferItemGroupByArgs['orderBy'] }
        : { orderBy?: TransferItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransferItem model
   */
  readonly fields: TransferItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransferItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transfer<T extends TransferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransferDefaultArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransferItem model
   */
  interface TransferItemFieldRefs {
    readonly id: FieldRef<"TransferItem", 'String'>
    readonly transferId: FieldRef<"TransferItem", 'String'>
    readonly productId: FieldRef<"TransferItem", 'String'>
    readonly quantity: FieldRef<"TransferItem", 'Int'>
    readonly sourceCostPrice: FieldRef<"TransferItem", 'Float'>
    readonly sourceRetailPrice: FieldRef<"TransferItem", 'Float'>
    readonly targetCostPrice: FieldRef<"TransferItem", 'Float'>
    readonly targetRetailPrice: FieldRef<"TransferItem", 'Float'>
    readonly condition: FieldRef<"TransferItem", 'ProductCondition'>
    readonly adjustmentReason: FieldRef<"TransferItem", 'String'>
    readonly notes: FieldRef<"TransferItem", 'String'>
    readonly createdAt: FieldRef<"TransferItem", 'DateTime'>
    readonly updatedAt: FieldRef<"TransferItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransferItem findUnique
   */
  export type TransferItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferItem to fetch.
     */
    where: TransferItemWhereUniqueInput
  }

  /**
   * TransferItem findUniqueOrThrow
   */
  export type TransferItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferItem to fetch.
     */
    where: TransferItemWhereUniqueInput
  }

  /**
   * TransferItem findFirst
   */
  export type TransferItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferItem to fetch.
     */
    where?: TransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferItems to fetch.
     */
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferItems.
     */
    cursor?: TransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferItems.
     */
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * TransferItem findFirstOrThrow
   */
  export type TransferItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferItem to fetch.
     */
    where?: TransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferItems to fetch.
     */
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferItems.
     */
    cursor?: TransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferItems.
     */
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * TransferItem findMany
   */
  export type TransferItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferItems to fetch.
     */
    where?: TransferItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferItems to fetch.
     */
    orderBy?: TransferItemOrderByWithRelationInput | TransferItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransferItems.
     */
    cursor?: TransferItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferItems.
     */
    skip?: number
    distinct?: TransferItemScalarFieldEnum | TransferItemScalarFieldEnum[]
  }

  /**
   * TransferItem create
   */
  export type TransferItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TransferItem.
     */
    data: XOR<TransferItemCreateInput, TransferItemUncheckedCreateInput>
  }

  /**
   * TransferItem createMany
   */
  export type TransferItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransferItems.
     */
    data: TransferItemCreateManyInput | TransferItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransferItem createManyAndReturn
   */
  export type TransferItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * The data used to create many TransferItems.
     */
    data: TransferItemCreateManyInput | TransferItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferItem update
   */
  export type TransferItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TransferItem.
     */
    data: XOR<TransferItemUpdateInput, TransferItemUncheckedUpdateInput>
    /**
     * Choose, which TransferItem to update.
     */
    where: TransferItemWhereUniqueInput
  }

  /**
   * TransferItem updateMany
   */
  export type TransferItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransferItems.
     */
    data: XOR<TransferItemUpdateManyMutationInput, TransferItemUncheckedUpdateManyInput>
    /**
     * Filter which TransferItems to update
     */
    where?: TransferItemWhereInput
    /**
     * Limit how many TransferItems to update.
     */
    limit?: number
  }

  /**
   * TransferItem updateManyAndReturn
   */
  export type TransferItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * The data used to update TransferItems.
     */
    data: XOR<TransferItemUpdateManyMutationInput, TransferItemUncheckedUpdateManyInput>
    /**
     * Filter which TransferItems to update
     */
    where?: TransferItemWhereInput
    /**
     * Limit how many TransferItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferItem upsert
   */
  export type TransferItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TransferItem to update in case it exists.
     */
    where: TransferItemWhereUniqueInput
    /**
     * In case the TransferItem found by the `where` argument doesn't exist, create a new TransferItem with this data.
     */
    create: XOR<TransferItemCreateInput, TransferItemUncheckedCreateInput>
    /**
     * In case the TransferItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferItemUpdateInput, TransferItemUncheckedUpdateInput>
  }

  /**
   * TransferItem delete
   */
  export type TransferItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
    /**
     * Filter which TransferItem to delete.
     */
    where: TransferItemWhereUniqueInput
  }

  /**
   * TransferItem deleteMany
   */
  export type TransferItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferItems to delete
     */
    where?: TransferItemWhereInput
    /**
     * Limit how many TransferItems to delete.
     */
    limit?: number
  }

  /**
   * TransferItem without action
   */
  export type TransferItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferItem
     */
    select?: TransferItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransferItem
     */
    omit?: TransferItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferItemInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    loyaltyPoints: number | null
  }

  export type CustomerSumAggregateOutputType = {
    loyaltyPoints: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    loyaltyPoints: number | null
    loyaltyTier: $Enums.LoyaltyTier | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    loyaltyPoints: number | null
    loyaltyTier: $Enums.LoyaltyTier | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    address: number
    loyaltyPoints: number
    loyaltyTier: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    loyaltyPoints?: true
  }

  export type CustomerSumAggregateInputType = {
    loyaltyPoints?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    loyaltyPoints?: true
    loyaltyTier?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    loyaltyPoints?: true
    loyaltyTier?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    loyaltyPoints?: true
    loyaltyTier?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string
    email: string | null
    phone: string | null
    address: string | null
    loyaltyPoints: number
    loyaltyTier: $Enums.LoyaltyTier
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    loyaltyPoints?: boolean
    loyaltyTier?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sales?: boolean | Customer$salesArgs<ExtArgs>
    returns?: boolean | Customer$returnsArgs<ExtArgs>
    addresses?: boolean | Customer$addressesArgs<ExtArgs>
    loyaltyTransactions?: boolean | Customer$loyaltyTransactionsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    loyaltyPoints?: boolean
    loyaltyTier?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    loyaltyPoints?: boolean
    loyaltyTier?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    loyaltyPoints?: boolean
    loyaltyTier?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "address" | "loyaltyPoints" | "loyaltyTier" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | Customer$salesArgs<ExtArgs>
    returns?: boolean | Customer$returnsArgs<ExtArgs>
    addresses?: boolean | Customer$addressesArgs<ExtArgs>
    loyaltyTransactions?: boolean | Customer$loyaltyTransactionsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      sales: Prisma.$SalePayload<ExtArgs>[]
      returns: Prisma.$ReturnPayload<ExtArgs>[]
      addresses: Prisma.$AddressPayload<ExtArgs>[]
      loyaltyTransactions: Prisma.$LoyaltyTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      phone: string | null
      address: string | null
      loyaltyPoints: number
      loyaltyTier: $Enums.LoyaltyTier
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sales<T extends Customer$salesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    returns<T extends Customer$returnsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$returnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addresses<T extends Customer$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    loyaltyTransactions<T extends Customer$loyaltyTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$loyaltyTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly loyaltyPoints: FieldRef<"Customer", 'Int'>
    readonly loyaltyTier: FieldRef<"Customer", 'LoyaltyTier'>
    readonly isActive: FieldRef<"Customer", 'Boolean'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.sales
   */
  export type Customer$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Customer.returns
   */
  export type Customer$returnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return
     */
    select?: ReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Return
     */
    omit?: ReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnInclude<ExtArgs> | null
    where?: ReturnWhereInput
    orderBy?: ReturnOrderByWithRelationInput | ReturnOrderByWithRelationInput[]
    cursor?: ReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnScalarFieldEnum | ReturnScalarFieldEnum[]
  }

  /**
   * Customer.addresses
   */
  export type Customer$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Customer.loyaltyTransactions
   */
  export type Customer$loyaltyTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    where?: LoyaltyTransactionWhereInput
    orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
    cursor?: LoyaltyTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoyaltyTransactionScalarFieldEnum | LoyaltyTransactionScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    type: string | null
    street: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    type: string | null
    street: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    customerId: number
    type: number
    street: number
    city: number
    state: number
    postalCode: number
    country: number
    isDefault: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    customerId?: true
    type?: true
    street?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    customerId?: true
    type?: true
    street?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    customerId?: true
    type?: true
    street?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: string
    customerId: string
    type: string
    street: string
    city: string
    state: string | null
    postalCode: string
    country: string
    isDefault: boolean
    createdAt: Date
    updatedAt: Date
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    type?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    type?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    type?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    customerId?: boolean
    type?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "type" | "street" | "city" | "state" | "postalCode" | "country" | "isDefault" | "createdAt" | "updatedAt", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      type: string
      street: string
      city: string
      state: string | null
      postalCode: string
      country: string
      isDefault: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'String'>
    readonly customerId: FieldRef<"Address", 'String'>
    readonly type: FieldRef<"Address", 'String'>
    readonly street: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly state: FieldRef<"Address", 'String'>
    readonly postalCode: FieldRef<"Address", 'String'>
    readonly country: FieldRef<"Address", 'String'>
    readonly isDefault: FieldRef<"Address", 'Boolean'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model LoyaltyProgram
   */

  export type AggregateLoyaltyProgram = {
    _count: LoyaltyProgramCountAggregateOutputType | null
    _avg: LoyaltyProgramAvgAggregateOutputType | null
    _sum: LoyaltyProgramSumAggregateOutputType | null
    _min: LoyaltyProgramMinAggregateOutputType | null
    _max: LoyaltyProgramMaxAggregateOutputType | null
  }

  export type LoyaltyProgramAvgAggregateOutputType = {
    pointsPerDollar: number | null
  }

  export type LoyaltyProgramSumAggregateOutputType = {
    pointsPerDollar: number | null
  }

  export type LoyaltyProgramMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    pointsPerDollar: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyProgramMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    pointsPerDollar: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyProgramCountAggregateOutputType = {
    id: number
    name: number
    description: number
    pointsPerDollar: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoyaltyProgramAvgAggregateInputType = {
    pointsPerDollar?: true
  }

  export type LoyaltyProgramSumAggregateInputType = {
    pointsPerDollar?: true
  }

  export type LoyaltyProgramMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pointsPerDollar?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyProgramMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pointsPerDollar?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyProgramCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    pointsPerDollar?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoyaltyProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyProgram to aggregate.
     */
    where?: LoyaltyProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyPrograms to fetch.
     */
    orderBy?: LoyaltyProgramOrderByWithRelationInput | LoyaltyProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoyaltyProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoyaltyPrograms
    **/
    _count?: true | LoyaltyProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoyaltyProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoyaltyProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoyaltyProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoyaltyProgramMaxAggregateInputType
  }

  export type GetLoyaltyProgramAggregateType<T extends LoyaltyProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateLoyaltyProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoyaltyProgram[P]>
      : GetScalarType<T[P], AggregateLoyaltyProgram[P]>
  }




  export type LoyaltyProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyProgramWhereInput
    orderBy?: LoyaltyProgramOrderByWithAggregationInput | LoyaltyProgramOrderByWithAggregationInput[]
    by: LoyaltyProgramScalarFieldEnum[] | LoyaltyProgramScalarFieldEnum
    having?: LoyaltyProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoyaltyProgramCountAggregateInputType | true
    _avg?: LoyaltyProgramAvgAggregateInputType
    _sum?: LoyaltyProgramSumAggregateInputType
    _min?: LoyaltyProgramMinAggregateInputType
    _max?: LoyaltyProgramMaxAggregateInputType
  }

  export type LoyaltyProgramGroupByOutputType = {
    id: string
    name: string
    description: string | null
    pointsPerDollar: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LoyaltyProgramCountAggregateOutputType | null
    _avg: LoyaltyProgramAvgAggregateOutputType | null
    _sum: LoyaltyProgramSumAggregateOutputType | null
    _min: LoyaltyProgramMinAggregateOutputType | null
    _max: LoyaltyProgramMaxAggregateOutputType | null
  }

  type GetLoyaltyProgramGroupByPayload<T extends LoyaltyProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoyaltyProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoyaltyProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoyaltyProgramGroupByOutputType[P]>
            : GetScalarType<T[P], LoyaltyProgramGroupByOutputType[P]>
        }
      >
    >


  export type LoyaltyProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    pointsPerDollar?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tiers?: boolean | LoyaltyProgram$tiersArgs<ExtArgs>
    transactions?: boolean | LoyaltyProgram$transactionsArgs<ExtArgs>
    _count?: boolean | LoyaltyProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyProgram"]>

  export type LoyaltyProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    pointsPerDollar?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["loyaltyProgram"]>

  export type LoyaltyProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    pointsPerDollar?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["loyaltyProgram"]>

  export type LoyaltyProgramSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    pointsPerDollar?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoyaltyProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "pointsPerDollar" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["loyaltyProgram"]>
  export type LoyaltyProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tiers?: boolean | LoyaltyProgram$tiersArgs<ExtArgs>
    transactions?: boolean | LoyaltyProgram$transactionsArgs<ExtArgs>
    _count?: boolean | LoyaltyProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LoyaltyProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LoyaltyProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LoyaltyProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoyaltyProgram"
    objects: {
      tiers: Prisma.$LoyaltyProgramTierPayload<ExtArgs>[]
      transactions: Prisma.$LoyaltyTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      pointsPerDollar: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loyaltyProgram"]>
    composites: {}
  }

  type LoyaltyProgramGetPayload<S extends boolean | null | undefined | LoyaltyProgramDefaultArgs> = $Result.GetResult<Prisma.$LoyaltyProgramPayload, S>

  type LoyaltyProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoyaltyProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoyaltyProgramCountAggregateInputType | true
    }

  export interface LoyaltyProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoyaltyProgram'], meta: { name: 'LoyaltyProgram' } }
    /**
     * Find zero or one LoyaltyProgram that matches the filter.
     * @param {LoyaltyProgramFindUniqueArgs} args - Arguments to find a LoyaltyProgram
     * @example
     * // Get one LoyaltyProgram
     * const loyaltyProgram = await prisma.loyaltyProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoyaltyProgramFindUniqueArgs>(args: SelectSubset<T, LoyaltyProgramFindUniqueArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoyaltyProgram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoyaltyProgramFindUniqueOrThrowArgs} args - Arguments to find a LoyaltyProgram
     * @example
     * // Get one LoyaltyProgram
     * const loyaltyProgram = await prisma.loyaltyProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoyaltyProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, LoyaltyProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoyaltyProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramFindFirstArgs} args - Arguments to find a LoyaltyProgram
     * @example
     * // Get one LoyaltyProgram
     * const loyaltyProgram = await prisma.loyaltyProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoyaltyProgramFindFirstArgs>(args?: SelectSubset<T, LoyaltyProgramFindFirstArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoyaltyProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramFindFirstOrThrowArgs} args - Arguments to find a LoyaltyProgram
     * @example
     * // Get one LoyaltyProgram
     * const loyaltyProgram = await prisma.loyaltyProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoyaltyProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, LoyaltyProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoyaltyPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoyaltyPrograms
     * const loyaltyPrograms = await prisma.loyaltyProgram.findMany()
     * 
     * // Get first 10 LoyaltyPrograms
     * const loyaltyPrograms = await prisma.loyaltyProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loyaltyProgramWithIdOnly = await prisma.loyaltyProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoyaltyProgramFindManyArgs>(args?: SelectSubset<T, LoyaltyProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoyaltyProgram.
     * @param {LoyaltyProgramCreateArgs} args - Arguments to create a LoyaltyProgram.
     * @example
     * // Create one LoyaltyProgram
     * const LoyaltyProgram = await prisma.loyaltyProgram.create({
     *   data: {
     *     // ... data to create a LoyaltyProgram
     *   }
     * })
     * 
     */
    create<T extends LoyaltyProgramCreateArgs>(args: SelectSubset<T, LoyaltyProgramCreateArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoyaltyPrograms.
     * @param {LoyaltyProgramCreateManyArgs} args - Arguments to create many LoyaltyPrograms.
     * @example
     * // Create many LoyaltyPrograms
     * const loyaltyProgram = await prisma.loyaltyProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoyaltyProgramCreateManyArgs>(args?: SelectSubset<T, LoyaltyProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoyaltyPrograms and returns the data saved in the database.
     * @param {LoyaltyProgramCreateManyAndReturnArgs} args - Arguments to create many LoyaltyPrograms.
     * @example
     * // Create many LoyaltyPrograms
     * const loyaltyProgram = await prisma.loyaltyProgram.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoyaltyPrograms and only return the `id`
     * const loyaltyProgramWithIdOnly = await prisma.loyaltyProgram.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoyaltyProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, LoyaltyProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoyaltyProgram.
     * @param {LoyaltyProgramDeleteArgs} args - Arguments to delete one LoyaltyProgram.
     * @example
     * // Delete one LoyaltyProgram
     * const LoyaltyProgram = await prisma.loyaltyProgram.delete({
     *   where: {
     *     // ... filter to delete one LoyaltyProgram
     *   }
     * })
     * 
     */
    delete<T extends LoyaltyProgramDeleteArgs>(args: SelectSubset<T, LoyaltyProgramDeleteArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoyaltyProgram.
     * @param {LoyaltyProgramUpdateArgs} args - Arguments to update one LoyaltyProgram.
     * @example
     * // Update one LoyaltyProgram
     * const loyaltyProgram = await prisma.loyaltyProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoyaltyProgramUpdateArgs>(args: SelectSubset<T, LoyaltyProgramUpdateArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoyaltyPrograms.
     * @param {LoyaltyProgramDeleteManyArgs} args - Arguments to filter LoyaltyPrograms to delete.
     * @example
     * // Delete a few LoyaltyPrograms
     * const { count } = await prisma.loyaltyProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoyaltyProgramDeleteManyArgs>(args?: SelectSubset<T, LoyaltyProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoyaltyPrograms
     * const loyaltyProgram = await prisma.loyaltyProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoyaltyProgramUpdateManyArgs>(args: SelectSubset<T, LoyaltyProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyPrograms and returns the data updated in the database.
     * @param {LoyaltyProgramUpdateManyAndReturnArgs} args - Arguments to update many LoyaltyPrograms.
     * @example
     * // Update many LoyaltyPrograms
     * const loyaltyProgram = await prisma.loyaltyProgram.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoyaltyPrograms and only return the `id`
     * const loyaltyProgramWithIdOnly = await prisma.loyaltyProgram.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoyaltyProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, LoyaltyProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoyaltyProgram.
     * @param {LoyaltyProgramUpsertArgs} args - Arguments to update or create a LoyaltyProgram.
     * @example
     * // Update or create a LoyaltyProgram
     * const loyaltyProgram = await prisma.loyaltyProgram.upsert({
     *   create: {
     *     // ... data to create a LoyaltyProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoyaltyProgram we want to update
     *   }
     * })
     */
    upsert<T extends LoyaltyProgramUpsertArgs>(args: SelectSubset<T, LoyaltyProgramUpsertArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoyaltyPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramCountArgs} args - Arguments to filter LoyaltyPrograms to count.
     * @example
     * // Count the number of LoyaltyPrograms
     * const count = await prisma.loyaltyProgram.count({
     *   where: {
     *     // ... the filter for the LoyaltyPrograms we want to count
     *   }
     * })
    **/
    count<T extends LoyaltyProgramCountArgs>(
      args?: Subset<T, LoyaltyProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoyaltyProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoyaltyProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoyaltyProgramAggregateArgs>(args: Subset<T, LoyaltyProgramAggregateArgs>): Prisma.PrismaPromise<GetLoyaltyProgramAggregateType<T>>

    /**
     * Group by LoyaltyProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoyaltyProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoyaltyProgramGroupByArgs['orderBy'] }
        : { orderBy?: LoyaltyProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoyaltyProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoyaltyProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoyaltyProgram model
   */
  readonly fields: LoyaltyProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoyaltyProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoyaltyProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tiers<T extends LoyaltyProgram$tiersArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyProgram$tiersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends LoyaltyProgram$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyProgram$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoyaltyProgram model
   */
  interface LoyaltyProgramFieldRefs {
    readonly id: FieldRef<"LoyaltyProgram", 'String'>
    readonly name: FieldRef<"LoyaltyProgram", 'String'>
    readonly description: FieldRef<"LoyaltyProgram", 'String'>
    readonly pointsPerDollar: FieldRef<"LoyaltyProgram", 'Float'>
    readonly isActive: FieldRef<"LoyaltyProgram", 'Boolean'>
    readonly createdAt: FieldRef<"LoyaltyProgram", 'DateTime'>
    readonly updatedAt: FieldRef<"LoyaltyProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoyaltyProgram findUnique
   */
  export type LoyaltyProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgram to fetch.
     */
    where: LoyaltyProgramWhereUniqueInput
  }

  /**
   * LoyaltyProgram findUniqueOrThrow
   */
  export type LoyaltyProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgram to fetch.
     */
    where: LoyaltyProgramWhereUniqueInput
  }

  /**
   * LoyaltyProgram findFirst
   */
  export type LoyaltyProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgram to fetch.
     */
    where?: LoyaltyProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyPrograms to fetch.
     */
    orderBy?: LoyaltyProgramOrderByWithRelationInput | LoyaltyProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyPrograms.
     */
    cursor?: LoyaltyProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyPrograms.
     */
    distinct?: LoyaltyProgramScalarFieldEnum | LoyaltyProgramScalarFieldEnum[]
  }

  /**
   * LoyaltyProgram findFirstOrThrow
   */
  export type LoyaltyProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgram to fetch.
     */
    where?: LoyaltyProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyPrograms to fetch.
     */
    orderBy?: LoyaltyProgramOrderByWithRelationInput | LoyaltyProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyPrograms.
     */
    cursor?: LoyaltyProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyPrograms.
     */
    distinct?: LoyaltyProgramScalarFieldEnum | LoyaltyProgramScalarFieldEnum[]
  }

  /**
   * LoyaltyProgram findMany
   */
  export type LoyaltyProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyPrograms to fetch.
     */
    where?: LoyaltyProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyPrograms to fetch.
     */
    orderBy?: LoyaltyProgramOrderByWithRelationInput | LoyaltyProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoyaltyPrograms.
     */
    cursor?: LoyaltyProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyPrograms.
     */
    skip?: number
    distinct?: LoyaltyProgramScalarFieldEnum | LoyaltyProgramScalarFieldEnum[]
  }

  /**
   * LoyaltyProgram create
   */
  export type LoyaltyProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a LoyaltyProgram.
     */
    data: XOR<LoyaltyProgramCreateInput, LoyaltyProgramUncheckedCreateInput>
  }

  /**
   * LoyaltyProgram createMany
   */
  export type LoyaltyProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoyaltyPrograms.
     */
    data: LoyaltyProgramCreateManyInput | LoyaltyProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoyaltyProgram createManyAndReturn
   */
  export type LoyaltyProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * The data used to create many LoyaltyPrograms.
     */
    data: LoyaltyProgramCreateManyInput | LoyaltyProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoyaltyProgram update
   */
  export type LoyaltyProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a LoyaltyProgram.
     */
    data: XOR<LoyaltyProgramUpdateInput, LoyaltyProgramUncheckedUpdateInput>
    /**
     * Choose, which LoyaltyProgram to update.
     */
    where: LoyaltyProgramWhereUniqueInput
  }

  /**
   * LoyaltyProgram updateMany
   */
  export type LoyaltyProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoyaltyPrograms.
     */
    data: XOR<LoyaltyProgramUpdateManyMutationInput, LoyaltyProgramUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyPrograms to update
     */
    where?: LoyaltyProgramWhereInput
    /**
     * Limit how many LoyaltyPrograms to update.
     */
    limit?: number
  }

  /**
   * LoyaltyProgram updateManyAndReturn
   */
  export type LoyaltyProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * The data used to update LoyaltyPrograms.
     */
    data: XOR<LoyaltyProgramUpdateManyMutationInput, LoyaltyProgramUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyPrograms to update
     */
    where?: LoyaltyProgramWhereInput
    /**
     * Limit how many LoyaltyPrograms to update.
     */
    limit?: number
  }

  /**
   * LoyaltyProgram upsert
   */
  export type LoyaltyProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the LoyaltyProgram to update in case it exists.
     */
    where: LoyaltyProgramWhereUniqueInput
    /**
     * In case the LoyaltyProgram found by the `where` argument doesn't exist, create a new LoyaltyProgram with this data.
     */
    create: XOR<LoyaltyProgramCreateInput, LoyaltyProgramUncheckedCreateInput>
    /**
     * In case the LoyaltyProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoyaltyProgramUpdateInput, LoyaltyProgramUncheckedUpdateInput>
  }

  /**
   * LoyaltyProgram delete
   */
  export type LoyaltyProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
    /**
     * Filter which LoyaltyProgram to delete.
     */
    where: LoyaltyProgramWhereUniqueInput
  }

  /**
   * LoyaltyProgram deleteMany
   */
  export type LoyaltyProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyPrograms to delete
     */
    where?: LoyaltyProgramWhereInput
    /**
     * Limit how many LoyaltyPrograms to delete.
     */
    limit?: number
  }

  /**
   * LoyaltyProgram.tiers
   */
  export type LoyaltyProgram$tiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    where?: LoyaltyProgramTierWhereInput
    orderBy?: LoyaltyProgramTierOrderByWithRelationInput | LoyaltyProgramTierOrderByWithRelationInput[]
    cursor?: LoyaltyProgramTierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoyaltyProgramTierScalarFieldEnum | LoyaltyProgramTierScalarFieldEnum[]
  }

  /**
   * LoyaltyProgram.transactions
   */
  export type LoyaltyProgram$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    where?: LoyaltyTransactionWhereInput
    orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
    cursor?: LoyaltyTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoyaltyTransactionScalarFieldEnum | LoyaltyTransactionScalarFieldEnum[]
  }

  /**
   * LoyaltyProgram without action
   */
  export type LoyaltyProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgram
     */
    select?: LoyaltyProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgram
     */
    omit?: LoyaltyProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramInclude<ExtArgs> | null
  }


  /**
   * Model LoyaltyProgramTier
   */

  export type AggregateLoyaltyProgramTier = {
    _count: LoyaltyProgramTierCountAggregateOutputType | null
    _avg: LoyaltyProgramTierAvgAggregateOutputType | null
    _sum: LoyaltyProgramTierSumAggregateOutputType | null
    _min: LoyaltyProgramTierMinAggregateOutputType | null
    _max: LoyaltyProgramTierMaxAggregateOutputType | null
  }

  export type LoyaltyProgramTierAvgAggregateOutputType = {
    requiredPoints: number | null
    pointsMultiplier: number | null
  }

  export type LoyaltyProgramTierSumAggregateOutputType = {
    requiredPoints: number | null
    pointsMultiplier: number | null
  }

  export type LoyaltyProgramTierMinAggregateOutputType = {
    id: string | null
    programId: string | null
    name: string | null
    description: string | null
    requiredPoints: number | null
    pointsMultiplier: number | null
    benefits: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyProgramTierMaxAggregateOutputType = {
    id: string | null
    programId: string | null
    name: string | null
    description: string | null
    requiredPoints: number | null
    pointsMultiplier: number | null
    benefits: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyProgramTierCountAggregateOutputType = {
    id: number
    programId: number
    name: number
    description: number
    requiredPoints: number
    pointsMultiplier: number
    benefits: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoyaltyProgramTierAvgAggregateInputType = {
    requiredPoints?: true
    pointsMultiplier?: true
  }

  export type LoyaltyProgramTierSumAggregateInputType = {
    requiredPoints?: true
    pointsMultiplier?: true
  }

  export type LoyaltyProgramTierMinAggregateInputType = {
    id?: true
    programId?: true
    name?: true
    description?: true
    requiredPoints?: true
    pointsMultiplier?: true
    benefits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyProgramTierMaxAggregateInputType = {
    id?: true
    programId?: true
    name?: true
    description?: true
    requiredPoints?: true
    pointsMultiplier?: true
    benefits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyProgramTierCountAggregateInputType = {
    id?: true
    programId?: true
    name?: true
    description?: true
    requiredPoints?: true
    pointsMultiplier?: true
    benefits?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoyaltyProgramTierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyProgramTier to aggregate.
     */
    where?: LoyaltyProgramTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyProgramTiers to fetch.
     */
    orderBy?: LoyaltyProgramTierOrderByWithRelationInput | LoyaltyProgramTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoyaltyProgramTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyProgramTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyProgramTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoyaltyProgramTiers
    **/
    _count?: true | LoyaltyProgramTierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoyaltyProgramTierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoyaltyProgramTierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoyaltyProgramTierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoyaltyProgramTierMaxAggregateInputType
  }

  export type GetLoyaltyProgramTierAggregateType<T extends LoyaltyProgramTierAggregateArgs> = {
        [P in keyof T & keyof AggregateLoyaltyProgramTier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoyaltyProgramTier[P]>
      : GetScalarType<T[P], AggregateLoyaltyProgramTier[P]>
  }




  export type LoyaltyProgramTierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyProgramTierWhereInput
    orderBy?: LoyaltyProgramTierOrderByWithAggregationInput | LoyaltyProgramTierOrderByWithAggregationInput[]
    by: LoyaltyProgramTierScalarFieldEnum[] | LoyaltyProgramTierScalarFieldEnum
    having?: LoyaltyProgramTierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoyaltyProgramTierCountAggregateInputType | true
    _avg?: LoyaltyProgramTierAvgAggregateInputType
    _sum?: LoyaltyProgramTierSumAggregateInputType
    _min?: LoyaltyProgramTierMinAggregateInputType
    _max?: LoyaltyProgramTierMaxAggregateInputType
  }

  export type LoyaltyProgramTierGroupByOutputType = {
    id: string
    programId: string
    name: string
    description: string | null
    requiredPoints: number
    pointsMultiplier: number
    benefits: string | null
    createdAt: Date
    updatedAt: Date
    _count: LoyaltyProgramTierCountAggregateOutputType | null
    _avg: LoyaltyProgramTierAvgAggregateOutputType | null
    _sum: LoyaltyProgramTierSumAggregateOutputType | null
    _min: LoyaltyProgramTierMinAggregateOutputType | null
    _max: LoyaltyProgramTierMaxAggregateOutputType | null
  }

  type GetLoyaltyProgramTierGroupByPayload<T extends LoyaltyProgramTierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoyaltyProgramTierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoyaltyProgramTierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoyaltyProgramTierGroupByOutputType[P]>
            : GetScalarType<T[P], LoyaltyProgramTierGroupByOutputType[P]>
        }
      >
    >


  export type LoyaltyProgramTierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    name?: boolean
    description?: boolean
    requiredPoints?: boolean
    pointsMultiplier?: boolean
    benefits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyProgramTier"]>

  export type LoyaltyProgramTierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    name?: boolean
    description?: boolean
    requiredPoints?: boolean
    pointsMultiplier?: boolean
    benefits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyProgramTier"]>

  export type LoyaltyProgramTierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    name?: boolean
    description?: boolean
    requiredPoints?: boolean
    pointsMultiplier?: boolean
    benefits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyProgramTier"]>

  export type LoyaltyProgramTierSelectScalar = {
    id?: boolean
    programId?: boolean
    name?: boolean
    description?: boolean
    requiredPoints?: boolean
    pointsMultiplier?: boolean
    benefits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoyaltyProgramTierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "programId" | "name" | "description" | "requiredPoints" | "pointsMultiplier" | "benefits" | "createdAt" | "updatedAt", ExtArgs["result"]["loyaltyProgramTier"]>
  export type LoyaltyProgramTierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }
  export type LoyaltyProgramTierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }
  export type LoyaltyProgramTierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }

  export type $LoyaltyProgramTierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoyaltyProgramTier"
    objects: {
      program: Prisma.$LoyaltyProgramPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      programId: string
      name: string
      description: string | null
      requiredPoints: number
      pointsMultiplier: number
      benefits: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loyaltyProgramTier"]>
    composites: {}
  }

  type LoyaltyProgramTierGetPayload<S extends boolean | null | undefined | LoyaltyProgramTierDefaultArgs> = $Result.GetResult<Prisma.$LoyaltyProgramTierPayload, S>

  type LoyaltyProgramTierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoyaltyProgramTierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoyaltyProgramTierCountAggregateInputType | true
    }

  export interface LoyaltyProgramTierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoyaltyProgramTier'], meta: { name: 'LoyaltyProgramTier' } }
    /**
     * Find zero or one LoyaltyProgramTier that matches the filter.
     * @param {LoyaltyProgramTierFindUniqueArgs} args - Arguments to find a LoyaltyProgramTier
     * @example
     * // Get one LoyaltyProgramTier
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoyaltyProgramTierFindUniqueArgs>(args: SelectSubset<T, LoyaltyProgramTierFindUniqueArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoyaltyProgramTier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoyaltyProgramTierFindUniqueOrThrowArgs} args - Arguments to find a LoyaltyProgramTier
     * @example
     * // Get one LoyaltyProgramTier
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoyaltyProgramTierFindUniqueOrThrowArgs>(args: SelectSubset<T, LoyaltyProgramTierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoyaltyProgramTier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramTierFindFirstArgs} args - Arguments to find a LoyaltyProgramTier
     * @example
     * // Get one LoyaltyProgramTier
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoyaltyProgramTierFindFirstArgs>(args?: SelectSubset<T, LoyaltyProgramTierFindFirstArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoyaltyProgramTier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramTierFindFirstOrThrowArgs} args - Arguments to find a LoyaltyProgramTier
     * @example
     * // Get one LoyaltyProgramTier
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoyaltyProgramTierFindFirstOrThrowArgs>(args?: SelectSubset<T, LoyaltyProgramTierFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoyaltyProgramTiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramTierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoyaltyProgramTiers
     * const loyaltyProgramTiers = await prisma.loyaltyProgramTier.findMany()
     * 
     * // Get first 10 LoyaltyProgramTiers
     * const loyaltyProgramTiers = await prisma.loyaltyProgramTier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loyaltyProgramTierWithIdOnly = await prisma.loyaltyProgramTier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoyaltyProgramTierFindManyArgs>(args?: SelectSubset<T, LoyaltyProgramTierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoyaltyProgramTier.
     * @param {LoyaltyProgramTierCreateArgs} args - Arguments to create a LoyaltyProgramTier.
     * @example
     * // Create one LoyaltyProgramTier
     * const LoyaltyProgramTier = await prisma.loyaltyProgramTier.create({
     *   data: {
     *     // ... data to create a LoyaltyProgramTier
     *   }
     * })
     * 
     */
    create<T extends LoyaltyProgramTierCreateArgs>(args: SelectSubset<T, LoyaltyProgramTierCreateArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoyaltyProgramTiers.
     * @param {LoyaltyProgramTierCreateManyArgs} args - Arguments to create many LoyaltyProgramTiers.
     * @example
     * // Create many LoyaltyProgramTiers
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoyaltyProgramTierCreateManyArgs>(args?: SelectSubset<T, LoyaltyProgramTierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoyaltyProgramTiers and returns the data saved in the database.
     * @param {LoyaltyProgramTierCreateManyAndReturnArgs} args - Arguments to create many LoyaltyProgramTiers.
     * @example
     * // Create many LoyaltyProgramTiers
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoyaltyProgramTiers and only return the `id`
     * const loyaltyProgramTierWithIdOnly = await prisma.loyaltyProgramTier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoyaltyProgramTierCreateManyAndReturnArgs>(args?: SelectSubset<T, LoyaltyProgramTierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoyaltyProgramTier.
     * @param {LoyaltyProgramTierDeleteArgs} args - Arguments to delete one LoyaltyProgramTier.
     * @example
     * // Delete one LoyaltyProgramTier
     * const LoyaltyProgramTier = await prisma.loyaltyProgramTier.delete({
     *   where: {
     *     // ... filter to delete one LoyaltyProgramTier
     *   }
     * })
     * 
     */
    delete<T extends LoyaltyProgramTierDeleteArgs>(args: SelectSubset<T, LoyaltyProgramTierDeleteArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoyaltyProgramTier.
     * @param {LoyaltyProgramTierUpdateArgs} args - Arguments to update one LoyaltyProgramTier.
     * @example
     * // Update one LoyaltyProgramTier
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoyaltyProgramTierUpdateArgs>(args: SelectSubset<T, LoyaltyProgramTierUpdateArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoyaltyProgramTiers.
     * @param {LoyaltyProgramTierDeleteManyArgs} args - Arguments to filter LoyaltyProgramTiers to delete.
     * @example
     * // Delete a few LoyaltyProgramTiers
     * const { count } = await prisma.loyaltyProgramTier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoyaltyProgramTierDeleteManyArgs>(args?: SelectSubset<T, LoyaltyProgramTierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyProgramTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramTierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoyaltyProgramTiers
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoyaltyProgramTierUpdateManyArgs>(args: SelectSubset<T, LoyaltyProgramTierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyProgramTiers and returns the data updated in the database.
     * @param {LoyaltyProgramTierUpdateManyAndReturnArgs} args - Arguments to update many LoyaltyProgramTiers.
     * @example
     * // Update many LoyaltyProgramTiers
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoyaltyProgramTiers and only return the `id`
     * const loyaltyProgramTierWithIdOnly = await prisma.loyaltyProgramTier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoyaltyProgramTierUpdateManyAndReturnArgs>(args: SelectSubset<T, LoyaltyProgramTierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoyaltyProgramTier.
     * @param {LoyaltyProgramTierUpsertArgs} args - Arguments to update or create a LoyaltyProgramTier.
     * @example
     * // Update or create a LoyaltyProgramTier
     * const loyaltyProgramTier = await prisma.loyaltyProgramTier.upsert({
     *   create: {
     *     // ... data to create a LoyaltyProgramTier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoyaltyProgramTier we want to update
     *   }
     * })
     */
    upsert<T extends LoyaltyProgramTierUpsertArgs>(args: SelectSubset<T, LoyaltyProgramTierUpsertArgs<ExtArgs>>): Prisma__LoyaltyProgramTierClient<$Result.GetResult<Prisma.$LoyaltyProgramTierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoyaltyProgramTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramTierCountArgs} args - Arguments to filter LoyaltyProgramTiers to count.
     * @example
     * // Count the number of LoyaltyProgramTiers
     * const count = await prisma.loyaltyProgramTier.count({
     *   where: {
     *     // ... the filter for the LoyaltyProgramTiers we want to count
     *   }
     * })
    **/
    count<T extends LoyaltyProgramTierCountArgs>(
      args?: Subset<T, LoyaltyProgramTierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoyaltyProgramTierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoyaltyProgramTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramTierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoyaltyProgramTierAggregateArgs>(args: Subset<T, LoyaltyProgramTierAggregateArgs>): Prisma.PrismaPromise<GetLoyaltyProgramTierAggregateType<T>>

    /**
     * Group by LoyaltyProgramTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyProgramTierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoyaltyProgramTierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoyaltyProgramTierGroupByArgs['orderBy'] }
        : { orderBy?: LoyaltyProgramTierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoyaltyProgramTierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoyaltyProgramTierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoyaltyProgramTier model
   */
  readonly fields: LoyaltyProgramTierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoyaltyProgramTier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoyaltyProgramTierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends LoyaltyProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyProgramDefaultArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoyaltyProgramTier model
   */
  interface LoyaltyProgramTierFieldRefs {
    readonly id: FieldRef<"LoyaltyProgramTier", 'String'>
    readonly programId: FieldRef<"LoyaltyProgramTier", 'String'>
    readonly name: FieldRef<"LoyaltyProgramTier", 'String'>
    readonly description: FieldRef<"LoyaltyProgramTier", 'String'>
    readonly requiredPoints: FieldRef<"LoyaltyProgramTier", 'Int'>
    readonly pointsMultiplier: FieldRef<"LoyaltyProgramTier", 'Float'>
    readonly benefits: FieldRef<"LoyaltyProgramTier", 'String'>
    readonly createdAt: FieldRef<"LoyaltyProgramTier", 'DateTime'>
    readonly updatedAt: FieldRef<"LoyaltyProgramTier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoyaltyProgramTier findUnique
   */
  export type LoyaltyProgramTierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgramTier to fetch.
     */
    where: LoyaltyProgramTierWhereUniqueInput
  }

  /**
   * LoyaltyProgramTier findUniqueOrThrow
   */
  export type LoyaltyProgramTierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgramTier to fetch.
     */
    where: LoyaltyProgramTierWhereUniqueInput
  }

  /**
   * LoyaltyProgramTier findFirst
   */
  export type LoyaltyProgramTierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgramTier to fetch.
     */
    where?: LoyaltyProgramTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyProgramTiers to fetch.
     */
    orderBy?: LoyaltyProgramTierOrderByWithRelationInput | LoyaltyProgramTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyProgramTiers.
     */
    cursor?: LoyaltyProgramTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyProgramTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyProgramTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyProgramTiers.
     */
    distinct?: LoyaltyProgramTierScalarFieldEnum | LoyaltyProgramTierScalarFieldEnum[]
  }

  /**
   * LoyaltyProgramTier findFirstOrThrow
   */
  export type LoyaltyProgramTierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgramTier to fetch.
     */
    where?: LoyaltyProgramTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyProgramTiers to fetch.
     */
    orderBy?: LoyaltyProgramTierOrderByWithRelationInput | LoyaltyProgramTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyProgramTiers.
     */
    cursor?: LoyaltyProgramTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyProgramTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyProgramTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyProgramTiers.
     */
    distinct?: LoyaltyProgramTierScalarFieldEnum | LoyaltyProgramTierScalarFieldEnum[]
  }

  /**
   * LoyaltyProgramTier findMany
   */
  export type LoyaltyProgramTierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyProgramTiers to fetch.
     */
    where?: LoyaltyProgramTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyProgramTiers to fetch.
     */
    orderBy?: LoyaltyProgramTierOrderByWithRelationInput | LoyaltyProgramTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoyaltyProgramTiers.
     */
    cursor?: LoyaltyProgramTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyProgramTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyProgramTiers.
     */
    skip?: number
    distinct?: LoyaltyProgramTierScalarFieldEnum | LoyaltyProgramTierScalarFieldEnum[]
  }

  /**
   * LoyaltyProgramTier create
   */
  export type LoyaltyProgramTierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * The data needed to create a LoyaltyProgramTier.
     */
    data: XOR<LoyaltyProgramTierCreateInput, LoyaltyProgramTierUncheckedCreateInput>
  }

  /**
   * LoyaltyProgramTier createMany
   */
  export type LoyaltyProgramTierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoyaltyProgramTiers.
     */
    data: LoyaltyProgramTierCreateManyInput | LoyaltyProgramTierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoyaltyProgramTier createManyAndReturn
   */
  export type LoyaltyProgramTierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * The data used to create many LoyaltyProgramTiers.
     */
    data: LoyaltyProgramTierCreateManyInput | LoyaltyProgramTierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoyaltyProgramTier update
   */
  export type LoyaltyProgramTierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * The data needed to update a LoyaltyProgramTier.
     */
    data: XOR<LoyaltyProgramTierUpdateInput, LoyaltyProgramTierUncheckedUpdateInput>
    /**
     * Choose, which LoyaltyProgramTier to update.
     */
    where: LoyaltyProgramTierWhereUniqueInput
  }

  /**
   * LoyaltyProgramTier updateMany
   */
  export type LoyaltyProgramTierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoyaltyProgramTiers.
     */
    data: XOR<LoyaltyProgramTierUpdateManyMutationInput, LoyaltyProgramTierUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyProgramTiers to update
     */
    where?: LoyaltyProgramTierWhereInput
    /**
     * Limit how many LoyaltyProgramTiers to update.
     */
    limit?: number
  }

  /**
   * LoyaltyProgramTier updateManyAndReturn
   */
  export type LoyaltyProgramTierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * The data used to update LoyaltyProgramTiers.
     */
    data: XOR<LoyaltyProgramTierUpdateManyMutationInput, LoyaltyProgramTierUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyProgramTiers to update
     */
    where?: LoyaltyProgramTierWhereInput
    /**
     * Limit how many LoyaltyProgramTiers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoyaltyProgramTier upsert
   */
  export type LoyaltyProgramTierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * The filter to search for the LoyaltyProgramTier to update in case it exists.
     */
    where: LoyaltyProgramTierWhereUniqueInput
    /**
     * In case the LoyaltyProgramTier found by the `where` argument doesn't exist, create a new LoyaltyProgramTier with this data.
     */
    create: XOR<LoyaltyProgramTierCreateInput, LoyaltyProgramTierUncheckedCreateInput>
    /**
     * In case the LoyaltyProgramTier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoyaltyProgramTierUpdateInput, LoyaltyProgramTierUncheckedUpdateInput>
  }

  /**
   * LoyaltyProgramTier delete
   */
  export type LoyaltyProgramTierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
    /**
     * Filter which LoyaltyProgramTier to delete.
     */
    where: LoyaltyProgramTierWhereUniqueInput
  }

  /**
   * LoyaltyProgramTier deleteMany
   */
  export type LoyaltyProgramTierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyProgramTiers to delete
     */
    where?: LoyaltyProgramTierWhereInput
    /**
     * Limit how many LoyaltyProgramTiers to delete.
     */
    limit?: number
  }

  /**
   * LoyaltyProgramTier without action
   */
  export type LoyaltyProgramTierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyProgramTier
     */
    select?: LoyaltyProgramTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyProgramTier
     */
    omit?: LoyaltyProgramTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyProgramTierInclude<ExtArgs> | null
  }


  /**
   * Model LoyaltyTransaction
   */

  export type AggregateLoyaltyTransaction = {
    _count: LoyaltyTransactionCountAggregateOutputType | null
    _avg: LoyaltyTransactionAvgAggregateOutputType | null
    _sum: LoyaltyTransactionSumAggregateOutputType | null
    _min: LoyaltyTransactionMinAggregateOutputType | null
    _max: LoyaltyTransactionMaxAggregateOutputType | null
  }

  export type LoyaltyTransactionAvgAggregateOutputType = {
    points: number | null
  }

  export type LoyaltyTransactionSumAggregateOutputType = {
    points: number | null
  }

  export type LoyaltyTransactionMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    programId: string | null
    points: number | null
    type: $Enums.LoyaltyTransactionType | null
    description: string | null
    referenceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyTransactionMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    programId: string | null
    points: number | null
    type: $Enums.LoyaltyTransactionType | null
    description: string | null
    referenceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoyaltyTransactionCountAggregateOutputType = {
    id: number
    customerId: number
    programId: number
    points: number
    type: number
    description: number
    referenceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoyaltyTransactionAvgAggregateInputType = {
    points?: true
  }

  export type LoyaltyTransactionSumAggregateInputType = {
    points?: true
  }

  export type LoyaltyTransactionMinAggregateInputType = {
    id?: true
    customerId?: true
    programId?: true
    points?: true
    type?: true
    description?: true
    referenceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyTransactionMaxAggregateInputType = {
    id?: true
    customerId?: true
    programId?: true
    points?: true
    type?: true
    description?: true
    referenceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoyaltyTransactionCountAggregateInputType = {
    id?: true
    customerId?: true
    programId?: true
    points?: true
    type?: true
    description?: true
    referenceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoyaltyTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyTransaction to aggregate.
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTransactions to fetch.
     */
    orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoyaltyTransactions
    **/
    _count?: true | LoyaltyTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoyaltyTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoyaltyTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoyaltyTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoyaltyTransactionMaxAggregateInputType
  }

  export type GetLoyaltyTransactionAggregateType<T extends LoyaltyTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateLoyaltyTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoyaltyTransaction[P]>
      : GetScalarType<T[P], AggregateLoyaltyTransaction[P]>
  }




  export type LoyaltyTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoyaltyTransactionWhereInput
    orderBy?: LoyaltyTransactionOrderByWithAggregationInput | LoyaltyTransactionOrderByWithAggregationInput[]
    by: LoyaltyTransactionScalarFieldEnum[] | LoyaltyTransactionScalarFieldEnum
    having?: LoyaltyTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoyaltyTransactionCountAggregateInputType | true
    _avg?: LoyaltyTransactionAvgAggregateInputType
    _sum?: LoyaltyTransactionSumAggregateInputType
    _min?: LoyaltyTransactionMinAggregateInputType
    _max?: LoyaltyTransactionMaxAggregateInputType
  }

  export type LoyaltyTransactionGroupByOutputType = {
    id: string
    customerId: string
    programId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description: string | null
    referenceId: string | null
    createdAt: Date
    updatedAt: Date
    _count: LoyaltyTransactionCountAggregateOutputType | null
    _avg: LoyaltyTransactionAvgAggregateOutputType | null
    _sum: LoyaltyTransactionSumAggregateOutputType | null
    _min: LoyaltyTransactionMinAggregateOutputType | null
    _max: LoyaltyTransactionMaxAggregateOutputType | null
  }

  type GetLoyaltyTransactionGroupByPayload<T extends LoyaltyTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoyaltyTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoyaltyTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoyaltyTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], LoyaltyTransactionGroupByOutputType[P]>
        }
      >
    >


  export type LoyaltyTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    programId?: boolean
    points?: boolean
    type?: boolean
    description?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyTransaction"]>

  export type LoyaltyTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    programId?: boolean
    points?: boolean
    type?: boolean
    description?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyTransaction"]>

  export type LoyaltyTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    programId?: boolean
    points?: boolean
    type?: boolean
    description?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loyaltyTransaction"]>

  export type LoyaltyTransactionSelectScalar = {
    id?: boolean
    customerId?: boolean
    programId?: boolean
    points?: boolean
    type?: boolean
    description?: boolean
    referenceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoyaltyTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "programId" | "points" | "type" | "description" | "referenceId" | "createdAt" | "updatedAt", ExtArgs["result"]["loyaltyTransaction"]>
  export type LoyaltyTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }
  export type LoyaltyTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }
  export type LoyaltyTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    program?: boolean | LoyaltyProgramDefaultArgs<ExtArgs>
  }

  export type $LoyaltyTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoyaltyTransaction"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      program: Prisma.$LoyaltyProgramPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      programId: string
      points: number
      type: $Enums.LoyaltyTransactionType
      description: string | null
      referenceId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loyaltyTransaction"]>
    composites: {}
  }

  type LoyaltyTransactionGetPayload<S extends boolean | null | undefined | LoyaltyTransactionDefaultArgs> = $Result.GetResult<Prisma.$LoyaltyTransactionPayload, S>

  type LoyaltyTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoyaltyTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoyaltyTransactionCountAggregateInputType | true
    }

  export interface LoyaltyTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoyaltyTransaction'], meta: { name: 'LoyaltyTransaction' } }
    /**
     * Find zero or one LoyaltyTransaction that matches the filter.
     * @param {LoyaltyTransactionFindUniqueArgs} args - Arguments to find a LoyaltyTransaction
     * @example
     * // Get one LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoyaltyTransactionFindUniqueArgs>(args: SelectSubset<T, LoyaltyTransactionFindUniqueArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoyaltyTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoyaltyTransactionFindUniqueOrThrowArgs} args - Arguments to find a LoyaltyTransaction
     * @example
     * // Get one LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoyaltyTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, LoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoyaltyTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionFindFirstArgs} args - Arguments to find a LoyaltyTransaction
     * @example
     * // Get one LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoyaltyTransactionFindFirstArgs>(args?: SelectSubset<T, LoyaltyTransactionFindFirstArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoyaltyTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionFindFirstOrThrowArgs} args - Arguments to find a LoyaltyTransaction
     * @example
     * // Get one LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoyaltyTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, LoyaltyTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoyaltyTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoyaltyTransactions
     * const loyaltyTransactions = await prisma.loyaltyTransaction.findMany()
     * 
     * // Get first 10 LoyaltyTransactions
     * const loyaltyTransactions = await prisma.loyaltyTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loyaltyTransactionWithIdOnly = await prisma.loyaltyTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoyaltyTransactionFindManyArgs>(args?: SelectSubset<T, LoyaltyTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoyaltyTransaction.
     * @param {LoyaltyTransactionCreateArgs} args - Arguments to create a LoyaltyTransaction.
     * @example
     * // Create one LoyaltyTransaction
     * const LoyaltyTransaction = await prisma.loyaltyTransaction.create({
     *   data: {
     *     // ... data to create a LoyaltyTransaction
     *   }
     * })
     * 
     */
    create<T extends LoyaltyTransactionCreateArgs>(args: SelectSubset<T, LoyaltyTransactionCreateArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoyaltyTransactions.
     * @param {LoyaltyTransactionCreateManyArgs} args - Arguments to create many LoyaltyTransactions.
     * @example
     * // Create many LoyaltyTransactions
     * const loyaltyTransaction = await prisma.loyaltyTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoyaltyTransactionCreateManyArgs>(args?: SelectSubset<T, LoyaltyTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoyaltyTransactions and returns the data saved in the database.
     * @param {LoyaltyTransactionCreateManyAndReturnArgs} args - Arguments to create many LoyaltyTransactions.
     * @example
     * // Create many LoyaltyTransactions
     * const loyaltyTransaction = await prisma.loyaltyTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoyaltyTransactions and only return the `id`
     * const loyaltyTransactionWithIdOnly = await prisma.loyaltyTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoyaltyTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, LoyaltyTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoyaltyTransaction.
     * @param {LoyaltyTransactionDeleteArgs} args - Arguments to delete one LoyaltyTransaction.
     * @example
     * // Delete one LoyaltyTransaction
     * const LoyaltyTransaction = await prisma.loyaltyTransaction.delete({
     *   where: {
     *     // ... filter to delete one LoyaltyTransaction
     *   }
     * })
     * 
     */
    delete<T extends LoyaltyTransactionDeleteArgs>(args: SelectSubset<T, LoyaltyTransactionDeleteArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoyaltyTransaction.
     * @param {LoyaltyTransactionUpdateArgs} args - Arguments to update one LoyaltyTransaction.
     * @example
     * // Update one LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoyaltyTransactionUpdateArgs>(args: SelectSubset<T, LoyaltyTransactionUpdateArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoyaltyTransactions.
     * @param {LoyaltyTransactionDeleteManyArgs} args - Arguments to filter LoyaltyTransactions to delete.
     * @example
     * // Delete a few LoyaltyTransactions
     * const { count } = await prisma.loyaltyTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoyaltyTransactionDeleteManyArgs>(args?: SelectSubset<T, LoyaltyTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoyaltyTransactions
     * const loyaltyTransaction = await prisma.loyaltyTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoyaltyTransactionUpdateManyArgs>(args: SelectSubset<T, LoyaltyTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoyaltyTransactions and returns the data updated in the database.
     * @param {LoyaltyTransactionUpdateManyAndReturnArgs} args - Arguments to update many LoyaltyTransactions.
     * @example
     * // Update many LoyaltyTransactions
     * const loyaltyTransaction = await prisma.loyaltyTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoyaltyTransactions and only return the `id`
     * const loyaltyTransactionWithIdOnly = await prisma.loyaltyTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoyaltyTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, LoyaltyTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoyaltyTransaction.
     * @param {LoyaltyTransactionUpsertArgs} args - Arguments to update or create a LoyaltyTransaction.
     * @example
     * // Update or create a LoyaltyTransaction
     * const loyaltyTransaction = await prisma.loyaltyTransaction.upsert({
     *   create: {
     *     // ... data to create a LoyaltyTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoyaltyTransaction we want to update
     *   }
     * })
     */
    upsert<T extends LoyaltyTransactionUpsertArgs>(args: SelectSubset<T, LoyaltyTransactionUpsertArgs<ExtArgs>>): Prisma__LoyaltyTransactionClient<$Result.GetResult<Prisma.$LoyaltyTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoyaltyTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionCountArgs} args - Arguments to filter LoyaltyTransactions to count.
     * @example
     * // Count the number of LoyaltyTransactions
     * const count = await prisma.loyaltyTransaction.count({
     *   where: {
     *     // ... the filter for the LoyaltyTransactions we want to count
     *   }
     * })
    **/
    count<T extends LoyaltyTransactionCountArgs>(
      args?: Subset<T, LoyaltyTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoyaltyTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoyaltyTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoyaltyTransactionAggregateArgs>(args: Subset<T, LoyaltyTransactionAggregateArgs>): Prisma.PrismaPromise<GetLoyaltyTransactionAggregateType<T>>

    /**
     * Group by LoyaltyTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoyaltyTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoyaltyTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoyaltyTransactionGroupByArgs['orderBy'] }
        : { orderBy?: LoyaltyTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoyaltyTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoyaltyTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoyaltyTransaction model
   */
  readonly fields: LoyaltyTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoyaltyTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoyaltyTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    program<T extends LoyaltyProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoyaltyProgramDefaultArgs<ExtArgs>>): Prisma__LoyaltyProgramClient<$Result.GetResult<Prisma.$LoyaltyProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoyaltyTransaction model
   */
  interface LoyaltyTransactionFieldRefs {
    readonly id: FieldRef<"LoyaltyTransaction", 'String'>
    readonly customerId: FieldRef<"LoyaltyTransaction", 'String'>
    readonly programId: FieldRef<"LoyaltyTransaction", 'String'>
    readonly points: FieldRef<"LoyaltyTransaction", 'Int'>
    readonly type: FieldRef<"LoyaltyTransaction", 'LoyaltyTransactionType'>
    readonly description: FieldRef<"LoyaltyTransaction", 'String'>
    readonly referenceId: FieldRef<"LoyaltyTransaction", 'String'>
    readonly createdAt: FieldRef<"LoyaltyTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"LoyaltyTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoyaltyTransaction findUnique
   */
  export type LoyaltyTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTransaction to fetch.
     */
    where: LoyaltyTransactionWhereUniqueInput
  }

  /**
   * LoyaltyTransaction findUniqueOrThrow
   */
  export type LoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTransaction to fetch.
     */
    where: LoyaltyTransactionWhereUniqueInput
  }

  /**
   * LoyaltyTransaction findFirst
   */
  export type LoyaltyTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTransaction to fetch.
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTransactions to fetch.
     */
    orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyTransactions.
     */
    cursor?: LoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyTransactions.
     */
    distinct?: LoyaltyTransactionScalarFieldEnum | LoyaltyTransactionScalarFieldEnum[]
  }

  /**
   * LoyaltyTransaction findFirstOrThrow
   */
  export type LoyaltyTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTransaction to fetch.
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTransactions to fetch.
     */
    orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoyaltyTransactions.
     */
    cursor?: LoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoyaltyTransactions.
     */
    distinct?: LoyaltyTransactionScalarFieldEnum | LoyaltyTransactionScalarFieldEnum[]
  }

  /**
   * LoyaltyTransaction findMany
   */
  export type LoyaltyTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which LoyaltyTransactions to fetch.
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoyaltyTransactions to fetch.
     */
    orderBy?: LoyaltyTransactionOrderByWithRelationInput | LoyaltyTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoyaltyTransactions.
     */
    cursor?: LoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoyaltyTransactions.
     */
    skip?: number
    distinct?: LoyaltyTransactionScalarFieldEnum | LoyaltyTransactionScalarFieldEnum[]
  }

  /**
   * LoyaltyTransaction create
   */
  export type LoyaltyTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a LoyaltyTransaction.
     */
    data: XOR<LoyaltyTransactionCreateInput, LoyaltyTransactionUncheckedCreateInput>
  }

  /**
   * LoyaltyTransaction createMany
   */
  export type LoyaltyTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoyaltyTransactions.
     */
    data: LoyaltyTransactionCreateManyInput | LoyaltyTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoyaltyTransaction createManyAndReturn
   */
  export type LoyaltyTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many LoyaltyTransactions.
     */
    data: LoyaltyTransactionCreateManyInput | LoyaltyTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoyaltyTransaction update
   */
  export type LoyaltyTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a LoyaltyTransaction.
     */
    data: XOR<LoyaltyTransactionUpdateInput, LoyaltyTransactionUncheckedUpdateInput>
    /**
     * Choose, which LoyaltyTransaction to update.
     */
    where: LoyaltyTransactionWhereUniqueInput
  }

  /**
   * LoyaltyTransaction updateMany
   */
  export type LoyaltyTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoyaltyTransactions.
     */
    data: XOR<LoyaltyTransactionUpdateManyMutationInput, LoyaltyTransactionUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyTransactions to update
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * Limit how many LoyaltyTransactions to update.
     */
    limit?: number
  }

  /**
   * LoyaltyTransaction updateManyAndReturn
   */
  export type LoyaltyTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * The data used to update LoyaltyTransactions.
     */
    data: XOR<LoyaltyTransactionUpdateManyMutationInput, LoyaltyTransactionUncheckedUpdateManyInput>
    /**
     * Filter which LoyaltyTransactions to update
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * Limit how many LoyaltyTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoyaltyTransaction upsert
   */
  export type LoyaltyTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the LoyaltyTransaction to update in case it exists.
     */
    where: LoyaltyTransactionWhereUniqueInput
    /**
     * In case the LoyaltyTransaction found by the `where` argument doesn't exist, create a new LoyaltyTransaction with this data.
     */
    create: XOR<LoyaltyTransactionCreateInput, LoyaltyTransactionUncheckedCreateInput>
    /**
     * In case the LoyaltyTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoyaltyTransactionUpdateInput, LoyaltyTransactionUncheckedUpdateInput>
  }

  /**
   * LoyaltyTransaction delete
   */
  export type LoyaltyTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter which LoyaltyTransaction to delete.
     */
    where: LoyaltyTransactionWhereUniqueInput
  }

  /**
   * LoyaltyTransaction deleteMany
   */
  export type LoyaltyTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoyaltyTransactions to delete
     */
    where?: LoyaltyTransactionWhereInput
    /**
     * Limit how many LoyaltyTransactions to delete.
     */
    limit?: number
  }

  /**
   * LoyaltyTransaction without action
   */
  export type LoyaltyTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoyaltyTransaction
     */
    select?: LoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoyaltyTransaction
     */
    omit?: LoyaltyTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoyaltyTransactionInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    action: $Enums.AuditAction | null
    userId: string | null
    userName: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    action: $Enums.AuditAction | null
    userId: string | null
    userName: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    action: number
    userId: number
    userName: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    userId?: true
    userName?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    userId?: true
    userName?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    userId?: true
    userName?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    entityType: string
    entityId: string
    action: $Enums.AuditAction
    userId: string | null
    userName: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    userId?: boolean
    userName?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    userId?: boolean
    userName?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    userId?: boolean
    userName?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    userId?: boolean
    userName?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "action" | "userId" | "userName" | "details" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string
      action: $Enums.AuditAction
      userId: string | null
      userName: string | null
      details: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'AuditAction'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly userName: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
  }


  /**
   * Model Audit
   */

  export type AggregateAudit = {
    _count: AuditCountAggregateOutputType | null
    _min: AuditMinAggregateOutputType | null
    _max: AuditMaxAggregateOutputType | null
  }

  export type AuditMinAggregateOutputType = {
    id: string | null
    referenceNumber: string | null
    warehouseId: string | null
    status: $Enums.AuditStatus | null
    startDate: Date | null
    endDate: Date | null
    completedDate: Date | null
    notes: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditMaxAggregateOutputType = {
    id: string | null
    referenceNumber: string | null
    warehouseId: string | null
    status: $Enums.AuditStatus | null
    startDate: Date | null
    endDate: Date | null
    completedDate: Date | null
    notes: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditCountAggregateOutputType = {
    id: number
    referenceNumber: number
    warehouseId: number
    status: number
    startDate: number
    endDate: number
    completedDate: number
    notes: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditMinAggregateInputType = {
    id?: true
    referenceNumber?: true
    warehouseId?: true
    status?: true
    startDate?: true
    endDate?: true
    completedDate?: true
    notes?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditMaxAggregateInputType = {
    id?: true
    referenceNumber?: true
    warehouseId?: true
    status?: true
    startDate?: true
    endDate?: true
    completedDate?: true
    notes?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditCountAggregateInputType = {
    id?: true
    referenceNumber?: true
    warehouseId?: true
    status?: true
    startDate?: true
    endDate?: true
    completedDate?: true
    notes?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Audit to aggregate.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Audits
    **/
    _count?: true | AuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditMaxAggregateInputType
  }

  export type GetAuditAggregateType<T extends AuditAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit[P]>
      : GetScalarType<T[P], AggregateAudit[P]>
  }




  export type AuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditWhereInput
    orderBy?: AuditOrderByWithAggregationInput | AuditOrderByWithAggregationInput[]
    by: AuditScalarFieldEnum[] | AuditScalarFieldEnum
    having?: AuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditCountAggregateInputType | true
    _min?: AuditMinAggregateInputType
    _max?: AuditMaxAggregateInputType
  }

  export type AuditGroupByOutputType = {
    id: string
    referenceNumber: string
    warehouseId: string
    status: $Enums.AuditStatus
    startDate: Date
    endDate: Date | null
    completedDate: Date | null
    notes: string | null
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: AuditCountAggregateOutputType | null
    _min: AuditMinAggregateOutputType | null
    _max: AuditMaxAggregateOutputType | null
  }

  type GetAuditGroupByPayload<T extends AuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditGroupByOutputType[P]>
            : GetScalarType<T[P], AuditGroupByOutputType[P]>
        }
      >
    >


  export type AuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    warehouseId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    completedDate?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Audit$itemsArgs<ExtArgs>
    assignments?: boolean | Audit$assignmentsArgs<ExtArgs>
    _count?: boolean | AuditCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit"]>

  export type AuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    warehouseId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    completedDate?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit"]>

  export type AuditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    warehouseId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    completedDate?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audit"]>

  export type AuditSelectScalar = {
    id?: boolean
    referenceNumber?: boolean
    warehouseId?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    completedDate?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referenceNumber" | "warehouseId" | "status" | "startDate" | "endDate" | "completedDate" | "notes" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["audit"]>
  export type AuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Audit$itemsArgs<ExtArgs>
    assignments?: boolean | Audit$assignmentsArgs<ExtArgs>
    _count?: boolean | AuditCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Audit"
    objects: {
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$AuditItemPayload<ExtArgs>[]
      assignments: Prisma.$AuditAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referenceNumber: string
      warehouseId: string
      status: $Enums.AuditStatus
      startDate: Date
      endDate: Date | null
      completedDate: Date | null
      notes: string | null
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["audit"]>
    composites: {}
  }

  type AuditGetPayload<S extends boolean | null | undefined | AuditDefaultArgs> = $Result.GetResult<Prisma.$AuditPayload, S>

  type AuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditCountAggregateInputType | true
    }

  export interface AuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Audit'], meta: { name: 'Audit' } }
    /**
     * Find zero or one Audit that matches the filter.
     * @param {AuditFindUniqueArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditFindUniqueArgs>(args: SelectSubset<T, AuditFindUniqueArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Audit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditFindUniqueOrThrowArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFindFirstArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditFindFirstArgs>(args?: SelectSubset<T, AuditFindFirstArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFindFirstOrThrowArgs} args - Arguments to find a Audit
     * @example
     * // Get one Audit
     * const audit = await prisma.audit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audits
     * const audits = await prisma.audit.findMany()
     * 
     * // Get first 10 Audits
     * const audits = await prisma.audit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditWithIdOnly = await prisma.audit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditFindManyArgs>(args?: SelectSubset<T, AuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Audit.
     * @param {AuditCreateArgs} args - Arguments to create a Audit.
     * @example
     * // Create one Audit
     * const Audit = await prisma.audit.create({
     *   data: {
     *     // ... data to create a Audit
     *   }
     * })
     * 
     */
    create<T extends AuditCreateArgs>(args: SelectSubset<T, AuditCreateArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Audits.
     * @param {AuditCreateManyArgs} args - Arguments to create many Audits.
     * @example
     * // Create many Audits
     * const audit = await prisma.audit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditCreateManyArgs>(args?: SelectSubset<T, AuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Audits and returns the data saved in the database.
     * @param {AuditCreateManyAndReturnArgs} args - Arguments to create many Audits.
     * @example
     * // Create many Audits
     * const audit = await prisma.audit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Audits and only return the `id`
     * const auditWithIdOnly = await prisma.audit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Audit.
     * @param {AuditDeleteArgs} args - Arguments to delete one Audit.
     * @example
     * // Delete one Audit
     * const Audit = await prisma.audit.delete({
     *   where: {
     *     // ... filter to delete one Audit
     *   }
     * })
     * 
     */
    delete<T extends AuditDeleteArgs>(args: SelectSubset<T, AuditDeleteArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Audit.
     * @param {AuditUpdateArgs} args - Arguments to update one Audit.
     * @example
     * // Update one Audit
     * const audit = await prisma.audit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditUpdateArgs>(args: SelectSubset<T, AuditUpdateArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Audits.
     * @param {AuditDeleteManyArgs} args - Arguments to filter Audits to delete.
     * @example
     * // Delete a few Audits
     * const { count } = await prisma.audit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditDeleteManyArgs>(args?: SelectSubset<T, AuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audits
     * const audit = await prisma.audit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditUpdateManyArgs>(args: SelectSubset<T, AuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audits and returns the data updated in the database.
     * @param {AuditUpdateManyAndReturnArgs} args - Arguments to update many Audits.
     * @example
     * // Update many Audits
     * const audit = await prisma.audit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Audits and only return the `id`
     * const auditWithIdOnly = await prisma.audit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Audit.
     * @param {AuditUpsertArgs} args - Arguments to update or create a Audit.
     * @example
     * // Update or create a Audit
     * const audit = await prisma.audit.upsert({
     *   create: {
     *     // ... data to create a Audit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit we want to update
     *   }
     * })
     */
    upsert<T extends AuditUpsertArgs>(args: SelectSubset<T, AuditUpsertArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Audits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditCountArgs} args - Arguments to filter Audits to count.
     * @example
     * // Count the number of Audits
     * const count = await prisma.audit.count({
     *   where: {
     *     // ... the filter for the Audits we want to count
     *   }
     * })
    **/
    count<T extends AuditCountArgs>(
      args?: Subset<T, AuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditAggregateArgs>(args: Subset<T, AuditAggregateArgs>): Prisma.PrismaPromise<GetAuditAggregateType<T>>

    /**
     * Group by Audit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditGroupByArgs['orderBy'] }
        : { orderBy?: AuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Audit model
   */
  readonly fields: AuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Audit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Audit$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Audit$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignments<T extends Audit$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Audit$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Audit model
   */
  interface AuditFieldRefs {
    readonly id: FieldRef<"Audit", 'String'>
    readonly referenceNumber: FieldRef<"Audit", 'String'>
    readonly warehouseId: FieldRef<"Audit", 'String'>
    readonly status: FieldRef<"Audit", 'AuditStatus'>
    readonly startDate: FieldRef<"Audit", 'DateTime'>
    readonly endDate: FieldRef<"Audit", 'DateTime'>
    readonly completedDate: FieldRef<"Audit", 'DateTime'>
    readonly notes: FieldRef<"Audit", 'String'>
    readonly createdById: FieldRef<"Audit", 'String'>
    readonly createdAt: FieldRef<"Audit", 'DateTime'>
    readonly updatedAt: FieldRef<"Audit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Audit findUnique
   */
  export type AuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit findUniqueOrThrow
   */
  export type AuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit findFirst
   */
  export type AuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Audits.
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Audits.
     */
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Audit findFirstOrThrow
   */
  export type AuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audit to fetch.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Audits.
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Audits.
     */
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Audit findMany
   */
  export type AuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter, which Audits to fetch.
     */
    where?: AuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audits to fetch.
     */
    orderBy?: AuditOrderByWithRelationInput | AuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Audits.
     */
    cursor?: AuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audits.
     */
    skip?: number
    distinct?: AuditScalarFieldEnum | AuditScalarFieldEnum[]
  }

  /**
   * Audit create
   */
  export type AuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * The data needed to create a Audit.
     */
    data: XOR<AuditCreateInput, AuditUncheckedCreateInput>
  }

  /**
   * Audit createMany
   */
  export type AuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Audits.
     */
    data: AuditCreateManyInput | AuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Audit createManyAndReturn
   */
  export type AuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * The data used to create many Audits.
     */
    data: AuditCreateManyInput | AuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Audit update
   */
  export type AuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * The data needed to update a Audit.
     */
    data: XOR<AuditUpdateInput, AuditUncheckedUpdateInput>
    /**
     * Choose, which Audit to update.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit updateMany
   */
  export type AuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Audits.
     */
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyInput>
    /**
     * Filter which Audits to update
     */
    where?: AuditWhereInput
    /**
     * Limit how many Audits to update.
     */
    limit?: number
  }

  /**
   * Audit updateManyAndReturn
   */
  export type AuditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * The data used to update Audits.
     */
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyInput>
    /**
     * Filter which Audits to update
     */
    where?: AuditWhereInput
    /**
     * Limit how many Audits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Audit upsert
   */
  export type AuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * The filter to search for the Audit to update in case it exists.
     */
    where: AuditWhereUniqueInput
    /**
     * In case the Audit found by the `where` argument doesn't exist, create a new Audit with this data.
     */
    create: XOR<AuditCreateInput, AuditUncheckedCreateInput>
    /**
     * In case the Audit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditUpdateInput, AuditUncheckedUpdateInput>
  }

  /**
   * Audit delete
   */
  export type AuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
    /**
     * Filter which Audit to delete.
     */
    where: AuditWhereUniqueInput
  }

  /**
   * Audit deleteMany
   */
  export type AuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Audits to delete
     */
    where?: AuditWhereInput
    /**
     * Limit how many Audits to delete.
     */
    limit?: number
  }

  /**
   * Audit.items
   */
  export type Audit$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    where?: AuditItemWhereInput
    orderBy?: AuditItemOrderByWithRelationInput | AuditItemOrderByWithRelationInput[]
    cursor?: AuditItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditItemScalarFieldEnum | AuditItemScalarFieldEnum[]
  }

  /**
   * Audit.assignments
   */
  export type Audit$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    where?: AuditAssignmentWhereInput
    orderBy?: AuditAssignmentOrderByWithRelationInput | AuditAssignmentOrderByWithRelationInput[]
    cursor?: AuditAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditAssignmentScalarFieldEnum | AuditAssignmentScalarFieldEnum[]
  }

  /**
   * Audit without action
   */
  export type AuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audit
     */
    select?: AuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Audit
     */
    omit?: AuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditInclude<ExtArgs> | null
  }


  /**
   * Model AuditItem
   */

  export type AggregateAuditItem = {
    _count: AuditItemCountAggregateOutputType | null
    _avg: AuditItemAvgAggregateOutputType | null
    _sum: AuditItemSumAggregateOutputType | null
    _min: AuditItemMinAggregateOutputType | null
    _max: AuditItemMaxAggregateOutputType | null
  }

  export type AuditItemAvgAggregateOutputType = {
    expectedQuantity: number | null
    countedQuantity: number | null
    discrepancy: number | null
  }

  export type AuditItemSumAggregateOutputType = {
    expectedQuantity: number | null
    countedQuantity: number | null
    discrepancy: number | null
  }

  export type AuditItemMinAggregateOutputType = {
    id: string | null
    auditId: string | null
    productId: string | null
    inventoryItemId: string | null
    expectedQuantity: number | null
    countedQuantity: number | null
    discrepancy: number | null
    notes: string | null
    status: $Enums.AuditItemStatus | null
    countedById: string | null
    countedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditItemMaxAggregateOutputType = {
    id: string | null
    auditId: string | null
    productId: string | null
    inventoryItemId: string | null
    expectedQuantity: number | null
    countedQuantity: number | null
    discrepancy: number | null
    notes: string | null
    status: $Enums.AuditItemStatus | null
    countedById: string | null
    countedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditItemCountAggregateOutputType = {
    id: number
    auditId: number
    productId: number
    inventoryItemId: number
    expectedQuantity: number
    countedQuantity: number
    discrepancy: number
    notes: number
    status: number
    countedById: number
    countedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditItemAvgAggregateInputType = {
    expectedQuantity?: true
    countedQuantity?: true
    discrepancy?: true
  }

  export type AuditItemSumAggregateInputType = {
    expectedQuantity?: true
    countedQuantity?: true
    discrepancy?: true
  }

  export type AuditItemMinAggregateInputType = {
    id?: true
    auditId?: true
    productId?: true
    inventoryItemId?: true
    expectedQuantity?: true
    countedQuantity?: true
    discrepancy?: true
    notes?: true
    status?: true
    countedById?: true
    countedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditItemMaxAggregateInputType = {
    id?: true
    auditId?: true
    productId?: true
    inventoryItemId?: true
    expectedQuantity?: true
    countedQuantity?: true
    discrepancy?: true
    notes?: true
    status?: true
    countedById?: true
    countedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditItemCountAggregateInputType = {
    id?: true
    auditId?: true
    productId?: true
    inventoryItemId?: true
    expectedQuantity?: true
    countedQuantity?: true
    discrepancy?: true
    notes?: true
    status?: true
    countedById?: true
    countedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditItem to aggregate.
     */
    where?: AuditItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditItems to fetch.
     */
    orderBy?: AuditItemOrderByWithRelationInput | AuditItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditItems
    **/
    _count?: true | AuditItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditItemMaxAggregateInputType
  }

  export type GetAuditItemAggregateType<T extends AuditItemAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditItem[P]>
      : GetScalarType<T[P], AggregateAuditItem[P]>
  }




  export type AuditItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditItemWhereInput
    orderBy?: AuditItemOrderByWithAggregationInput | AuditItemOrderByWithAggregationInput[]
    by: AuditItemScalarFieldEnum[] | AuditItemScalarFieldEnum
    having?: AuditItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditItemCountAggregateInputType | true
    _avg?: AuditItemAvgAggregateInputType
    _sum?: AuditItemSumAggregateInputType
    _min?: AuditItemMinAggregateInputType
    _max?: AuditItemMaxAggregateInputType
  }

  export type AuditItemGroupByOutputType = {
    id: string
    auditId: string
    productId: string
    inventoryItemId: string
    expectedQuantity: number
    countedQuantity: number | null
    discrepancy: number | null
    notes: string | null
    status: $Enums.AuditItemStatus
    countedById: string | null
    countedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AuditItemCountAggregateOutputType | null
    _avg: AuditItemAvgAggregateOutputType | null
    _sum: AuditItemSumAggregateOutputType | null
    _min: AuditItemMinAggregateOutputType | null
    _max: AuditItemMaxAggregateOutputType | null
  }

  type GetAuditItemGroupByPayload<T extends AuditItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditItemGroupByOutputType[P]>
            : GetScalarType<T[P], AuditItemGroupByOutputType[P]>
        }
      >
    >


  export type AuditItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    expectedQuantity?: boolean
    countedQuantity?: boolean
    discrepancy?: boolean
    notes?: boolean
    status?: boolean
    countedById?: boolean
    countedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditItem"]>

  export type AuditItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    expectedQuantity?: boolean
    countedQuantity?: boolean
    discrepancy?: boolean
    notes?: boolean
    status?: boolean
    countedById?: boolean
    countedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditItem"]>

  export type AuditItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    expectedQuantity?: boolean
    countedQuantity?: boolean
    discrepancy?: boolean
    notes?: boolean
    status?: boolean
    countedById?: boolean
    countedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditItem"]>

  export type AuditItemSelectScalar = {
    id?: boolean
    auditId?: boolean
    productId?: boolean
    inventoryItemId?: boolean
    expectedQuantity?: boolean
    countedQuantity?: boolean
    discrepancy?: boolean
    notes?: boolean
    status?: boolean
    countedById?: boolean
    countedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auditId" | "productId" | "inventoryItemId" | "expectedQuantity" | "countedQuantity" | "discrepancy" | "notes" | "status" | "countedById" | "countedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["auditItem"]>
  export type AuditItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type AuditItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type AuditItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryItem?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }

  export type $AuditItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditItem"
    objects: {
      audit: Prisma.$AuditPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      inventoryItem: Prisma.$InventoryItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auditId: string
      productId: string
      inventoryItemId: string
      expectedQuantity: number
      countedQuantity: number | null
      discrepancy: number | null
      notes: string | null
      status: $Enums.AuditItemStatus
      countedById: string | null
      countedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auditItem"]>
    composites: {}
  }

  type AuditItemGetPayload<S extends boolean | null | undefined | AuditItemDefaultArgs> = $Result.GetResult<Prisma.$AuditItemPayload, S>

  type AuditItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditItemCountAggregateInputType | true
    }

  export interface AuditItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditItem'], meta: { name: 'AuditItem' } }
    /**
     * Find zero or one AuditItem that matches the filter.
     * @param {AuditItemFindUniqueArgs} args - Arguments to find a AuditItem
     * @example
     * // Get one AuditItem
     * const auditItem = await prisma.auditItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditItemFindUniqueArgs>(args: SelectSubset<T, AuditItemFindUniqueArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditItemFindUniqueOrThrowArgs} args - Arguments to find a AuditItem
     * @example
     * // Get one AuditItem
     * const auditItem = await prisma.auditItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditItemFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditItemFindFirstArgs} args - Arguments to find a AuditItem
     * @example
     * // Get one AuditItem
     * const auditItem = await prisma.auditItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditItemFindFirstArgs>(args?: SelectSubset<T, AuditItemFindFirstArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditItemFindFirstOrThrowArgs} args - Arguments to find a AuditItem
     * @example
     * // Get one AuditItem
     * const auditItem = await prisma.auditItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditItemFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditItems
     * const auditItems = await prisma.auditItem.findMany()
     * 
     * // Get first 10 AuditItems
     * const auditItems = await prisma.auditItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditItemWithIdOnly = await prisma.auditItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditItemFindManyArgs>(args?: SelectSubset<T, AuditItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditItem.
     * @param {AuditItemCreateArgs} args - Arguments to create a AuditItem.
     * @example
     * // Create one AuditItem
     * const AuditItem = await prisma.auditItem.create({
     *   data: {
     *     // ... data to create a AuditItem
     *   }
     * })
     * 
     */
    create<T extends AuditItemCreateArgs>(args: SelectSubset<T, AuditItemCreateArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditItems.
     * @param {AuditItemCreateManyArgs} args - Arguments to create many AuditItems.
     * @example
     * // Create many AuditItems
     * const auditItem = await prisma.auditItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditItemCreateManyArgs>(args?: SelectSubset<T, AuditItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditItems and returns the data saved in the database.
     * @param {AuditItemCreateManyAndReturnArgs} args - Arguments to create many AuditItems.
     * @example
     * // Create many AuditItems
     * const auditItem = await prisma.auditItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditItems and only return the `id`
     * const auditItemWithIdOnly = await prisma.auditItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditItemCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditItem.
     * @param {AuditItemDeleteArgs} args - Arguments to delete one AuditItem.
     * @example
     * // Delete one AuditItem
     * const AuditItem = await prisma.auditItem.delete({
     *   where: {
     *     // ... filter to delete one AuditItem
     *   }
     * })
     * 
     */
    delete<T extends AuditItemDeleteArgs>(args: SelectSubset<T, AuditItemDeleteArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditItem.
     * @param {AuditItemUpdateArgs} args - Arguments to update one AuditItem.
     * @example
     * // Update one AuditItem
     * const auditItem = await prisma.auditItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditItemUpdateArgs>(args: SelectSubset<T, AuditItemUpdateArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditItems.
     * @param {AuditItemDeleteManyArgs} args - Arguments to filter AuditItems to delete.
     * @example
     * // Delete a few AuditItems
     * const { count } = await prisma.auditItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditItemDeleteManyArgs>(args?: SelectSubset<T, AuditItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditItems
     * const auditItem = await prisma.auditItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditItemUpdateManyArgs>(args: SelectSubset<T, AuditItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditItems and returns the data updated in the database.
     * @param {AuditItemUpdateManyAndReturnArgs} args - Arguments to update many AuditItems.
     * @example
     * // Update many AuditItems
     * const auditItem = await prisma.auditItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditItems and only return the `id`
     * const auditItemWithIdOnly = await prisma.auditItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditItemUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditItem.
     * @param {AuditItemUpsertArgs} args - Arguments to update or create a AuditItem.
     * @example
     * // Update or create a AuditItem
     * const auditItem = await prisma.auditItem.upsert({
     *   create: {
     *     // ... data to create a AuditItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditItem we want to update
     *   }
     * })
     */
    upsert<T extends AuditItemUpsertArgs>(args: SelectSubset<T, AuditItemUpsertArgs<ExtArgs>>): Prisma__AuditItemClient<$Result.GetResult<Prisma.$AuditItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditItemCountArgs} args - Arguments to filter AuditItems to count.
     * @example
     * // Count the number of AuditItems
     * const count = await prisma.auditItem.count({
     *   where: {
     *     // ... the filter for the AuditItems we want to count
     *   }
     * })
    **/
    count<T extends AuditItemCountArgs>(
      args?: Subset<T, AuditItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditItemAggregateArgs>(args: Subset<T, AuditItemAggregateArgs>): Prisma.PrismaPromise<GetAuditItemAggregateType<T>>

    /**
     * Group by AuditItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditItemGroupByArgs['orderBy'] }
        : { orderBy?: AuditItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditItem model
   */
  readonly fields: AuditItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audit<T extends AuditDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditDefaultArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventoryItem<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditItem model
   */
  interface AuditItemFieldRefs {
    readonly id: FieldRef<"AuditItem", 'String'>
    readonly auditId: FieldRef<"AuditItem", 'String'>
    readonly productId: FieldRef<"AuditItem", 'String'>
    readonly inventoryItemId: FieldRef<"AuditItem", 'String'>
    readonly expectedQuantity: FieldRef<"AuditItem", 'Int'>
    readonly countedQuantity: FieldRef<"AuditItem", 'Int'>
    readonly discrepancy: FieldRef<"AuditItem", 'Int'>
    readonly notes: FieldRef<"AuditItem", 'String'>
    readonly status: FieldRef<"AuditItem", 'AuditItemStatus'>
    readonly countedById: FieldRef<"AuditItem", 'String'>
    readonly countedAt: FieldRef<"AuditItem", 'DateTime'>
    readonly createdAt: FieldRef<"AuditItem", 'DateTime'>
    readonly updatedAt: FieldRef<"AuditItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditItem findUnique
   */
  export type AuditItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * Filter, which AuditItem to fetch.
     */
    where: AuditItemWhereUniqueInput
  }

  /**
   * AuditItem findUniqueOrThrow
   */
  export type AuditItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * Filter, which AuditItem to fetch.
     */
    where: AuditItemWhereUniqueInput
  }

  /**
   * AuditItem findFirst
   */
  export type AuditItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * Filter, which AuditItem to fetch.
     */
    where?: AuditItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditItems to fetch.
     */
    orderBy?: AuditItemOrderByWithRelationInput | AuditItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditItems.
     */
    cursor?: AuditItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditItems.
     */
    distinct?: AuditItemScalarFieldEnum | AuditItemScalarFieldEnum[]
  }

  /**
   * AuditItem findFirstOrThrow
   */
  export type AuditItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * Filter, which AuditItem to fetch.
     */
    where?: AuditItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditItems to fetch.
     */
    orderBy?: AuditItemOrderByWithRelationInput | AuditItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditItems.
     */
    cursor?: AuditItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditItems.
     */
    distinct?: AuditItemScalarFieldEnum | AuditItemScalarFieldEnum[]
  }

  /**
   * AuditItem findMany
   */
  export type AuditItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * Filter, which AuditItems to fetch.
     */
    where?: AuditItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditItems to fetch.
     */
    orderBy?: AuditItemOrderByWithRelationInput | AuditItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditItems.
     */
    cursor?: AuditItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditItems.
     */
    skip?: number
    distinct?: AuditItemScalarFieldEnum | AuditItemScalarFieldEnum[]
  }

  /**
   * AuditItem create
   */
  export type AuditItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditItem.
     */
    data: XOR<AuditItemCreateInput, AuditItemUncheckedCreateInput>
  }

  /**
   * AuditItem createMany
   */
  export type AuditItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditItems.
     */
    data: AuditItemCreateManyInput | AuditItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditItem createManyAndReturn
   */
  export type AuditItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * The data used to create many AuditItems.
     */
    data: AuditItemCreateManyInput | AuditItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditItem update
   */
  export type AuditItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditItem.
     */
    data: XOR<AuditItemUpdateInput, AuditItemUncheckedUpdateInput>
    /**
     * Choose, which AuditItem to update.
     */
    where: AuditItemWhereUniqueInput
  }

  /**
   * AuditItem updateMany
   */
  export type AuditItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditItems.
     */
    data: XOR<AuditItemUpdateManyMutationInput, AuditItemUncheckedUpdateManyInput>
    /**
     * Filter which AuditItems to update
     */
    where?: AuditItemWhereInput
    /**
     * Limit how many AuditItems to update.
     */
    limit?: number
  }

  /**
   * AuditItem updateManyAndReturn
   */
  export type AuditItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * The data used to update AuditItems.
     */
    data: XOR<AuditItemUpdateManyMutationInput, AuditItemUncheckedUpdateManyInput>
    /**
     * Filter which AuditItems to update
     */
    where?: AuditItemWhereInput
    /**
     * Limit how many AuditItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditItem upsert
   */
  export type AuditItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditItem to update in case it exists.
     */
    where: AuditItemWhereUniqueInput
    /**
     * In case the AuditItem found by the `where` argument doesn't exist, create a new AuditItem with this data.
     */
    create: XOR<AuditItemCreateInput, AuditItemUncheckedCreateInput>
    /**
     * In case the AuditItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditItemUpdateInput, AuditItemUncheckedUpdateInput>
  }

  /**
   * AuditItem delete
   */
  export type AuditItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
    /**
     * Filter which AuditItem to delete.
     */
    where: AuditItemWhereUniqueInput
  }

  /**
   * AuditItem deleteMany
   */
  export type AuditItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditItems to delete
     */
    where?: AuditItemWhereInput
    /**
     * Limit how many AuditItems to delete.
     */
    limit?: number
  }

  /**
   * AuditItem without action
   */
  export type AuditItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditItem
     */
    select?: AuditItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditItem
     */
    omit?: AuditItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditItemInclude<ExtArgs> | null
  }


  /**
   * Model AuditAssignment
   */

  export type AggregateAuditAssignment = {
    _count: AuditAssignmentCountAggregateOutputType | null
    _min: AuditAssignmentMinAggregateOutputType | null
    _max: AuditAssignmentMaxAggregateOutputType | null
  }

  export type AuditAssignmentMinAggregateOutputType = {
    id: string | null
    auditId: string | null
    userId: string | null
    assignedZones: string | null
    status: $Enums.AssignmentStatus | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditAssignmentMaxAggregateOutputType = {
    id: string | null
    auditId: string | null
    userId: string | null
    assignedZones: string | null
    status: $Enums.AssignmentStatus | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditAssignmentCountAggregateOutputType = {
    id: number
    auditId: number
    userId: number
    assignedZones: number
    status: number
    startedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditAssignmentMinAggregateInputType = {
    id?: true
    auditId?: true
    userId?: true
    assignedZones?: true
    status?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditAssignmentMaxAggregateInputType = {
    id?: true
    auditId?: true
    userId?: true
    assignedZones?: true
    status?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditAssignmentCountAggregateInputType = {
    id?: true
    auditId?: true
    userId?: true
    assignedZones?: true
    status?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditAssignment to aggregate.
     */
    where?: AuditAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditAssignments to fetch.
     */
    orderBy?: AuditAssignmentOrderByWithRelationInput | AuditAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditAssignments
    **/
    _count?: true | AuditAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditAssignmentMaxAggregateInputType
  }

  export type GetAuditAssignmentAggregateType<T extends AuditAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditAssignment[P]>
      : GetScalarType<T[P], AggregateAuditAssignment[P]>
  }




  export type AuditAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditAssignmentWhereInput
    orderBy?: AuditAssignmentOrderByWithAggregationInput | AuditAssignmentOrderByWithAggregationInput[]
    by: AuditAssignmentScalarFieldEnum[] | AuditAssignmentScalarFieldEnum
    having?: AuditAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditAssignmentCountAggregateInputType | true
    _min?: AuditAssignmentMinAggregateInputType
    _max?: AuditAssignmentMaxAggregateInputType
  }

  export type AuditAssignmentGroupByOutputType = {
    id: string
    auditId: string
    userId: string
    assignedZones: string | null
    status: $Enums.AssignmentStatus
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AuditAssignmentCountAggregateOutputType | null
    _min: AuditAssignmentMinAggregateOutputType | null
    _max: AuditAssignmentMaxAggregateOutputType | null
  }

  type GetAuditAssignmentGroupByPayload<T extends AuditAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AuditAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AuditAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    userId?: boolean
    assignedZones?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditAssignment"]>

  export type AuditAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    userId?: boolean
    assignedZones?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditAssignment"]>

  export type AuditAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auditId?: boolean
    userId?: boolean
    assignedZones?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditAssignment"]>

  export type AuditAssignmentSelectScalar = {
    id?: boolean
    auditId?: boolean
    userId?: boolean
    assignedZones?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auditId" | "userId" | "assignedZones" | "status" | "startedAt" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["auditAssignment"]>
  export type AuditAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit?: boolean | AuditDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditAssignment"
    objects: {
      audit: Prisma.$AuditPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auditId: string
      userId: string
      assignedZones: string | null
      status: $Enums.AssignmentStatus
      startedAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auditAssignment"]>
    composites: {}
  }

  type AuditAssignmentGetPayload<S extends boolean | null | undefined | AuditAssignmentDefaultArgs> = $Result.GetResult<Prisma.$AuditAssignmentPayload, S>

  type AuditAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditAssignmentCountAggregateInputType | true
    }

  export interface AuditAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditAssignment'], meta: { name: 'AuditAssignment' } }
    /**
     * Find zero or one AuditAssignment that matches the filter.
     * @param {AuditAssignmentFindUniqueArgs} args - Arguments to find a AuditAssignment
     * @example
     * // Get one AuditAssignment
     * const auditAssignment = await prisma.auditAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditAssignmentFindUniqueArgs>(args: SelectSubset<T, AuditAssignmentFindUniqueArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditAssignmentFindUniqueOrThrowArgs} args - Arguments to find a AuditAssignment
     * @example
     * // Get one AuditAssignment
     * const auditAssignment = await prisma.auditAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAssignmentFindFirstArgs} args - Arguments to find a AuditAssignment
     * @example
     * // Get one AuditAssignment
     * const auditAssignment = await prisma.auditAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditAssignmentFindFirstArgs>(args?: SelectSubset<T, AuditAssignmentFindFirstArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAssignmentFindFirstOrThrowArgs} args - Arguments to find a AuditAssignment
     * @example
     * // Get one AuditAssignment
     * const auditAssignment = await prisma.auditAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditAssignments
     * const auditAssignments = await prisma.auditAssignment.findMany()
     * 
     * // Get first 10 AuditAssignments
     * const auditAssignments = await prisma.auditAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditAssignmentWithIdOnly = await prisma.auditAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditAssignmentFindManyArgs>(args?: SelectSubset<T, AuditAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditAssignment.
     * @param {AuditAssignmentCreateArgs} args - Arguments to create a AuditAssignment.
     * @example
     * // Create one AuditAssignment
     * const AuditAssignment = await prisma.auditAssignment.create({
     *   data: {
     *     // ... data to create a AuditAssignment
     *   }
     * })
     * 
     */
    create<T extends AuditAssignmentCreateArgs>(args: SelectSubset<T, AuditAssignmentCreateArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditAssignments.
     * @param {AuditAssignmentCreateManyArgs} args - Arguments to create many AuditAssignments.
     * @example
     * // Create many AuditAssignments
     * const auditAssignment = await prisma.auditAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditAssignmentCreateManyArgs>(args?: SelectSubset<T, AuditAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditAssignments and returns the data saved in the database.
     * @param {AuditAssignmentCreateManyAndReturnArgs} args - Arguments to create many AuditAssignments.
     * @example
     * // Create many AuditAssignments
     * const auditAssignment = await prisma.auditAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditAssignments and only return the `id`
     * const auditAssignmentWithIdOnly = await prisma.auditAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditAssignment.
     * @param {AuditAssignmentDeleteArgs} args - Arguments to delete one AuditAssignment.
     * @example
     * // Delete one AuditAssignment
     * const AuditAssignment = await prisma.auditAssignment.delete({
     *   where: {
     *     // ... filter to delete one AuditAssignment
     *   }
     * })
     * 
     */
    delete<T extends AuditAssignmentDeleteArgs>(args: SelectSubset<T, AuditAssignmentDeleteArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditAssignment.
     * @param {AuditAssignmentUpdateArgs} args - Arguments to update one AuditAssignment.
     * @example
     * // Update one AuditAssignment
     * const auditAssignment = await prisma.auditAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditAssignmentUpdateArgs>(args: SelectSubset<T, AuditAssignmentUpdateArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditAssignments.
     * @param {AuditAssignmentDeleteManyArgs} args - Arguments to filter AuditAssignments to delete.
     * @example
     * // Delete a few AuditAssignments
     * const { count } = await prisma.auditAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditAssignmentDeleteManyArgs>(args?: SelectSubset<T, AuditAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditAssignments
     * const auditAssignment = await prisma.auditAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditAssignmentUpdateManyArgs>(args: SelectSubset<T, AuditAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditAssignments and returns the data updated in the database.
     * @param {AuditAssignmentUpdateManyAndReturnArgs} args - Arguments to update many AuditAssignments.
     * @example
     * // Update many AuditAssignments
     * const auditAssignment = await prisma.auditAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditAssignments and only return the `id`
     * const auditAssignmentWithIdOnly = await prisma.auditAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditAssignment.
     * @param {AuditAssignmentUpsertArgs} args - Arguments to update or create a AuditAssignment.
     * @example
     * // Update or create a AuditAssignment
     * const auditAssignment = await prisma.auditAssignment.upsert({
     *   create: {
     *     // ... data to create a AuditAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditAssignment we want to update
     *   }
     * })
     */
    upsert<T extends AuditAssignmentUpsertArgs>(args: SelectSubset<T, AuditAssignmentUpsertArgs<ExtArgs>>): Prisma__AuditAssignmentClient<$Result.GetResult<Prisma.$AuditAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAssignmentCountArgs} args - Arguments to filter AuditAssignments to count.
     * @example
     * // Count the number of AuditAssignments
     * const count = await prisma.auditAssignment.count({
     *   where: {
     *     // ... the filter for the AuditAssignments we want to count
     *   }
     * })
    **/
    count<T extends AuditAssignmentCountArgs>(
      args?: Subset<T, AuditAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditAssignmentAggregateArgs>(args: Subset<T, AuditAssignmentAggregateArgs>): Prisma.PrismaPromise<GetAuditAssignmentAggregateType<T>>

    /**
     * Group by AuditAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AuditAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditAssignment model
   */
  readonly fields: AuditAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audit<T extends AuditDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuditDefaultArgs<ExtArgs>>): Prisma__AuditClient<$Result.GetResult<Prisma.$AuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditAssignment model
   */
  interface AuditAssignmentFieldRefs {
    readonly id: FieldRef<"AuditAssignment", 'String'>
    readonly auditId: FieldRef<"AuditAssignment", 'String'>
    readonly userId: FieldRef<"AuditAssignment", 'String'>
    readonly assignedZones: FieldRef<"AuditAssignment", 'String'>
    readonly status: FieldRef<"AuditAssignment", 'AssignmentStatus'>
    readonly startedAt: FieldRef<"AuditAssignment", 'DateTime'>
    readonly completedAt: FieldRef<"AuditAssignment", 'DateTime'>
    readonly createdAt: FieldRef<"AuditAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"AuditAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditAssignment findUnique
   */
  export type AuditAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AuditAssignment to fetch.
     */
    where: AuditAssignmentWhereUniqueInput
  }

  /**
   * AuditAssignment findUniqueOrThrow
   */
  export type AuditAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AuditAssignment to fetch.
     */
    where: AuditAssignmentWhereUniqueInput
  }

  /**
   * AuditAssignment findFirst
   */
  export type AuditAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AuditAssignment to fetch.
     */
    where?: AuditAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditAssignments to fetch.
     */
    orderBy?: AuditAssignmentOrderByWithRelationInput | AuditAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditAssignments.
     */
    cursor?: AuditAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditAssignments.
     */
    distinct?: AuditAssignmentScalarFieldEnum | AuditAssignmentScalarFieldEnum[]
  }

  /**
   * AuditAssignment findFirstOrThrow
   */
  export type AuditAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AuditAssignment to fetch.
     */
    where?: AuditAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditAssignments to fetch.
     */
    orderBy?: AuditAssignmentOrderByWithRelationInput | AuditAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditAssignments.
     */
    cursor?: AuditAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditAssignments.
     */
    distinct?: AuditAssignmentScalarFieldEnum | AuditAssignmentScalarFieldEnum[]
  }

  /**
   * AuditAssignment findMany
   */
  export type AuditAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AuditAssignments to fetch.
     */
    where?: AuditAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditAssignments to fetch.
     */
    orderBy?: AuditAssignmentOrderByWithRelationInput | AuditAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditAssignments.
     */
    cursor?: AuditAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditAssignments.
     */
    skip?: number
    distinct?: AuditAssignmentScalarFieldEnum | AuditAssignmentScalarFieldEnum[]
  }

  /**
   * AuditAssignment create
   */
  export type AuditAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditAssignment.
     */
    data: XOR<AuditAssignmentCreateInput, AuditAssignmentUncheckedCreateInput>
  }

  /**
   * AuditAssignment createMany
   */
  export type AuditAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditAssignments.
     */
    data: AuditAssignmentCreateManyInput | AuditAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditAssignment createManyAndReturn
   */
  export type AuditAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many AuditAssignments.
     */
    data: AuditAssignmentCreateManyInput | AuditAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditAssignment update
   */
  export type AuditAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditAssignment.
     */
    data: XOR<AuditAssignmentUpdateInput, AuditAssignmentUncheckedUpdateInput>
    /**
     * Choose, which AuditAssignment to update.
     */
    where: AuditAssignmentWhereUniqueInput
  }

  /**
   * AuditAssignment updateMany
   */
  export type AuditAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditAssignments.
     */
    data: XOR<AuditAssignmentUpdateManyMutationInput, AuditAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which AuditAssignments to update
     */
    where?: AuditAssignmentWhereInput
    /**
     * Limit how many AuditAssignments to update.
     */
    limit?: number
  }

  /**
   * AuditAssignment updateManyAndReturn
   */
  export type AuditAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update AuditAssignments.
     */
    data: XOR<AuditAssignmentUpdateManyMutationInput, AuditAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which AuditAssignments to update
     */
    where?: AuditAssignmentWhereInput
    /**
     * Limit how many AuditAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditAssignment upsert
   */
  export type AuditAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditAssignment to update in case it exists.
     */
    where: AuditAssignmentWhereUniqueInput
    /**
     * In case the AuditAssignment found by the `where` argument doesn't exist, create a new AuditAssignment with this data.
     */
    create: XOR<AuditAssignmentCreateInput, AuditAssignmentUncheckedCreateInput>
    /**
     * In case the AuditAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditAssignmentUpdateInput, AuditAssignmentUncheckedUpdateInput>
  }

  /**
   * AuditAssignment delete
   */
  export type AuditAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
    /**
     * Filter which AuditAssignment to delete.
     */
    where: AuditAssignmentWhereUniqueInput
  }

  /**
   * AuditAssignment deleteMany
   */
  export type AuditAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditAssignments to delete
     */
    where?: AuditAssignmentWhereInput
    /**
     * Limit how many AuditAssignments to delete.
     */
    limit?: number
  }

  /**
   * AuditAssignment without action
   */
  export type AuditAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAssignment
     */
    select?: AuditAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAssignment
     */
    omit?: AuditAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model TaxRate
   */

  export type AggregateTaxRate = {
    _count: TaxRateCountAggregateOutputType | null
    _avg: TaxRateAvgAggregateOutputType | null
    _sum: TaxRateSumAggregateOutputType | null
    _min: TaxRateMinAggregateOutputType | null
    _max: TaxRateMaxAggregateOutputType | null
  }

  export type TaxRateAvgAggregateOutputType = {
    rate: number | null
  }

  export type TaxRateSumAggregateOutputType = {
    rate: number | null
  }

  export type TaxRateMinAggregateOutputType = {
    id: string | null
    name: string | null
    rate: number | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxRateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    rate: number | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxRateCountAggregateOutputType = {
    id: number
    name: number
    rate: number
    isDefault: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaxRateAvgAggregateInputType = {
    rate?: true
  }

  export type TaxRateSumAggregateInputType = {
    rate?: true
  }

  export type TaxRateMinAggregateInputType = {
    id?: true
    name?: true
    rate?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxRateMaxAggregateInputType = {
    id?: true
    name?: true
    rate?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxRateCountAggregateInputType = {
    id?: true
    name?: true
    rate?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxRate to aggregate.
     */
    where?: TaxRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRates to fetch.
     */
    orderBy?: TaxRateOrderByWithRelationInput | TaxRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxRates
    **/
    _count?: true | TaxRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxRateMaxAggregateInputType
  }

  export type GetTaxRateAggregateType<T extends TaxRateAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxRate[P]>
      : GetScalarType<T[P], AggregateTaxRate[P]>
  }




  export type TaxRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxRateWhereInput
    orderBy?: TaxRateOrderByWithAggregationInput | TaxRateOrderByWithAggregationInput[]
    by: TaxRateScalarFieldEnum[] | TaxRateScalarFieldEnum
    having?: TaxRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxRateCountAggregateInputType | true
    _avg?: TaxRateAvgAggregateInputType
    _sum?: TaxRateSumAggregateInputType
    _min?: TaxRateMinAggregateInputType
    _max?: TaxRateMaxAggregateInputType
  }

  export type TaxRateGroupByOutputType = {
    id: string
    name: string
    rate: number
    isDefault: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TaxRateCountAggregateOutputType | null
    _avg: TaxRateAvgAggregateOutputType | null
    _sum: TaxRateSumAggregateOutputType | null
    _min: TaxRateMinAggregateOutputType | null
    _max: TaxRateMaxAggregateOutputType | null
  }

  type GetTaxRateGroupByPayload<T extends TaxRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxRateGroupByOutputType[P]>
            : GetScalarType<T[P], TaxRateGroupByOutputType[P]>
        }
      >
    >


  export type TaxRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rate?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["taxRate"]>

  export type TaxRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rate?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["taxRate"]>

  export type TaxRateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    rate?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["taxRate"]>

  export type TaxRateSelectScalar = {
    id?: boolean
    name?: boolean
    rate?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaxRateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "rate" | "isDefault" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["taxRate"]>

  export type $TaxRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxRate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      rate: number
      isDefault: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taxRate"]>
    composites: {}
  }

  type TaxRateGetPayload<S extends boolean | null | undefined | TaxRateDefaultArgs> = $Result.GetResult<Prisma.$TaxRatePayload, S>

  type TaxRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxRateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxRateCountAggregateInputType | true
    }

  export interface TaxRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxRate'], meta: { name: 'TaxRate' } }
    /**
     * Find zero or one TaxRate that matches the filter.
     * @param {TaxRateFindUniqueArgs} args - Arguments to find a TaxRate
     * @example
     * // Get one TaxRate
     * const taxRate = await prisma.taxRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxRateFindUniqueArgs>(args: SelectSubset<T, TaxRateFindUniqueArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxRate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxRateFindUniqueOrThrowArgs} args - Arguments to find a TaxRate
     * @example
     * // Get one TaxRate
     * const taxRate = await prisma.taxRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxRateFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateFindFirstArgs} args - Arguments to find a TaxRate
     * @example
     * // Get one TaxRate
     * const taxRate = await prisma.taxRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxRateFindFirstArgs>(args?: SelectSubset<T, TaxRateFindFirstArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateFindFirstOrThrowArgs} args - Arguments to find a TaxRate
     * @example
     * // Get one TaxRate
     * const taxRate = await prisma.taxRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxRateFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxRates
     * const taxRates = await prisma.taxRate.findMany()
     * 
     * // Get first 10 TaxRates
     * const taxRates = await prisma.taxRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxRateWithIdOnly = await prisma.taxRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxRateFindManyArgs>(args?: SelectSubset<T, TaxRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxRate.
     * @param {TaxRateCreateArgs} args - Arguments to create a TaxRate.
     * @example
     * // Create one TaxRate
     * const TaxRate = await prisma.taxRate.create({
     *   data: {
     *     // ... data to create a TaxRate
     *   }
     * })
     * 
     */
    create<T extends TaxRateCreateArgs>(args: SelectSubset<T, TaxRateCreateArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxRates.
     * @param {TaxRateCreateManyArgs} args - Arguments to create many TaxRates.
     * @example
     * // Create many TaxRates
     * const taxRate = await prisma.taxRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxRateCreateManyArgs>(args?: SelectSubset<T, TaxRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxRates and returns the data saved in the database.
     * @param {TaxRateCreateManyAndReturnArgs} args - Arguments to create many TaxRates.
     * @example
     * // Create many TaxRates
     * const taxRate = await prisma.taxRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxRates and only return the `id`
     * const taxRateWithIdOnly = await prisma.taxRate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxRateCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaxRate.
     * @param {TaxRateDeleteArgs} args - Arguments to delete one TaxRate.
     * @example
     * // Delete one TaxRate
     * const TaxRate = await prisma.taxRate.delete({
     *   where: {
     *     // ... filter to delete one TaxRate
     *   }
     * })
     * 
     */
    delete<T extends TaxRateDeleteArgs>(args: SelectSubset<T, TaxRateDeleteArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxRate.
     * @param {TaxRateUpdateArgs} args - Arguments to update one TaxRate.
     * @example
     * // Update one TaxRate
     * const taxRate = await prisma.taxRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxRateUpdateArgs>(args: SelectSubset<T, TaxRateUpdateArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxRates.
     * @param {TaxRateDeleteManyArgs} args - Arguments to filter TaxRates to delete.
     * @example
     * // Delete a few TaxRates
     * const { count } = await prisma.taxRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxRateDeleteManyArgs>(args?: SelectSubset<T, TaxRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxRates
     * const taxRate = await prisma.taxRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxRateUpdateManyArgs>(args: SelectSubset<T, TaxRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxRates and returns the data updated in the database.
     * @param {TaxRateUpdateManyAndReturnArgs} args - Arguments to update many TaxRates.
     * @example
     * // Update many TaxRates
     * const taxRate = await prisma.taxRate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaxRates and only return the `id`
     * const taxRateWithIdOnly = await prisma.taxRate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaxRateUpdateManyAndReturnArgs>(args: SelectSubset<T, TaxRateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaxRate.
     * @param {TaxRateUpsertArgs} args - Arguments to update or create a TaxRate.
     * @example
     * // Update or create a TaxRate
     * const taxRate = await prisma.taxRate.upsert({
     *   create: {
     *     // ... data to create a TaxRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxRate we want to update
     *   }
     * })
     */
    upsert<T extends TaxRateUpsertArgs>(args: SelectSubset<T, TaxRateUpsertArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateCountArgs} args - Arguments to filter TaxRates to count.
     * @example
     * // Count the number of TaxRates
     * const count = await prisma.taxRate.count({
     *   where: {
     *     // ... the filter for the TaxRates we want to count
     *   }
     * })
    **/
    count<T extends TaxRateCountArgs>(
      args?: Subset<T, TaxRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxRateAggregateArgs>(args: Subset<T, TaxRateAggregateArgs>): Prisma.PrismaPromise<GetTaxRateAggregateType<T>>

    /**
     * Group by TaxRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxRateGroupByArgs['orderBy'] }
        : { orderBy?: TaxRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxRate model
   */
  readonly fields: TaxRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxRate model
   */
  interface TaxRateFieldRefs {
    readonly id: FieldRef<"TaxRate", 'String'>
    readonly name: FieldRef<"TaxRate", 'String'>
    readonly rate: FieldRef<"TaxRate", 'Float'>
    readonly isDefault: FieldRef<"TaxRate", 'Boolean'>
    readonly isActive: FieldRef<"TaxRate", 'Boolean'>
    readonly createdAt: FieldRef<"TaxRate", 'DateTime'>
    readonly updatedAt: FieldRef<"TaxRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxRate findUnique
   */
  export type TaxRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Filter, which TaxRate to fetch.
     */
    where: TaxRateWhereUniqueInput
  }

  /**
   * TaxRate findUniqueOrThrow
   */
  export type TaxRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Filter, which TaxRate to fetch.
     */
    where: TaxRateWhereUniqueInput
  }

  /**
   * TaxRate findFirst
   */
  export type TaxRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Filter, which TaxRate to fetch.
     */
    where?: TaxRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRates to fetch.
     */
    orderBy?: TaxRateOrderByWithRelationInput | TaxRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxRates.
     */
    cursor?: TaxRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxRates.
     */
    distinct?: TaxRateScalarFieldEnum | TaxRateScalarFieldEnum[]
  }

  /**
   * TaxRate findFirstOrThrow
   */
  export type TaxRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Filter, which TaxRate to fetch.
     */
    where?: TaxRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRates to fetch.
     */
    orderBy?: TaxRateOrderByWithRelationInput | TaxRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxRates.
     */
    cursor?: TaxRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxRates.
     */
    distinct?: TaxRateScalarFieldEnum | TaxRateScalarFieldEnum[]
  }

  /**
   * TaxRate findMany
   */
  export type TaxRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Filter, which TaxRates to fetch.
     */
    where?: TaxRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRates to fetch.
     */
    orderBy?: TaxRateOrderByWithRelationInput | TaxRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxRates.
     */
    cursor?: TaxRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRates.
     */
    skip?: number
    distinct?: TaxRateScalarFieldEnum | TaxRateScalarFieldEnum[]
  }

  /**
   * TaxRate create
   */
  export type TaxRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * The data needed to create a TaxRate.
     */
    data: XOR<TaxRateCreateInput, TaxRateUncheckedCreateInput>
  }

  /**
   * TaxRate createMany
   */
  export type TaxRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxRates.
     */
    data: TaxRateCreateManyInput | TaxRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxRate createManyAndReturn
   */
  export type TaxRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * The data used to create many TaxRates.
     */
    data: TaxRateCreateManyInput | TaxRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxRate update
   */
  export type TaxRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * The data needed to update a TaxRate.
     */
    data: XOR<TaxRateUpdateInput, TaxRateUncheckedUpdateInput>
    /**
     * Choose, which TaxRate to update.
     */
    where: TaxRateWhereUniqueInput
  }

  /**
   * TaxRate updateMany
   */
  export type TaxRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxRates.
     */
    data: XOR<TaxRateUpdateManyMutationInput, TaxRateUncheckedUpdateManyInput>
    /**
     * Filter which TaxRates to update
     */
    where?: TaxRateWhereInput
    /**
     * Limit how many TaxRates to update.
     */
    limit?: number
  }

  /**
   * TaxRate updateManyAndReturn
   */
  export type TaxRateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * The data used to update TaxRates.
     */
    data: XOR<TaxRateUpdateManyMutationInput, TaxRateUncheckedUpdateManyInput>
    /**
     * Filter which TaxRates to update
     */
    where?: TaxRateWhereInput
    /**
     * Limit how many TaxRates to update.
     */
    limit?: number
  }

  /**
   * TaxRate upsert
   */
  export type TaxRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * The filter to search for the TaxRate to update in case it exists.
     */
    where: TaxRateWhereUniqueInput
    /**
     * In case the TaxRate found by the `where` argument doesn't exist, create a new TaxRate with this data.
     */
    create: XOR<TaxRateCreateInput, TaxRateUncheckedCreateInput>
    /**
     * In case the TaxRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxRateUpdateInput, TaxRateUncheckedUpdateInput>
  }

  /**
   * TaxRate delete
   */
  export type TaxRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Filter which TaxRate to delete.
     */
    where: TaxRateWhereUniqueInput
  }

  /**
   * TaxRate deleteMany
   */
  export type TaxRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxRates to delete
     */
    where?: TaxRateWhereInput
    /**
     * Limit how many TaxRates to delete.
     */
    limit?: number
  }

  /**
   * TaxRate without action
   */
  export type TaxRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    password: 'password',
    image: 'image',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const WarehouseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    address: 'address',
    contactPerson: 'contactPerson',
    phone: 'phone',
    email: 'email',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


  export const WarehouseZoneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    warehouseId: 'warehouseId',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseZoneScalarFieldEnum = (typeof WarehouseZoneScalarFieldEnum)[keyof typeof WarehouseZoneScalarFieldEnum]


  export const WarehouseAisleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    zoneId: 'zoneId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseAisleScalarFieldEnum = (typeof WarehouseAisleScalarFieldEnum)[keyof typeof WarehouseAisleScalarFieldEnum]


  export const WarehouseShelfScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    aisleId: 'aisleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseShelfScalarFieldEnum = (typeof WarehouseShelfScalarFieldEnum)[keyof typeof WarehouseShelfScalarFieldEnum]


  export const WarehouseBinScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    shelfId: 'shelfId',
    capacity: 'capacity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseBinScalarFieldEnum = (typeof WarehouseBinScalarFieldEnum)[keyof typeof WarehouseBinScalarFieldEnum]


  export const WarehouseStaffScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    warehouseId: 'warehouseId',
    position: 'position',
    isManager: 'isManager',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseStaffScalarFieldEnum = (typeof WarehouseStaffScalarFieldEnum)[keyof typeof WarehouseStaffScalarFieldEnum]


  export const StoreScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    address: 'address',
    phone: 'phone',
    email: 'email',
    openingHours: 'openingHours',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const StoreStaffScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    storeId: 'storeId',
    position: 'position',
    isManager: 'isManager',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreStaffScalarFieldEnum = (typeof StoreStaffScalarFieldEnum)[keyof typeof StoreStaffScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactPerson: 'contactPerson',
    email: 'email',
    phone: 'phone',
    address: 'address',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    taxId: 'taxId',
    paymentTerms: 'paymentTerms',
    notes: 'notes',
    rating: 'rating',
    isActive: 'isActive',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const SupplierContractScalarFieldEnum: {
    id: 'id',
    supplierId: 'supplierId',
    contractNumber: 'contractNumber',
    title: 'title',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    renewalDate: 'renewalDate',
    value: 'value',
    terms: 'terms',
    paymentTerms: 'paymentTerms',
    status: 'status',
    documentUrl: 'documentUrl',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierContractScalarFieldEnum = (typeof SupplierContractScalarFieldEnum)[keyof typeof SupplierContractScalarFieldEnum]


  export const SupplierPerformanceMetricScalarFieldEnum: {
    id: 'id',
    supplierId: 'supplierId',
    metricType: 'metricType',
    date: 'date',
    value: 'value',
    notes: 'notes',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierPerformanceMetricScalarFieldEnum = (typeof SupplierPerformanceMetricScalarFieldEnum)[keyof typeof SupplierPerformanceMetricScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    supplierId: 'supplierId',
    warehouseId: 'warehouseId',
    orderDate: 'orderDate',
    expectedDeliveryDate: 'expectedDeliveryDate',
    status: 'status',
    subtotal: 'subtotal',
    taxAmount: 'taxAmount',
    totalAmount: 'totalAmount',
    notes: 'notes',
    createdById: 'createdById',
    approvedById: 'approvedById',
    receivedById: 'receivedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const PurchaseOrderItemScalarFieldEnum: {
    id: 'id',
    purchaseOrderId: 'purchaseOrderId',
    productId: 'productId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    receivedQuantity: 'receivedQuantity',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderItemScalarFieldEnum = (typeof PurchaseOrderItemScalarFieldEnum)[keyof typeof PurchaseOrderItemScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    barcode: 'barcode',
    name: 'name',
    description: 'description',
    unit: 'unit',
    categoryId: 'categoryId',
    supplierId: 'supplierId',
    costPrice: 'costPrice',
    wholesalePrice: 'wholesalePrice',
    retailPrice: 'retailPrice',
    minStockLevel: 'minStockLevel',
    reorderPoint: 'reorderPoint',
    leadTime: 'leadTime',
    condition: 'condition',
    createdById: 'createdById',
    updatedById: 'updatedById',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const CategoryPriceRuleScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    adjustmentType: 'adjustmentType',
    adjustmentValue: 'adjustmentValue',
    isDefault: 'isDefault',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryPriceRuleScalarFieldEnum = (typeof CategoryPriceRuleScalarFieldEnum)[keyof typeof CategoryPriceRuleScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    storeId: 'storeId',
    warehouseId: 'warehouseId',
    binId: 'binId',
    batchNumber: 'batchNumber',
    lotNumber: 'lotNumber',
    serialNumber: 'serialNumber',
    expiryDate: 'expiryDate',
    manufacturingDate: 'manufacturingDate',
    quantity: 'quantity',
    reservedQuantity: 'reservedQuantity',
    costPrice: 'costPrice',
    retailPrice: 'retailPrice',
    status: 'status',
    condition: 'condition',
    inventoryMethod: 'inventoryMethod',
    receivedDate: 'receivedDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const SaleScalarFieldEnum: {
    id: 'id',
    receiptNumber: 'receiptNumber',
    storeId: 'storeId',
    customerId: 'customerId',
    createdById: 'createdById',
    saleDate: 'saleDate',
    subtotal: 'subtotal',
    taxAmount: 'taxAmount',
    discountAmount: 'discountAmount',
    totalAmount: 'totalAmount',
    paymentMethod: 'paymentMethod',
    paymentStatus: 'paymentStatus',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaleScalarFieldEnum = (typeof SaleScalarFieldEnum)[keyof typeof SaleScalarFieldEnum]


  export const SaleItemScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    productId: 'productId',
    inventoryItemId: 'inventoryItemId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    discountAmount: 'discountAmount',
    taxAmount: 'taxAmount',
    totalPrice: 'totalPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaleItemScalarFieldEnum = (typeof SaleItemScalarFieldEnum)[keyof typeof SaleItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    referenceNumber: 'referenceNumber',
    notes: 'notes',
    processedById: 'processedById',
    processedByName: 'processedByName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ReturnScalarFieldEnum: {
    id: 'id',
    returnNumber: 'returnNumber',
    saleId: 'saleId',
    storeId: 'storeId',
    customerId: 'customerId',
    returnDate: 'returnDate',
    status: 'status',
    subtotal: 'subtotal',
    taxAmount: 'taxAmount',
    totalAmount: 'totalAmount',
    refundMethod: 'refundMethod',
    refundStatus: 'refundStatus',
    reason: 'reason',
    notes: 'notes',
    processedById: 'processedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReturnScalarFieldEnum = (typeof ReturnScalarFieldEnum)[keyof typeof ReturnScalarFieldEnum]


  export const ReturnItemScalarFieldEnum: {
    id: 'id',
    returnId: 'returnId',
    productId: 'productId',
    saleItemId: 'saleItemId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    reason: 'reason',
    condition: 'condition',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReturnItemScalarFieldEnum = (typeof ReturnItemScalarFieldEnum)[keyof typeof ReturnItemScalarFieldEnum]


  export const QualityControlScalarFieldEnum: {
    id: 'id',
    referenceNumber: 'referenceNumber',
    type: 'type',
    status: 'status',
    warehouseId: 'warehouseId',
    purchaseOrderId: 'purchaseOrderId',
    returnId: 'returnId',
    inspectionDate: 'inspectionDate',
    completedDate: 'completedDate',
    inspectedById: 'inspectedById',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QualityControlScalarFieldEnum = (typeof QualityControlScalarFieldEnum)[keyof typeof QualityControlScalarFieldEnum]


  export const QualityControlItemScalarFieldEnum: {
    id: 'id',
    qualityControlId: 'qualityControlId',
    productId: 'productId',
    quantity: 'quantity',
    passedQuantity: 'passedQuantity',
    failedQuantity: 'failedQuantity',
    pendingQuantity: 'pendingQuantity',
    status: 'status',
    reason: 'reason',
    action: 'action',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QualityControlItemScalarFieldEnum = (typeof QualityControlItemScalarFieldEnum)[keyof typeof QualityControlItemScalarFieldEnum]


  export const TransferScalarFieldEnum: {
    id: 'id',
    transferNumber: 'transferNumber',
    fromWarehouseId: 'fromWarehouseId',
    fromStoreId: 'fromStoreId',
    toWarehouseId: 'toWarehouseId',
    toStoreId: 'toStoreId',
    status: 'status',
    transferType: 'transferType',
    priority: 'priority',
    requestedById: 'requestedById',
    approvedById: 'approvedById',
    rejectedById: 'rejectedById',
    completedById: 'completedById',
    requestedDate: 'requestedDate',
    approvedDate: 'approvedDate',
    rejectedDate: 'rejectedDate',
    completedDate: 'completedDate',
    expectedDeliveryDate: 'expectedDeliveryDate',
    actualDeliveryDate: 'actualDeliveryDate',
    shippingMethod: 'shippingMethod',
    trackingNumber: 'trackingNumber',
    totalItems: 'totalItems',
    totalCost: 'totalCost',
    totalRetail: 'totalRetail',
    rejectionReason: 'rejectionReason',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransferScalarFieldEnum = (typeof TransferScalarFieldEnum)[keyof typeof TransferScalarFieldEnum]


  export const TransferDocumentScalarFieldEnum: {
    id: 'id',
    transferId: 'transferId',
    name: 'name',
    type: 'type',
    url: 'url',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransferDocumentScalarFieldEnum = (typeof TransferDocumentScalarFieldEnum)[keyof typeof TransferDocumentScalarFieldEnum]


  export const TransferItemScalarFieldEnum: {
    id: 'id',
    transferId: 'transferId',
    productId: 'productId',
    quantity: 'quantity',
    sourceCostPrice: 'sourceCostPrice',
    sourceRetailPrice: 'sourceRetailPrice',
    targetCostPrice: 'targetCostPrice',
    targetRetailPrice: 'targetRetailPrice',
    condition: 'condition',
    adjustmentReason: 'adjustmentReason',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransferItemScalarFieldEnum = (typeof TransferItemScalarFieldEnum)[keyof typeof TransferItemScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    loyaltyPoints: 'loyaltyPoints',
    loyaltyTier: 'loyaltyTier',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    type: 'type',
    street: 'street',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    isDefault: 'isDefault',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const LoyaltyProgramScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    pointsPerDollar: 'pointsPerDollar',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoyaltyProgramScalarFieldEnum = (typeof LoyaltyProgramScalarFieldEnum)[keyof typeof LoyaltyProgramScalarFieldEnum]


  export const LoyaltyProgramTierScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    name: 'name',
    description: 'description',
    requiredPoints: 'requiredPoints',
    pointsMultiplier: 'pointsMultiplier',
    benefits: 'benefits',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoyaltyProgramTierScalarFieldEnum = (typeof LoyaltyProgramTierScalarFieldEnum)[keyof typeof LoyaltyProgramTierScalarFieldEnum]


  export const LoyaltyTransactionScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    programId: 'programId',
    points: 'points',
    type: 'type',
    description: 'description',
    referenceId: 'referenceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoyaltyTransactionScalarFieldEnum = (typeof LoyaltyTransactionScalarFieldEnum)[keyof typeof LoyaltyTransactionScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    action: 'action',
    userId: 'userId',
    userName: 'userName',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const AuditScalarFieldEnum: {
    id: 'id',
    referenceNumber: 'referenceNumber',
    warehouseId: 'warehouseId',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    completedDate: 'completedDate',
    notes: 'notes',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditScalarFieldEnum = (typeof AuditScalarFieldEnum)[keyof typeof AuditScalarFieldEnum]


  export const AuditItemScalarFieldEnum: {
    id: 'id',
    auditId: 'auditId',
    productId: 'productId',
    inventoryItemId: 'inventoryItemId',
    expectedQuantity: 'expectedQuantity',
    countedQuantity: 'countedQuantity',
    discrepancy: 'discrepancy',
    notes: 'notes',
    status: 'status',
    countedById: 'countedById',
    countedAt: 'countedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditItemScalarFieldEnum = (typeof AuditItemScalarFieldEnum)[keyof typeof AuditItemScalarFieldEnum]


  export const AuditAssignmentScalarFieldEnum: {
    id: 'id',
    auditId: 'auditId',
    userId: 'userId',
    assignedZones: 'assignedZones',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditAssignmentScalarFieldEnum = (typeof AuditAssignmentScalarFieldEnum)[keyof typeof AuditAssignmentScalarFieldEnum]


  export const TaxRateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    rate: 'rate',
    isDefault: 'isDefault',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaxRateScalarFieldEnum = (typeof TaxRateScalarFieldEnum)[keyof typeof TaxRateScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ContractStatus'
   */
  export type EnumContractStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractStatus'>
    


  /**
   * Reference to a field of type 'ContractStatus[]'
   */
  export type ListEnumContractStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractStatus[]'>
    


  /**
   * Reference to a field of type 'PerformanceMetricType'
   */
  export type EnumPerformanceMetricTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PerformanceMetricType'>
    


  /**
   * Reference to a field of type 'PerformanceMetricType[]'
   */
  export type ListEnumPerformanceMetricTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PerformanceMetricType[]'>
    


  /**
   * Reference to a field of type 'PurchaseOrderStatus'
   */
  export type EnumPurchaseOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseOrderStatus'>
    


  /**
   * Reference to a field of type 'PurchaseOrderStatus[]'
   */
  export type ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseOrderStatus[]'>
    


  /**
   * Reference to a field of type 'ProductCondition'
   */
  export type EnumProductConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductCondition'>
    


  /**
   * Reference to a field of type 'ProductCondition[]'
   */
  export type ListEnumProductConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductCondition[]'>
    


  /**
   * Reference to a field of type 'InventoryStatus'
   */
  export type EnumInventoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryStatus'>
    


  /**
   * Reference to a field of type 'InventoryStatus[]'
   */
  export type ListEnumInventoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryStatus[]'>
    


  /**
   * Reference to a field of type 'InventoryMethod'
   */
  export type EnumInventoryMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryMethod'>
    


  /**
   * Reference to a field of type 'InventoryMethod[]'
   */
  export type ListEnumInventoryMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'ReturnStatus'
   */
  export type EnumReturnStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReturnStatus'>
    


  /**
   * Reference to a field of type 'ReturnStatus[]'
   */
  export type ListEnumReturnStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReturnStatus[]'>
    


  /**
   * Reference to a field of type 'RefundMethod'
   */
  export type EnumRefundMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundMethod'>
    


  /**
   * Reference to a field of type 'RefundMethod[]'
   */
  export type ListEnumRefundMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundMethod[]'>
    


  /**
   * Reference to a field of type 'RefundStatus'
   */
  export type EnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundStatus'>
    


  /**
   * Reference to a field of type 'RefundStatus[]'
   */
  export type ListEnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundStatus[]'>
    


  /**
   * Reference to a field of type 'ReturnReason'
   */
  export type EnumReturnReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReturnReason'>
    


  /**
   * Reference to a field of type 'ReturnReason[]'
   */
  export type ListEnumReturnReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReturnReason[]'>
    


  /**
   * Reference to a field of type 'ItemCondition'
   */
  export type EnumItemConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemCondition'>
    


  /**
   * Reference to a field of type 'ItemCondition[]'
   */
  export type ListEnumItemConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemCondition[]'>
    


  /**
   * Reference to a field of type 'QCType'
   */
  export type EnumQCTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QCType'>
    


  /**
   * Reference to a field of type 'QCType[]'
   */
  export type ListEnumQCTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QCType[]'>
    


  /**
   * Reference to a field of type 'QCStatus'
   */
  export type EnumQCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QCStatus'>
    


  /**
   * Reference to a field of type 'QCStatus[]'
   */
  export type ListEnumQCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QCStatus[]'>
    


  /**
   * Reference to a field of type 'QCItemStatus'
   */
  export type EnumQCItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QCItemStatus'>
    


  /**
   * Reference to a field of type 'QCItemStatus[]'
   */
  export type ListEnumQCItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QCItemStatus[]'>
    


  /**
   * Reference to a field of type 'QCAction'
   */
  export type EnumQCActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QCAction'>
    


  /**
   * Reference to a field of type 'QCAction[]'
   */
  export type ListEnumQCActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QCAction[]'>
    


  /**
   * Reference to a field of type 'TransferStatus'
   */
  export type EnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus'>
    


  /**
   * Reference to a field of type 'TransferStatus[]'
   */
  export type ListEnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus[]'>
    


  /**
   * Reference to a field of type 'TransferType'
   */
  export type EnumTransferTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferType'>
    


  /**
   * Reference to a field of type 'TransferType[]'
   */
  export type ListEnumTransferTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferType[]'>
    


  /**
   * Reference to a field of type 'TransferPriority'
   */
  export type EnumTransferPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferPriority'>
    


  /**
   * Reference to a field of type 'TransferPriority[]'
   */
  export type ListEnumTransferPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferPriority[]'>
    


  /**
   * Reference to a field of type 'LoyaltyTier'
   */
  export type EnumLoyaltyTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoyaltyTier'>
    


  /**
   * Reference to a field of type 'LoyaltyTier[]'
   */
  export type ListEnumLoyaltyTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoyaltyTier[]'>
    


  /**
   * Reference to a field of type 'LoyaltyTransactionType'
   */
  export type EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoyaltyTransactionType'>
    


  /**
   * Reference to a field of type 'LoyaltyTransactionType[]'
   */
  export type ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoyaltyTransactionType[]'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'AuditAction[]'
   */
  export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


  /**
   * Reference to a field of type 'AuditStatus'
   */
  export type EnumAuditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditStatus'>
    


  /**
   * Reference to a field of type 'AuditStatus[]'
   */
  export type ListEnumAuditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditStatus[]'>
    


  /**
   * Reference to a field of type 'AuditItemStatus'
   */
  export type EnumAuditItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditItemStatus'>
    


  /**
   * Reference to a field of type 'AuditItemStatus[]'
   */
  export type ListEnumAuditItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditItemStatus[]'>
    


  /**
   * Reference to a field of type 'AssignmentStatus'
   */
  export type EnumAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentStatus'>
    


  /**
   * Reference to a field of type 'AssignmentStatus[]'
   */
  export type ListEnumAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    createdSales?: SaleListRelationFilter
    processedReturns?: ReturnListRelationFilter
    inspectedQCs?: QualityControlListRelationFilter
    warehouseStaff?: XOR<WarehouseStaffNullableScalarRelationFilter, WarehouseStaffWhereInput> | null
    storeStaff?: XOR<StoreStaffNullableScalarRelationFilter, StoreStaffWhereInput> | null
    createdAudits?: AuditListRelationFilter
    auditAssignments?: AuditAssignmentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    createdSales?: SaleOrderByRelationAggregateInput
    processedReturns?: ReturnOrderByRelationAggregateInput
    inspectedQCs?: QualityControlOrderByRelationAggregateInput
    warehouseStaff?: WarehouseStaffOrderByWithRelationInput
    storeStaff?: StoreStaffOrderByWithRelationInput
    createdAudits?: AuditOrderByRelationAggregateInput
    auditAssignments?: AuditAssignmentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    createdSales?: SaleListRelationFilter
    processedReturns?: ReturnListRelationFilter
    inspectedQCs?: QualityControlListRelationFilter
    warehouseStaff?: XOR<WarehouseStaffNullableScalarRelationFilter, WarehouseStaffWhereInput> | null
    storeStaff?: XOR<StoreStaffNullableScalarRelationFilter, StoreStaffWhereInput> | null
    createdAudits?: AuditListRelationFilter
    auditAssignments?: AuditAssignmentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type WarehouseWhereInput = {
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    id?: StringFilter<"Warehouse"> | string
    name?: StringFilter<"Warehouse"> | string
    code?: StringFilter<"Warehouse"> | string
    address?: StringNullableFilter<"Warehouse"> | string | null
    contactPerson?: StringNullableFilter<"Warehouse"> | string | null
    phone?: StringNullableFilter<"Warehouse"> | string | null
    email?: StringNullableFilter<"Warehouse"> | string | null
    isActive?: BoolFilter<"Warehouse"> | boolean
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    zones?: WarehouseZoneListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    staff?: WarehouseStaffListRelationFilter
    transfersFrom?: TransferListRelationFilter
    transfersTo?: TransferListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    qualityControls?: QualityControlListRelationFilter
    audits?: AuditListRelationFilter
  }

  export type WarehouseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    zones?: WarehouseZoneOrderByRelationAggregateInput
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    staff?: WarehouseStaffOrderByRelationAggregateInput
    transfersFrom?: TransferOrderByRelationAggregateInput
    transfersTo?: TransferOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    qualityControls?: QualityControlOrderByRelationAggregateInput
    audits?: AuditOrderByRelationAggregateInput
  }

  export type WarehouseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    name?: StringFilter<"Warehouse"> | string
    address?: StringNullableFilter<"Warehouse"> | string | null
    contactPerson?: StringNullableFilter<"Warehouse"> | string | null
    phone?: StringNullableFilter<"Warehouse"> | string | null
    email?: StringNullableFilter<"Warehouse"> | string | null
    isActive?: BoolFilter<"Warehouse"> | boolean
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    zones?: WarehouseZoneListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    staff?: WarehouseStaffListRelationFilter
    transfersFrom?: TransferListRelationFilter
    transfersTo?: TransferListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    qualityControls?: QualityControlListRelationFilter
    audits?: AuditListRelationFilter
  }, "id" | "code">

  export type WarehouseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseCountOrderByAggregateInput
    _max?: WarehouseMaxOrderByAggregateInput
    _min?: WarehouseMinOrderByAggregateInput
  }

  export type WarehouseScalarWhereWithAggregatesInput = {
    AND?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    OR?: WarehouseScalarWhereWithAggregatesInput[]
    NOT?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Warehouse"> | string
    name?: StringWithAggregatesFilter<"Warehouse"> | string
    code?: StringWithAggregatesFilter<"Warehouse"> | string
    address?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    contactPerson?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    email?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    isActive?: BoolWithAggregatesFilter<"Warehouse"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
  }

  export type WarehouseZoneWhereInput = {
    AND?: WarehouseZoneWhereInput | WarehouseZoneWhereInput[]
    OR?: WarehouseZoneWhereInput[]
    NOT?: WarehouseZoneWhereInput | WarehouseZoneWhereInput[]
    id?: StringFilter<"WarehouseZone"> | string
    name?: StringFilter<"WarehouseZone"> | string
    code?: StringFilter<"WarehouseZone"> | string
    warehouseId?: StringFilter<"WarehouseZone"> | string
    description?: StringNullableFilter<"WarehouseZone"> | string | null
    createdAt?: DateTimeFilter<"WarehouseZone"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseZone"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    aisles?: WarehouseAisleListRelationFilter
  }

  export type WarehouseZoneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    warehouseId?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    warehouse?: WarehouseOrderByWithRelationInput
    aisles?: WarehouseAisleOrderByRelationAggregateInput
  }

  export type WarehouseZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    warehouseId_code?: WarehouseZoneWarehouseIdCodeCompoundUniqueInput
    AND?: WarehouseZoneWhereInput | WarehouseZoneWhereInput[]
    OR?: WarehouseZoneWhereInput[]
    NOT?: WarehouseZoneWhereInput | WarehouseZoneWhereInput[]
    name?: StringFilter<"WarehouseZone"> | string
    code?: StringFilter<"WarehouseZone"> | string
    warehouseId?: StringFilter<"WarehouseZone"> | string
    description?: StringNullableFilter<"WarehouseZone"> | string | null
    createdAt?: DateTimeFilter<"WarehouseZone"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseZone"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    aisles?: WarehouseAisleListRelationFilter
  }, "id" | "warehouseId_code">

  export type WarehouseZoneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    warehouseId?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseZoneCountOrderByAggregateInput
    _max?: WarehouseZoneMaxOrderByAggregateInput
    _min?: WarehouseZoneMinOrderByAggregateInput
  }

  export type WarehouseZoneScalarWhereWithAggregatesInput = {
    AND?: WarehouseZoneScalarWhereWithAggregatesInput | WarehouseZoneScalarWhereWithAggregatesInput[]
    OR?: WarehouseZoneScalarWhereWithAggregatesInput[]
    NOT?: WarehouseZoneScalarWhereWithAggregatesInput | WarehouseZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WarehouseZone"> | string
    name?: StringWithAggregatesFilter<"WarehouseZone"> | string
    code?: StringWithAggregatesFilter<"WarehouseZone"> | string
    warehouseId?: StringWithAggregatesFilter<"WarehouseZone"> | string
    description?: StringNullableWithAggregatesFilter<"WarehouseZone"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WarehouseZone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WarehouseZone"> | Date | string
  }

  export type WarehouseAisleWhereInput = {
    AND?: WarehouseAisleWhereInput | WarehouseAisleWhereInput[]
    OR?: WarehouseAisleWhereInput[]
    NOT?: WarehouseAisleWhereInput | WarehouseAisleWhereInput[]
    id?: StringFilter<"WarehouseAisle"> | string
    name?: StringFilter<"WarehouseAisle"> | string
    code?: StringFilter<"WarehouseAisle"> | string
    zoneId?: StringFilter<"WarehouseAisle"> | string
    createdAt?: DateTimeFilter<"WarehouseAisle"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseAisle"> | Date | string
    zone?: XOR<WarehouseZoneScalarRelationFilter, WarehouseZoneWhereInput>
    shelves?: WarehouseShelfListRelationFilter
  }

  export type WarehouseAisleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    zone?: WarehouseZoneOrderByWithRelationInput
    shelves?: WarehouseShelfOrderByRelationAggregateInput
  }

  export type WarehouseAisleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    zoneId_code?: WarehouseAisleZoneIdCodeCompoundUniqueInput
    AND?: WarehouseAisleWhereInput | WarehouseAisleWhereInput[]
    OR?: WarehouseAisleWhereInput[]
    NOT?: WarehouseAisleWhereInput | WarehouseAisleWhereInput[]
    name?: StringFilter<"WarehouseAisle"> | string
    code?: StringFilter<"WarehouseAisle"> | string
    zoneId?: StringFilter<"WarehouseAisle"> | string
    createdAt?: DateTimeFilter<"WarehouseAisle"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseAisle"> | Date | string
    zone?: XOR<WarehouseZoneScalarRelationFilter, WarehouseZoneWhereInput>
    shelves?: WarehouseShelfListRelationFilter
  }, "id" | "zoneId_code">

  export type WarehouseAisleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseAisleCountOrderByAggregateInput
    _max?: WarehouseAisleMaxOrderByAggregateInput
    _min?: WarehouseAisleMinOrderByAggregateInput
  }

  export type WarehouseAisleScalarWhereWithAggregatesInput = {
    AND?: WarehouseAisleScalarWhereWithAggregatesInput | WarehouseAisleScalarWhereWithAggregatesInput[]
    OR?: WarehouseAisleScalarWhereWithAggregatesInput[]
    NOT?: WarehouseAisleScalarWhereWithAggregatesInput | WarehouseAisleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WarehouseAisle"> | string
    name?: StringWithAggregatesFilter<"WarehouseAisle"> | string
    code?: StringWithAggregatesFilter<"WarehouseAisle"> | string
    zoneId?: StringWithAggregatesFilter<"WarehouseAisle"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WarehouseAisle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WarehouseAisle"> | Date | string
  }

  export type WarehouseShelfWhereInput = {
    AND?: WarehouseShelfWhereInput | WarehouseShelfWhereInput[]
    OR?: WarehouseShelfWhereInput[]
    NOT?: WarehouseShelfWhereInput | WarehouseShelfWhereInput[]
    id?: StringFilter<"WarehouseShelf"> | string
    name?: StringFilter<"WarehouseShelf"> | string
    code?: StringFilter<"WarehouseShelf"> | string
    aisleId?: StringFilter<"WarehouseShelf"> | string
    createdAt?: DateTimeFilter<"WarehouseShelf"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseShelf"> | Date | string
    aisle?: XOR<WarehouseAisleScalarRelationFilter, WarehouseAisleWhereInput>
    bins?: WarehouseBinListRelationFilter
  }

  export type WarehouseShelfOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    aisleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aisle?: WarehouseAisleOrderByWithRelationInput
    bins?: WarehouseBinOrderByRelationAggregateInput
  }

  export type WarehouseShelfWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    aisleId_code?: WarehouseShelfAisleIdCodeCompoundUniqueInput
    AND?: WarehouseShelfWhereInput | WarehouseShelfWhereInput[]
    OR?: WarehouseShelfWhereInput[]
    NOT?: WarehouseShelfWhereInput | WarehouseShelfWhereInput[]
    name?: StringFilter<"WarehouseShelf"> | string
    code?: StringFilter<"WarehouseShelf"> | string
    aisleId?: StringFilter<"WarehouseShelf"> | string
    createdAt?: DateTimeFilter<"WarehouseShelf"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseShelf"> | Date | string
    aisle?: XOR<WarehouseAisleScalarRelationFilter, WarehouseAisleWhereInput>
    bins?: WarehouseBinListRelationFilter
  }, "id" | "aisleId_code">

  export type WarehouseShelfOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    aisleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseShelfCountOrderByAggregateInput
    _max?: WarehouseShelfMaxOrderByAggregateInput
    _min?: WarehouseShelfMinOrderByAggregateInput
  }

  export type WarehouseShelfScalarWhereWithAggregatesInput = {
    AND?: WarehouseShelfScalarWhereWithAggregatesInput | WarehouseShelfScalarWhereWithAggregatesInput[]
    OR?: WarehouseShelfScalarWhereWithAggregatesInput[]
    NOT?: WarehouseShelfScalarWhereWithAggregatesInput | WarehouseShelfScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WarehouseShelf"> | string
    name?: StringWithAggregatesFilter<"WarehouseShelf"> | string
    code?: StringWithAggregatesFilter<"WarehouseShelf"> | string
    aisleId?: StringWithAggregatesFilter<"WarehouseShelf"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WarehouseShelf"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WarehouseShelf"> | Date | string
  }

  export type WarehouseBinWhereInput = {
    AND?: WarehouseBinWhereInput | WarehouseBinWhereInput[]
    OR?: WarehouseBinWhereInput[]
    NOT?: WarehouseBinWhereInput | WarehouseBinWhereInput[]
    id?: StringFilter<"WarehouseBin"> | string
    name?: StringFilter<"WarehouseBin"> | string
    code?: StringFilter<"WarehouseBin"> | string
    shelfId?: StringFilter<"WarehouseBin"> | string
    capacity?: IntNullableFilter<"WarehouseBin"> | number | null
    createdAt?: DateTimeFilter<"WarehouseBin"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseBin"> | Date | string
    shelf?: XOR<WarehouseShelfScalarRelationFilter, WarehouseShelfWhereInput>
    inventoryItems?: InventoryItemListRelationFilter
  }

  export type WarehouseBinOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    shelfId?: SortOrder
    capacity?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shelf?: WarehouseShelfOrderByWithRelationInput
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
  }

  export type WarehouseBinWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shelfId_code?: WarehouseBinShelfIdCodeCompoundUniqueInput
    AND?: WarehouseBinWhereInput | WarehouseBinWhereInput[]
    OR?: WarehouseBinWhereInput[]
    NOT?: WarehouseBinWhereInput | WarehouseBinWhereInput[]
    name?: StringFilter<"WarehouseBin"> | string
    code?: StringFilter<"WarehouseBin"> | string
    shelfId?: StringFilter<"WarehouseBin"> | string
    capacity?: IntNullableFilter<"WarehouseBin"> | number | null
    createdAt?: DateTimeFilter<"WarehouseBin"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseBin"> | Date | string
    shelf?: XOR<WarehouseShelfScalarRelationFilter, WarehouseShelfWhereInput>
    inventoryItems?: InventoryItemListRelationFilter
  }, "id" | "shelfId_code">

  export type WarehouseBinOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    shelfId?: SortOrder
    capacity?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseBinCountOrderByAggregateInput
    _avg?: WarehouseBinAvgOrderByAggregateInput
    _max?: WarehouseBinMaxOrderByAggregateInput
    _min?: WarehouseBinMinOrderByAggregateInput
    _sum?: WarehouseBinSumOrderByAggregateInput
  }

  export type WarehouseBinScalarWhereWithAggregatesInput = {
    AND?: WarehouseBinScalarWhereWithAggregatesInput | WarehouseBinScalarWhereWithAggregatesInput[]
    OR?: WarehouseBinScalarWhereWithAggregatesInput[]
    NOT?: WarehouseBinScalarWhereWithAggregatesInput | WarehouseBinScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WarehouseBin"> | string
    name?: StringWithAggregatesFilter<"WarehouseBin"> | string
    code?: StringWithAggregatesFilter<"WarehouseBin"> | string
    shelfId?: StringWithAggregatesFilter<"WarehouseBin"> | string
    capacity?: IntNullableWithAggregatesFilter<"WarehouseBin"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"WarehouseBin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WarehouseBin"> | Date | string
  }

  export type WarehouseStaffWhereInput = {
    AND?: WarehouseStaffWhereInput | WarehouseStaffWhereInput[]
    OR?: WarehouseStaffWhereInput[]
    NOT?: WarehouseStaffWhereInput | WarehouseStaffWhereInput[]
    id?: StringFilter<"WarehouseStaff"> | string
    userId?: StringFilter<"WarehouseStaff"> | string
    warehouseId?: StringFilter<"WarehouseStaff"> | string
    position?: StringNullableFilter<"WarehouseStaff"> | string | null
    isManager?: BoolFilter<"WarehouseStaff"> | boolean
    createdAt?: DateTimeFilter<"WarehouseStaff"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseStaff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
  }

  export type WarehouseStaffOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    position?: SortOrderInput | SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
  }

  export type WarehouseStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: WarehouseStaffWhereInput | WarehouseStaffWhereInput[]
    OR?: WarehouseStaffWhereInput[]
    NOT?: WarehouseStaffWhereInput | WarehouseStaffWhereInput[]
    warehouseId?: StringFilter<"WarehouseStaff"> | string
    position?: StringNullableFilter<"WarehouseStaff"> | string | null
    isManager?: BoolFilter<"WarehouseStaff"> | boolean
    createdAt?: DateTimeFilter<"WarehouseStaff"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseStaff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
  }, "id" | "userId">

  export type WarehouseStaffOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    position?: SortOrderInput | SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseStaffCountOrderByAggregateInput
    _max?: WarehouseStaffMaxOrderByAggregateInput
    _min?: WarehouseStaffMinOrderByAggregateInput
  }

  export type WarehouseStaffScalarWhereWithAggregatesInput = {
    AND?: WarehouseStaffScalarWhereWithAggregatesInput | WarehouseStaffScalarWhereWithAggregatesInput[]
    OR?: WarehouseStaffScalarWhereWithAggregatesInput[]
    NOT?: WarehouseStaffScalarWhereWithAggregatesInput | WarehouseStaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WarehouseStaff"> | string
    userId?: StringWithAggregatesFilter<"WarehouseStaff"> | string
    warehouseId?: StringWithAggregatesFilter<"WarehouseStaff"> | string
    position?: StringNullableWithAggregatesFilter<"WarehouseStaff"> | string | null
    isManager?: BoolWithAggregatesFilter<"WarehouseStaff"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WarehouseStaff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WarehouseStaff"> | Date | string
  }

  export type StoreWhereInput = {
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    id?: StringFilter<"Store"> | string
    name?: StringFilter<"Store"> | string
    code?: StringFilter<"Store"> | string
    address?: StringNullableFilter<"Store"> | string | null
    phone?: StringNullableFilter<"Store"> | string | null
    email?: StringNullableFilter<"Store"> | string | null
    openingHours?: StringNullableFilter<"Store"> | string | null
    isActive?: BoolFilter<"Store"> | boolean
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    inventoryItems?: InventoryItemListRelationFilter
    sales?: SaleListRelationFilter
    returns?: ReturnListRelationFilter
    staff?: StoreStaffListRelationFilter
    transfersFrom?: TransferListRelationFilter
    transfersTo?: TransferListRelationFilter
  }

  export type StoreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    openingHours?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    sales?: SaleOrderByRelationAggregateInput
    returns?: ReturnOrderByRelationAggregateInput
    staff?: StoreStaffOrderByRelationAggregateInput
    transfersFrom?: TransferOrderByRelationAggregateInput
    transfersTo?: TransferOrderByRelationAggregateInput
  }

  export type StoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    name?: StringFilter<"Store"> | string
    address?: StringNullableFilter<"Store"> | string | null
    phone?: StringNullableFilter<"Store"> | string | null
    email?: StringNullableFilter<"Store"> | string | null
    openingHours?: StringNullableFilter<"Store"> | string | null
    isActive?: BoolFilter<"Store"> | boolean
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    inventoryItems?: InventoryItemListRelationFilter
    sales?: SaleListRelationFilter
    returns?: ReturnListRelationFilter
    staff?: StoreStaffListRelationFilter
    transfersFrom?: TransferListRelationFilter
    transfersTo?: TransferListRelationFilter
  }, "id" | "code">

  export type StoreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    openingHours?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreCountOrderByAggregateInput
    _max?: StoreMaxOrderByAggregateInput
    _min?: StoreMinOrderByAggregateInput
  }

  export type StoreScalarWhereWithAggregatesInput = {
    AND?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    OR?: StoreScalarWhereWithAggregatesInput[]
    NOT?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Store"> | string
    name?: StringWithAggregatesFilter<"Store"> | string
    code?: StringWithAggregatesFilter<"Store"> | string
    address?: StringNullableWithAggregatesFilter<"Store"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Store"> | string | null
    email?: StringNullableWithAggregatesFilter<"Store"> | string | null
    openingHours?: StringNullableWithAggregatesFilter<"Store"> | string | null
    isActive?: BoolWithAggregatesFilter<"Store"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
  }

  export type StoreStaffWhereInput = {
    AND?: StoreStaffWhereInput | StoreStaffWhereInput[]
    OR?: StoreStaffWhereInput[]
    NOT?: StoreStaffWhereInput | StoreStaffWhereInput[]
    id?: StringFilter<"StoreStaff"> | string
    userId?: StringFilter<"StoreStaff"> | string
    storeId?: StringFilter<"StoreStaff"> | string
    position?: StringNullableFilter<"StoreStaff"> | string | null
    isManager?: BoolFilter<"StoreStaff"> | boolean
    createdAt?: DateTimeFilter<"StoreStaff"> | Date | string
    updatedAt?: DateTimeFilter<"StoreStaff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
  }

  export type StoreStaffOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    position?: SortOrderInput | SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
  }

  export type StoreStaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: StoreStaffWhereInput | StoreStaffWhereInput[]
    OR?: StoreStaffWhereInput[]
    NOT?: StoreStaffWhereInput | StoreStaffWhereInput[]
    storeId?: StringFilter<"StoreStaff"> | string
    position?: StringNullableFilter<"StoreStaff"> | string | null
    isManager?: BoolFilter<"StoreStaff"> | boolean
    createdAt?: DateTimeFilter<"StoreStaff"> | Date | string
    updatedAt?: DateTimeFilter<"StoreStaff"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
  }, "id" | "userId">

  export type StoreStaffOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    position?: SortOrderInput | SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreStaffCountOrderByAggregateInput
    _max?: StoreStaffMaxOrderByAggregateInput
    _min?: StoreStaffMinOrderByAggregateInput
  }

  export type StoreStaffScalarWhereWithAggregatesInput = {
    AND?: StoreStaffScalarWhereWithAggregatesInput | StoreStaffScalarWhereWithAggregatesInput[]
    OR?: StoreStaffScalarWhereWithAggregatesInput[]
    NOT?: StoreStaffScalarWhereWithAggregatesInput | StoreStaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreStaff"> | string
    userId?: StringWithAggregatesFilter<"StoreStaff"> | string
    storeId?: StringWithAggregatesFilter<"StoreStaff"> | string
    position?: StringNullableWithAggregatesFilter<"StoreStaff"> | string | null
    isManager?: BoolWithAggregatesFilter<"StoreStaff"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StoreStaff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StoreStaff"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    city?: StringNullableFilter<"Supplier"> | string | null
    state?: StringNullableFilter<"Supplier"> | string | null
    postalCode?: StringNullableFilter<"Supplier"> | string | null
    country?: StringNullableFilter<"Supplier"> | string | null
    taxId?: StringNullableFilter<"Supplier"> | string | null
    paymentTerms?: StringNullableFilter<"Supplier"> | string | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    rating?: IntNullableFilter<"Supplier"> | number | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdById?: StringNullableFilter<"Supplier"> | string | null
    updatedById?: StringNullableFilter<"Supplier"> | string | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    products?: ProductListRelationFilter
    contracts?: SupplierContractListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    performanceMetrics?: SupplierPerformanceMetricListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    contracts?: SupplierContractOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    performanceMetrics?: SupplierPerformanceMetricOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    city?: StringNullableFilter<"Supplier"> | string | null
    state?: StringNullableFilter<"Supplier"> | string | null
    postalCode?: StringNullableFilter<"Supplier"> | string | null
    country?: StringNullableFilter<"Supplier"> | string | null
    taxId?: StringNullableFilter<"Supplier"> | string | null
    paymentTerms?: StringNullableFilter<"Supplier"> | string | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    rating?: IntNullableFilter<"Supplier"> | number | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdById?: StringNullableFilter<"Supplier"> | string | null
    updatedById?: StringNullableFilter<"Supplier"> | string | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    products?: ProductListRelationFilter
    contracts?: SupplierContractListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    performanceMetrics?: SupplierPerformanceMetricListRelationFilter
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    contactPerson?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    address?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    city?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    state?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    country?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    paymentTerms?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    rating?: IntNullableWithAggregatesFilter<"Supplier"> | number | null
    isActive?: BoolWithAggregatesFilter<"Supplier"> | boolean
    createdById?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type SupplierContractWhereInput = {
    AND?: SupplierContractWhereInput | SupplierContractWhereInput[]
    OR?: SupplierContractWhereInput[]
    NOT?: SupplierContractWhereInput | SupplierContractWhereInput[]
    id?: StringFilter<"SupplierContract"> | string
    supplierId?: StringFilter<"SupplierContract"> | string
    contractNumber?: StringFilter<"SupplierContract"> | string
    title?: StringFilter<"SupplierContract"> | string
    description?: StringNullableFilter<"SupplierContract"> | string | null
    startDate?: DateTimeFilter<"SupplierContract"> | Date | string
    endDate?: DateTimeNullableFilter<"SupplierContract"> | Date | string | null
    renewalDate?: DateTimeNullableFilter<"SupplierContract"> | Date | string | null
    value?: FloatNullableFilter<"SupplierContract"> | number | null
    terms?: StringNullableFilter<"SupplierContract"> | string | null
    paymentTerms?: StringNullableFilter<"SupplierContract"> | string | null
    status?: EnumContractStatusFilter<"SupplierContract"> | $Enums.ContractStatus
    documentUrl?: StringNullableFilter<"SupplierContract"> | string | null
    createdById?: StringNullableFilter<"SupplierContract"> | string | null
    updatedById?: StringNullableFilter<"SupplierContract"> | string | null
    createdAt?: DateTimeFilter<"SupplierContract"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierContract"> | Date | string
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }

  export type SupplierContractOrderByWithRelationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    contractNumber?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    renewalDate?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    status?: SortOrder
    documentUrl?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
  }

  export type SupplierContractWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierContractWhereInput | SupplierContractWhereInput[]
    OR?: SupplierContractWhereInput[]
    NOT?: SupplierContractWhereInput | SupplierContractWhereInput[]
    supplierId?: StringFilter<"SupplierContract"> | string
    contractNumber?: StringFilter<"SupplierContract"> | string
    title?: StringFilter<"SupplierContract"> | string
    description?: StringNullableFilter<"SupplierContract"> | string | null
    startDate?: DateTimeFilter<"SupplierContract"> | Date | string
    endDate?: DateTimeNullableFilter<"SupplierContract"> | Date | string | null
    renewalDate?: DateTimeNullableFilter<"SupplierContract"> | Date | string | null
    value?: FloatNullableFilter<"SupplierContract"> | number | null
    terms?: StringNullableFilter<"SupplierContract"> | string | null
    paymentTerms?: StringNullableFilter<"SupplierContract"> | string | null
    status?: EnumContractStatusFilter<"SupplierContract"> | $Enums.ContractStatus
    documentUrl?: StringNullableFilter<"SupplierContract"> | string | null
    createdById?: StringNullableFilter<"SupplierContract"> | string | null
    updatedById?: StringNullableFilter<"SupplierContract"> | string | null
    createdAt?: DateTimeFilter<"SupplierContract"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierContract"> | Date | string
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }, "id">

  export type SupplierContractOrderByWithAggregationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    contractNumber?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    renewalDate?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    status?: SortOrder
    documentUrl?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierContractCountOrderByAggregateInput
    _avg?: SupplierContractAvgOrderByAggregateInput
    _max?: SupplierContractMaxOrderByAggregateInput
    _min?: SupplierContractMinOrderByAggregateInput
    _sum?: SupplierContractSumOrderByAggregateInput
  }

  export type SupplierContractScalarWhereWithAggregatesInput = {
    AND?: SupplierContractScalarWhereWithAggregatesInput | SupplierContractScalarWhereWithAggregatesInput[]
    OR?: SupplierContractScalarWhereWithAggregatesInput[]
    NOT?: SupplierContractScalarWhereWithAggregatesInput | SupplierContractScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupplierContract"> | string
    supplierId?: StringWithAggregatesFilter<"SupplierContract"> | string
    contractNumber?: StringWithAggregatesFilter<"SupplierContract"> | string
    title?: StringWithAggregatesFilter<"SupplierContract"> | string
    description?: StringNullableWithAggregatesFilter<"SupplierContract"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"SupplierContract"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"SupplierContract"> | Date | string | null
    renewalDate?: DateTimeNullableWithAggregatesFilter<"SupplierContract"> | Date | string | null
    value?: FloatNullableWithAggregatesFilter<"SupplierContract"> | number | null
    terms?: StringNullableWithAggregatesFilter<"SupplierContract"> | string | null
    paymentTerms?: StringNullableWithAggregatesFilter<"SupplierContract"> | string | null
    status?: EnumContractStatusWithAggregatesFilter<"SupplierContract"> | $Enums.ContractStatus
    documentUrl?: StringNullableWithAggregatesFilter<"SupplierContract"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"SupplierContract"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"SupplierContract"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SupplierContract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupplierContract"> | Date | string
  }

  export type SupplierPerformanceMetricWhereInput = {
    AND?: SupplierPerformanceMetricWhereInput | SupplierPerformanceMetricWhereInput[]
    OR?: SupplierPerformanceMetricWhereInput[]
    NOT?: SupplierPerformanceMetricWhereInput | SupplierPerformanceMetricWhereInput[]
    id?: StringFilter<"SupplierPerformanceMetric"> | string
    supplierId?: StringFilter<"SupplierPerformanceMetric"> | string
    metricType?: EnumPerformanceMetricTypeFilter<"SupplierPerformanceMetric"> | $Enums.PerformanceMetricType
    date?: DateTimeFilter<"SupplierPerformanceMetric"> | Date | string
    value?: FloatFilter<"SupplierPerformanceMetric"> | number
    notes?: StringNullableFilter<"SupplierPerformanceMetric"> | string | null
    createdById?: StringNullableFilter<"SupplierPerformanceMetric"> | string | null
    createdAt?: DateTimeFilter<"SupplierPerformanceMetric"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierPerformanceMetric"> | Date | string
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }

  export type SupplierPerformanceMetricOrderByWithRelationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    metricType?: SortOrder
    date?: SortOrder
    value?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
  }

  export type SupplierPerformanceMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierPerformanceMetricWhereInput | SupplierPerformanceMetricWhereInput[]
    OR?: SupplierPerformanceMetricWhereInput[]
    NOT?: SupplierPerformanceMetricWhereInput | SupplierPerformanceMetricWhereInput[]
    supplierId?: StringFilter<"SupplierPerformanceMetric"> | string
    metricType?: EnumPerformanceMetricTypeFilter<"SupplierPerformanceMetric"> | $Enums.PerformanceMetricType
    date?: DateTimeFilter<"SupplierPerformanceMetric"> | Date | string
    value?: FloatFilter<"SupplierPerformanceMetric"> | number
    notes?: StringNullableFilter<"SupplierPerformanceMetric"> | string | null
    createdById?: StringNullableFilter<"SupplierPerformanceMetric"> | string | null
    createdAt?: DateTimeFilter<"SupplierPerformanceMetric"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierPerformanceMetric"> | Date | string
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
  }, "id">

  export type SupplierPerformanceMetricOrderByWithAggregationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    metricType?: SortOrder
    date?: SortOrder
    value?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierPerformanceMetricCountOrderByAggregateInput
    _avg?: SupplierPerformanceMetricAvgOrderByAggregateInput
    _max?: SupplierPerformanceMetricMaxOrderByAggregateInput
    _min?: SupplierPerformanceMetricMinOrderByAggregateInput
    _sum?: SupplierPerformanceMetricSumOrderByAggregateInput
  }

  export type SupplierPerformanceMetricScalarWhereWithAggregatesInput = {
    AND?: SupplierPerformanceMetricScalarWhereWithAggregatesInput | SupplierPerformanceMetricScalarWhereWithAggregatesInput[]
    OR?: SupplierPerformanceMetricScalarWhereWithAggregatesInput[]
    NOT?: SupplierPerformanceMetricScalarWhereWithAggregatesInput | SupplierPerformanceMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupplierPerformanceMetric"> | string
    supplierId?: StringWithAggregatesFilter<"SupplierPerformanceMetric"> | string
    metricType?: EnumPerformanceMetricTypeWithAggregatesFilter<"SupplierPerformanceMetric"> | $Enums.PerformanceMetricType
    date?: DateTimeWithAggregatesFilter<"SupplierPerformanceMetric"> | Date | string
    value?: FloatWithAggregatesFilter<"SupplierPerformanceMetric"> | number
    notes?: StringNullableWithAggregatesFilter<"SupplierPerformanceMetric"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"SupplierPerformanceMetric"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SupplierPerformanceMetric"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupplierPerformanceMetric"> | Date | string
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    orderNumber?: StringFilter<"PurchaseOrder"> | string
    supplierId?: StringFilter<"PurchaseOrder"> | string
    warehouseId?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expectedDeliveryDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    status?: EnumPurchaseOrderStatusFilter<"PurchaseOrder"> | $Enums.PurchaseOrderStatus
    subtotal?: FloatFilter<"PurchaseOrder"> | number
    taxAmount?: FloatFilter<"PurchaseOrder"> | number
    totalAmount?: FloatFilter<"PurchaseOrder"> | number
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdById?: StringNullableFilter<"PurchaseOrder"> | string | null
    approvedById?: StringNullableFilter<"PurchaseOrder"> | string | null
    receivedById?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    items?: PurchaseOrderItemListRelationFilter
    qualityControls?: QualityControlListRelationFilter
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    supplierId?: SortOrder
    warehouseId?: SortOrder
    orderDate?: SortOrder
    expectedDeliveryDate?: SortOrderInput | SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    receivedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
    items?: PurchaseOrderItemOrderByRelationAggregateInput
    qualityControls?: QualityControlOrderByRelationAggregateInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    supplierId?: StringFilter<"PurchaseOrder"> | string
    warehouseId?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expectedDeliveryDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    status?: EnumPurchaseOrderStatusFilter<"PurchaseOrder"> | $Enums.PurchaseOrderStatus
    subtotal?: FloatFilter<"PurchaseOrder"> | number
    taxAmount?: FloatFilter<"PurchaseOrder"> | number
    totalAmount?: FloatFilter<"PurchaseOrder"> | number
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdById?: StringNullableFilter<"PurchaseOrder"> | string | null
    approvedById?: StringNullableFilter<"PurchaseOrder"> | string | null
    receivedById?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    items?: PurchaseOrderItemListRelationFilter
    qualityControls?: QualityControlListRelationFilter
  }, "id" | "orderNumber">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    supplierId?: SortOrder
    warehouseId?: SortOrder
    orderDate?: SortOrder
    expectedDeliveryDate?: SortOrderInput | SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    receivedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _avg?: PurchaseOrderAvgOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
    _sum?: PurchaseOrderSumOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    orderNumber?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    supplierId?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    warehouseId?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    expectedDeliveryDate?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    status?: EnumPurchaseOrderStatusWithAggregatesFilter<"PurchaseOrder"> | $Enums.PurchaseOrderStatus
    subtotal?: FloatWithAggregatesFilter<"PurchaseOrder"> | number
    taxAmount?: FloatWithAggregatesFilter<"PurchaseOrder"> | number
    totalAmount?: FloatWithAggregatesFilter<"PurchaseOrder"> | number
    notes?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    approvedById?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    receivedById?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
  }

  export type PurchaseOrderItemWhereInput = {
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    id?: StringFilter<"PurchaseOrderItem"> | string
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    productId?: StringFilter<"PurchaseOrderItem"> | string
    quantity?: IntFilter<"PurchaseOrderItem"> | number
    unitPrice?: FloatFilter<"PurchaseOrderItem"> | number
    totalPrice?: FloatFilter<"PurchaseOrderItem"> | number
    receivedQuantity?: IntFilter<"PurchaseOrderItem"> | number
    notes?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type PurchaseOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    receivedQuantity?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type PurchaseOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    productId?: StringFilter<"PurchaseOrderItem"> | string
    quantity?: IntFilter<"PurchaseOrderItem"> | number
    unitPrice?: FloatFilter<"PurchaseOrderItem"> | number
    totalPrice?: FloatFilter<"PurchaseOrderItem"> | number
    receivedQuantity?: IntFilter<"PurchaseOrderItem"> | number
    notes?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type PurchaseOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    receivedQuantity?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderItemCountOrderByAggregateInput
    _avg?: PurchaseOrderItemAvgOrderByAggregateInput
    _max?: PurchaseOrderItemMaxOrderByAggregateInput
    _min?: PurchaseOrderItemMinOrderByAggregateInput
    _sum?: PurchaseOrderItemSumOrderByAggregateInput
  }

  export type PurchaseOrderItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    purchaseOrderId?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    productId?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    quantity?: IntWithAggregatesFilter<"PurchaseOrderItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"PurchaseOrderItem"> | number
    totalPrice?: FloatWithAggregatesFilter<"PurchaseOrderItem"> | number
    receivedQuantity?: IntWithAggregatesFilter<"PurchaseOrderItem"> | number
    notes?: StringNullableWithAggregatesFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrderItem"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    sku?: StringFilter<"Product"> | string
    barcode?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    unit?: StringFilter<"Product"> | string
    categoryId?: StringNullableFilter<"Product"> | string | null
    supplierId?: StringNullableFilter<"Product"> | string | null
    costPrice?: FloatFilter<"Product"> | number
    wholesalePrice?: FloatFilter<"Product"> | number
    retailPrice?: FloatFilter<"Product"> | number
    minStockLevel?: IntFilter<"Product"> | number
    reorderPoint?: IntFilter<"Product"> | number
    leadTime?: IntNullableFilter<"Product"> | number | null
    condition?: EnumProductConditionFilter<"Product"> | $Enums.ProductCondition
    createdById?: StringNullableFilter<"Product"> | string | null
    updatedById?: StringNullableFilter<"Product"> | string | null
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    qualityControlItems?: QualityControlItemListRelationFilter
    returnItems?: ReturnItemListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    saleItems?: SaleItemListRelationFilter
    transferItems?: TransferItemListRelationFilter
    auditItems?: AuditItemListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    barcode?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    minStockLevel?: SortOrder
    reorderPoint?: SortOrder
    leadTime?: SortOrderInput | SortOrder
    condition?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CategoryOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    purchaseOrderItems?: PurchaseOrderItemOrderByRelationAggregateInput
    qualityControlItems?: QualityControlItemOrderByRelationAggregateInput
    returnItems?: ReturnItemOrderByRelationAggregateInput
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    saleItems?: SaleItemOrderByRelationAggregateInput
    transferItems?: TransferItemOrderByRelationAggregateInput
    auditItems?: AuditItemOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    barcode?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    unit?: StringFilter<"Product"> | string
    categoryId?: StringNullableFilter<"Product"> | string | null
    supplierId?: StringNullableFilter<"Product"> | string | null
    costPrice?: FloatFilter<"Product"> | number
    wholesalePrice?: FloatFilter<"Product"> | number
    retailPrice?: FloatFilter<"Product"> | number
    minStockLevel?: IntFilter<"Product"> | number
    reorderPoint?: IntFilter<"Product"> | number
    leadTime?: IntNullableFilter<"Product"> | number | null
    condition?: EnumProductConditionFilter<"Product"> | $Enums.ProductCondition
    createdById?: StringNullableFilter<"Product"> | string | null
    updatedById?: StringNullableFilter<"Product"> | string | null
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    qualityControlItems?: QualityControlItemListRelationFilter
    returnItems?: ReturnItemListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    saleItems?: SaleItemListRelationFilter
    transferItems?: TransferItemListRelationFilter
    auditItems?: AuditItemListRelationFilter
  }, "id" | "sku">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    barcode?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    minStockLevel?: SortOrder
    reorderPoint?: SortOrder
    leadTime?: SortOrderInput | SortOrder
    condition?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    sku?: StringWithAggregatesFilter<"Product"> | string
    barcode?: StringNullableWithAggregatesFilter<"Product"> | string | null
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    unit?: StringWithAggregatesFilter<"Product"> | string
    categoryId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    supplierId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    costPrice?: FloatWithAggregatesFilter<"Product"> | number
    wholesalePrice?: FloatWithAggregatesFilter<"Product"> | number
    retailPrice?: FloatWithAggregatesFilter<"Product"> | number
    minStockLevel?: IntWithAggregatesFilter<"Product"> | number
    reorderPoint?: IntWithAggregatesFilter<"Product"> | number
    leadTime?: IntNullableWithAggregatesFilter<"Product"> | number | null
    condition?: EnumProductConditionWithAggregatesFilter<"Product"> | $Enums.ProductCondition
    createdById?: StringNullableWithAggregatesFilter<"Product"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"Product"> | string | null
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
    priceRules?: CategoryPriceRuleListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    priceRules?: CategoryPriceRuleOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
    priceRules?: CategoryPriceRuleListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    isActive?: BoolWithAggregatesFilter<"Category"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type CategoryPriceRuleWhereInput = {
    AND?: CategoryPriceRuleWhereInput | CategoryPriceRuleWhereInput[]
    OR?: CategoryPriceRuleWhereInput[]
    NOT?: CategoryPriceRuleWhereInput | CategoryPriceRuleWhereInput[]
    id?: StringFilter<"CategoryPriceRule"> | string
    categoryId?: StringFilter<"CategoryPriceRule"> | string
    adjustmentType?: StringFilter<"CategoryPriceRule"> | string
    adjustmentValue?: FloatFilter<"CategoryPriceRule"> | number
    isDefault?: BoolFilter<"CategoryPriceRule"> | boolean
    createdAt?: DateTimeFilter<"CategoryPriceRule"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryPriceRule"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type CategoryPriceRuleOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    adjustmentType?: SortOrder
    adjustmentValue?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CategoryOrderByWithRelationInput
  }

  export type CategoryPriceRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryPriceRuleWhereInput | CategoryPriceRuleWhereInput[]
    OR?: CategoryPriceRuleWhereInput[]
    NOT?: CategoryPriceRuleWhereInput | CategoryPriceRuleWhereInput[]
    categoryId?: StringFilter<"CategoryPriceRule"> | string
    adjustmentType?: StringFilter<"CategoryPriceRule"> | string
    adjustmentValue?: FloatFilter<"CategoryPriceRule"> | number
    isDefault?: BoolFilter<"CategoryPriceRule"> | boolean
    createdAt?: DateTimeFilter<"CategoryPriceRule"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryPriceRule"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "id">

  export type CategoryPriceRuleOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    adjustmentType?: SortOrder
    adjustmentValue?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryPriceRuleCountOrderByAggregateInput
    _avg?: CategoryPriceRuleAvgOrderByAggregateInput
    _max?: CategoryPriceRuleMaxOrderByAggregateInput
    _min?: CategoryPriceRuleMinOrderByAggregateInput
    _sum?: CategoryPriceRuleSumOrderByAggregateInput
  }

  export type CategoryPriceRuleScalarWhereWithAggregatesInput = {
    AND?: CategoryPriceRuleScalarWhereWithAggregatesInput | CategoryPriceRuleScalarWhereWithAggregatesInput[]
    OR?: CategoryPriceRuleScalarWhereWithAggregatesInput[]
    NOT?: CategoryPriceRuleScalarWhereWithAggregatesInput | CategoryPriceRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CategoryPriceRule"> | string
    categoryId?: StringWithAggregatesFilter<"CategoryPriceRule"> | string
    adjustmentType?: StringWithAggregatesFilter<"CategoryPriceRule"> | string
    adjustmentValue?: FloatWithAggregatesFilter<"CategoryPriceRule"> | number
    isDefault?: BoolWithAggregatesFilter<"CategoryPriceRule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CategoryPriceRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CategoryPriceRule"> | Date | string
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    productId?: StringFilter<"InventoryItem"> | string
    storeId?: StringNullableFilter<"InventoryItem"> | string | null
    warehouseId?: StringNullableFilter<"InventoryItem"> | string | null
    binId?: StringNullableFilter<"InventoryItem"> | string | null
    batchNumber?: StringNullableFilter<"InventoryItem"> | string | null
    lotNumber?: StringNullableFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableFilter<"InventoryItem"> | string | null
    expiryDate?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    manufacturingDate?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    quantity?: IntFilter<"InventoryItem"> | number
    reservedQuantity?: IntFilter<"InventoryItem"> | number
    costPrice?: FloatFilter<"InventoryItem"> | number
    retailPrice?: FloatFilter<"InventoryItem"> | number
    status?: EnumInventoryStatusFilter<"InventoryItem"> | $Enums.InventoryStatus
    condition?: EnumProductConditionFilter<"InventoryItem"> | $Enums.ProductCondition
    inventoryMethod?: EnumInventoryMethodNullableFilter<"InventoryItem"> | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFilter<"InventoryItem"> | Date | string
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    warehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    bin?: XOR<WarehouseBinNullableScalarRelationFilter, WarehouseBinWhereInput> | null
    saleItems?: SaleItemListRelationFilter
    auditItems?: AuditItemListRelationFilter
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    storeId?: SortOrderInput | SortOrder
    warehouseId?: SortOrderInput | SortOrder
    binId?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    lotNumber?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    manufacturingDate?: SortOrderInput | SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    costPrice?: SortOrder
    retailPrice?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    inventoryMethod?: SortOrderInput | SortOrder
    receivedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
    bin?: WarehouseBinOrderByWithRelationInput
    saleItems?: SaleItemOrderByRelationAggregateInput
    auditItems?: AuditItemOrderByRelationAggregateInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_storeId?: InventoryItemProductIdStoreIdCompoundUniqueInput
    productId_warehouseId_binId?: InventoryItemProductIdWarehouseIdBinIdCompoundUniqueInput
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    productId?: StringFilter<"InventoryItem"> | string
    storeId?: StringNullableFilter<"InventoryItem"> | string | null
    warehouseId?: StringNullableFilter<"InventoryItem"> | string | null
    binId?: StringNullableFilter<"InventoryItem"> | string | null
    batchNumber?: StringNullableFilter<"InventoryItem"> | string | null
    lotNumber?: StringNullableFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableFilter<"InventoryItem"> | string | null
    expiryDate?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    manufacturingDate?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    quantity?: IntFilter<"InventoryItem"> | number
    reservedQuantity?: IntFilter<"InventoryItem"> | number
    costPrice?: FloatFilter<"InventoryItem"> | number
    retailPrice?: FloatFilter<"InventoryItem"> | number
    status?: EnumInventoryStatusFilter<"InventoryItem"> | $Enums.InventoryStatus
    condition?: EnumProductConditionFilter<"InventoryItem"> | $Enums.ProductCondition
    inventoryMethod?: EnumInventoryMethodNullableFilter<"InventoryItem"> | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFilter<"InventoryItem"> | Date | string
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    store?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    warehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    bin?: XOR<WarehouseBinNullableScalarRelationFilter, WarehouseBinWhereInput> | null
    saleItems?: SaleItemListRelationFilter
    auditItems?: AuditItemListRelationFilter
  }, "id" | "productId_storeId" | "productId_warehouseId_binId">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    storeId?: SortOrderInput | SortOrder
    warehouseId?: SortOrderInput | SortOrder
    binId?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    lotNumber?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    manufacturingDate?: SortOrderInput | SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    costPrice?: SortOrder
    retailPrice?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    inventoryMethod?: SortOrderInput | SortOrder
    receivedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryItem"> | string
    productId?: StringWithAggregatesFilter<"InventoryItem"> | string
    storeId?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    warehouseId?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    binId?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    batchNumber?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    lotNumber?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"InventoryItem"> | Date | string | null
    manufacturingDate?: DateTimeNullableWithAggregatesFilter<"InventoryItem"> | Date | string | null
    quantity?: IntWithAggregatesFilter<"InventoryItem"> | number
    reservedQuantity?: IntWithAggregatesFilter<"InventoryItem"> | number
    costPrice?: FloatWithAggregatesFilter<"InventoryItem"> | number
    retailPrice?: FloatWithAggregatesFilter<"InventoryItem"> | number
    status?: EnumInventoryStatusWithAggregatesFilter<"InventoryItem"> | $Enums.InventoryStatus
    condition?: EnumProductConditionWithAggregatesFilter<"InventoryItem"> | $Enums.ProductCondition
    inventoryMethod?: EnumInventoryMethodNullableWithAggregatesFilter<"InventoryItem"> | $Enums.InventoryMethod | null
    receivedDate?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
  }

  export type SaleWhereInput = {
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    id?: StringFilter<"Sale"> | string
    receiptNumber?: StringFilter<"Sale"> | string
    storeId?: StringFilter<"Sale"> | string
    customerId?: StringNullableFilter<"Sale"> | string | null
    createdById?: StringFilter<"Sale"> | string
    saleDate?: DateTimeFilter<"Sale"> | Date | string
    subtotal?: FloatFilter<"Sale"> | number
    taxAmount?: FloatFilter<"Sale"> | number
    discountAmount?: FloatFilter<"Sale"> | number
    totalAmount?: FloatFilter<"Sale"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Sale"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFilter<"Sale"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"Sale"> | string | null
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: SaleItemListRelationFilter
    payments?: PaymentListRelationFilter
    returns?: ReturnListRelationFilter
  }

  export type SaleOrderByWithRelationInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    saleDate?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    items?: SaleItemOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    returns?: ReturnOrderByRelationAggregateInput
  }

  export type SaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    receiptNumber?: string
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    storeId?: StringFilter<"Sale"> | string
    customerId?: StringNullableFilter<"Sale"> | string | null
    createdById?: StringFilter<"Sale"> | string
    saleDate?: DateTimeFilter<"Sale"> | Date | string
    subtotal?: FloatFilter<"Sale"> | number
    taxAmount?: FloatFilter<"Sale"> | number
    discountAmount?: FloatFilter<"Sale"> | number
    totalAmount?: FloatFilter<"Sale"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Sale"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFilter<"Sale"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"Sale"> | string | null
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: SaleItemListRelationFilter
    payments?: PaymentListRelationFilter
    returns?: ReturnListRelationFilter
  }, "id" | "receiptNumber">

  export type SaleOrderByWithAggregationInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    saleDate?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SaleCountOrderByAggregateInput
    _avg?: SaleAvgOrderByAggregateInput
    _max?: SaleMaxOrderByAggregateInput
    _min?: SaleMinOrderByAggregateInput
    _sum?: SaleSumOrderByAggregateInput
  }

  export type SaleScalarWhereWithAggregatesInput = {
    AND?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    OR?: SaleScalarWhereWithAggregatesInput[]
    NOT?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sale"> | string
    receiptNumber?: StringWithAggregatesFilter<"Sale"> | string
    storeId?: StringWithAggregatesFilter<"Sale"> | string
    customerId?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    createdById?: StringWithAggregatesFilter<"Sale"> | string
    saleDate?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    subtotal?: FloatWithAggregatesFilter<"Sale"> | number
    taxAmount?: FloatWithAggregatesFilter<"Sale"> | number
    discountAmount?: FloatWithAggregatesFilter<"Sale"> | number
    totalAmount?: FloatWithAggregatesFilter<"Sale"> | number
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Sale"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"Sale"> | $Enums.PaymentStatus
    notes?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
  }

  export type SaleItemWhereInput = {
    AND?: SaleItemWhereInput | SaleItemWhereInput[]
    OR?: SaleItemWhereInput[]
    NOT?: SaleItemWhereInput | SaleItemWhereInput[]
    id?: StringFilter<"SaleItem"> | string
    saleId?: StringFilter<"SaleItem"> | string
    productId?: StringFilter<"SaleItem"> | string
    inventoryItemId?: StringFilter<"SaleItem"> | string
    quantity?: IntFilter<"SaleItem"> | number
    unitPrice?: FloatFilter<"SaleItem"> | number
    discountAmount?: FloatFilter<"SaleItem"> | number
    taxAmount?: FloatFilter<"SaleItem"> | number
    totalPrice?: FloatFilter<"SaleItem"> | number
    createdAt?: DateTimeFilter<"SaleItem"> | Date | string
    updatedAt?: DateTimeFilter<"SaleItem"> | Date | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    returnItems?: ReturnItemListRelationFilter
  }

  export type SaleItemOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sale?: SaleOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    inventoryItem?: InventoryItemOrderByWithRelationInput
    returnItems?: ReturnItemOrderByRelationAggregateInput
  }

  export type SaleItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleItemWhereInput | SaleItemWhereInput[]
    OR?: SaleItemWhereInput[]
    NOT?: SaleItemWhereInput | SaleItemWhereInput[]
    saleId?: StringFilter<"SaleItem"> | string
    productId?: StringFilter<"SaleItem"> | string
    inventoryItemId?: StringFilter<"SaleItem"> | string
    quantity?: IntFilter<"SaleItem"> | number
    unitPrice?: FloatFilter<"SaleItem"> | number
    discountAmount?: FloatFilter<"SaleItem"> | number
    taxAmount?: FloatFilter<"SaleItem"> | number
    totalPrice?: FloatFilter<"SaleItem"> | number
    createdAt?: DateTimeFilter<"SaleItem"> | Date | string
    updatedAt?: DateTimeFilter<"SaleItem"> | Date | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    returnItems?: ReturnItemListRelationFilter
  }, "id">

  export type SaleItemOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SaleItemCountOrderByAggregateInput
    _avg?: SaleItemAvgOrderByAggregateInput
    _max?: SaleItemMaxOrderByAggregateInput
    _min?: SaleItemMinOrderByAggregateInput
    _sum?: SaleItemSumOrderByAggregateInput
  }

  export type SaleItemScalarWhereWithAggregatesInput = {
    AND?: SaleItemScalarWhereWithAggregatesInput | SaleItemScalarWhereWithAggregatesInput[]
    OR?: SaleItemScalarWhereWithAggregatesInput[]
    NOT?: SaleItemScalarWhereWithAggregatesInput | SaleItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleItem"> | string
    saleId?: StringWithAggregatesFilter<"SaleItem"> | string
    productId?: StringWithAggregatesFilter<"SaleItem"> | string
    inventoryItemId?: StringWithAggregatesFilter<"SaleItem"> | string
    quantity?: IntWithAggregatesFilter<"SaleItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"SaleItem"> | number
    discountAmount?: FloatWithAggregatesFilter<"SaleItem"> | number
    taxAmount?: FloatWithAggregatesFilter<"SaleItem"> | number
    totalPrice?: FloatWithAggregatesFilter<"SaleItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SaleItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SaleItem"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    saleId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    processedById?: StringFilter<"Payment"> | string
    processedByName?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    processedById?: SortOrder
    processedByName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sale?: SaleOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    saleId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    processedById?: StringFilter<"Payment"> | string
    processedByName?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    processedById?: SortOrder
    processedByName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    saleId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    referenceNumber?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    processedById?: StringWithAggregatesFilter<"Payment"> | string
    processedByName?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type ReturnWhereInput = {
    AND?: ReturnWhereInput | ReturnWhereInput[]
    OR?: ReturnWhereInput[]
    NOT?: ReturnWhereInput | ReturnWhereInput[]
    id?: StringFilter<"Return"> | string
    returnNumber?: StringFilter<"Return"> | string
    saleId?: StringNullableFilter<"Return"> | string | null
    storeId?: StringFilter<"Return"> | string
    customerId?: StringNullableFilter<"Return"> | string | null
    returnDate?: DateTimeFilter<"Return"> | Date | string
    status?: EnumReturnStatusFilter<"Return"> | $Enums.ReturnStatus
    subtotal?: FloatFilter<"Return"> | number
    taxAmount?: FloatFilter<"Return"> | number
    totalAmount?: FloatFilter<"Return"> | number
    refundMethod?: EnumRefundMethodNullableFilter<"Return"> | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFilter<"Return"> | $Enums.RefundStatus
    reason?: StringNullableFilter<"Return"> | string | null
    notes?: StringNullableFilter<"Return"> | string | null
    processedById?: StringFilter<"Return"> | string
    createdAt?: DateTimeFilter<"Return"> | Date | string
    updatedAt?: DateTimeFilter<"Return"> | Date | string
    sale?: XOR<SaleNullableScalarRelationFilter, SaleWhereInput> | null
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    processedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: ReturnItemListRelationFilter
    qualityControls?: QualityControlListRelationFilter
  }

  export type ReturnOrderByWithRelationInput = {
    id?: SortOrder
    returnNumber?: SortOrder
    saleId?: SortOrderInput | SortOrder
    storeId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    returnDate?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    refundMethod?: SortOrderInput | SortOrder
    refundStatus?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    processedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sale?: SaleOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    processedBy?: UserOrderByWithRelationInput
    items?: ReturnItemOrderByRelationAggregateInput
    qualityControls?: QualityControlOrderByRelationAggregateInput
  }

  export type ReturnWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    returnNumber?: string
    AND?: ReturnWhereInput | ReturnWhereInput[]
    OR?: ReturnWhereInput[]
    NOT?: ReturnWhereInput | ReturnWhereInput[]
    saleId?: StringNullableFilter<"Return"> | string | null
    storeId?: StringFilter<"Return"> | string
    customerId?: StringNullableFilter<"Return"> | string | null
    returnDate?: DateTimeFilter<"Return"> | Date | string
    status?: EnumReturnStatusFilter<"Return"> | $Enums.ReturnStatus
    subtotal?: FloatFilter<"Return"> | number
    taxAmount?: FloatFilter<"Return"> | number
    totalAmount?: FloatFilter<"Return"> | number
    refundMethod?: EnumRefundMethodNullableFilter<"Return"> | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFilter<"Return"> | $Enums.RefundStatus
    reason?: StringNullableFilter<"Return"> | string | null
    notes?: StringNullableFilter<"Return"> | string | null
    processedById?: StringFilter<"Return"> | string
    createdAt?: DateTimeFilter<"Return"> | Date | string
    updatedAt?: DateTimeFilter<"Return"> | Date | string
    sale?: XOR<SaleNullableScalarRelationFilter, SaleWhereInput> | null
    store?: XOR<StoreScalarRelationFilter, StoreWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    processedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: ReturnItemListRelationFilter
    qualityControls?: QualityControlListRelationFilter
  }, "id" | "returnNumber">

  export type ReturnOrderByWithAggregationInput = {
    id?: SortOrder
    returnNumber?: SortOrder
    saleId?: SortOrderInput | SortOrder
    storeId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    returnDate?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    refundMethod?: SortOrderInput | SortOrder
    refundStatus?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    processedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReturnCountOrderByAggregateInput
    _avg?: ReturnAvgOrderByAggregateInput
    _max?: ReturnMaxOrderByAggregateInput
    _min?: ReturnMinOrderByAggregateInput
    _sum?: ReturnSumOrderByAggregateInput
  }

  export type ReturnScalarWhereWithAggregatesInput = {
    AND?: ReturnScalarWhereWithAggregatesInput | ReturnScalarWhereWithAggregatesInput[]
    OR?: ReturnScalarWhereWithAggregatesInput[]
    NOT?: ReturnScalarWhereWithAggregatesInput | ReturnScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Return"> | string
    returnNumber?: StringWithAggregatesFilter<"Return"> | string
    saleId?: StringNullableWithAggregatesFilter<"Return"> | string | null
    storeId?: StringWithAggregatesFilter<"Return"> | string
    customerId?: StringNullableWithAggregatesFilter<"Return"> | string | null
    returnDate?: DateTimeWithAggregatesFilter<"Return"> | Date | string
    status?: EnumReturnStatusWithAggregatesFilter<"Return"> | $Enums.ReturnStatus
    subtotal?: FloatWithAggregatesFilter<"Return"> | number
    taxAmount?: FloatWithAggregatesFilter<"Return"> | number
    totalAmount?: FloatWithAggregatesFilter<"Return"> | number
    refundMethod?: EnumRefundMethodNullableWithAggregatesFilter<"Return"> | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusWithAggregatesFilter<"Return"> | $Enums.RefundStatus
    reason?: StringNullableWithAggregatesFilter<"Return"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Return"> | string | null
    processedById?: StringWithAggregatesFilter<"Return"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Return"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Return"> | Date | string
  }

  export type ReturnItemWhereInput = {
    AND?: ReturnItemWhereInput | ReturnItemWhereInput[]
    OR?: ReturnItemWhereInput[]
    NOT?: ReturnItemWhereInput | ReturnItemWhereInput[]
    id?: StringFilter<"ReturnItem"> | string
    returnId?: StringFilter<"ReturnItem"> | string
    productId?: StringFilter<"ReturnItem"> | string
    saleItemId?: StringNullableFilter<"ReturnItem"> | string | null
    quantity?: IntFilter<"ReturnItem"> | number
    unitPrice?: FloatFilter<"ReturnItem"> | number
    totalPrice?: FloatFilter<"ReturnItem"> | number
    reason?: EnumReturnReasonFilter<"ReturnItem"> | $Enums.ReturnReason
    condition?: EnumItemConditionFilter<"ReturnItem"> | $Enums.ItemCondition
    notes?: StringNullableFilter<"ReturnItem"> | string | null
    createdAt?: DateTimeFilter<"ReturnItem"> | Date | string
    updatedAt?: DateTimeFilter<"ReturnItem"> | Date | string
    return?: XOR<ReturnScalarRelationFilter, ReturnWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    saleItem?: XOR<SaleItemNullableScalarRelationFilter, SaleItemWhereInput> | null
  }

  export type ReturnItemOrderByWithRelationInput = {
    id?: SortOrder
    returnId?: SortOrder
    productId?: SortOrder
    saleItemId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    reason?: SortOrder
    condition?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    return?: ReturnOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    saleItem?: SaleItemOrderByWithRelationInput
  }

  export type ReturnItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReturnItemWhereInput | ReturnItemWhereInput[]
    OR?: ReturnItemWhereInput[]
    NOT?: ReturnItemWhereInput | ReturnItemWhereInput[]
    returnId?: StringFilter<"ReturnItem"> | string
    productId?: StringFilter<"ReturnItem"> | string
    saleItemId?: StringNullableFilter<"ReturnItem"> | string | null
    quantity?: IntFilter<"ReturnItem"> | number
    unitPrice?: FloatFilter<"ReturnItem"> | number
    totalPrice?: FloatFilter<"ReturnItem"> | number
    reason?: EnumReturnReasonFilter<"ReturnItem"> | $Enums.ReturnReason
    condition?: EnumItemConditionFilter<"ReturnItem"> | $Enums.ItemCondition
    notes?: StringNullableFilter<"ReturnItem"> | string | null
    createdAt?: DateTimeFilter<"ReturnItem"> | Date | string
    updatedAt?: DateTimeFilter<"ReturnItem"> | Date | string
    return?: XOR<ReturnScalarRelationFilter, ReturnWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    saleItem?: XOR<SaleItemNullableScalarRelationFilter, SaleItemWhereInput> | null
  }, "id">

  export type ReturnItemOrderByWithAggregationInput = {
    id?: SortOrder
    returnId?: SortOrder
    productId?: SortOrder
    saleItemId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    reason?: SortOrder
    condition?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReturnItemCountOrderByAggregateInput
    _avg?: ReturnItemAvgOrderByAggregateInput
    _max?: ReturnItemMaxOrderByAggregateInput
    _min?: ReturnItemMinOrderByAggregateInput
    _sum?: ReturnItemSumOrderByAggregateInput
  }

  export type ReturnItemScalarWhereWithAggregatesInput = {
    AND?: ReturnItemScalarWhereWithAggregatesInput | ReturnItemScalarWhereWithAggregatesInput[]
    OR?: ReturnItemScalarWhereWithAggregatesInput[]
    NOT?: ReturnItemScalarWhereWithAggregatesInput | ReturnItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReturnItem"> | string
    returnId?: StringWithAggregatesFilter<"ReturnItem"> | string
    productId?: StringWithAggregatesFilter<"ReturnItem"> | string
    saleItemId?: StringNullableWithAggregatesFilter<"ReturnItem"> | string | null
    quantity?: IntWithAggregatesFilter<"ReturnItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"ReturnItem"> | number
    totalPrice?: FloatWithAggregatesFilter<"ReturnItem"> | number
    reason?: EnumReturnReasonWithAggregatesFilter<"ReturnItem"> | $Enums.ReturnReason
    condition?: EnumItemConditionWithAggregatesFilter<"ReturnItem"> | $Enums.ItemCondition
    notes?: StringNullableWithAggregatesFilter<"ReturnItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReturnItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReturnItem"> | Date | string
  }

  export type QualityControlWhereInput = {
    AND?: QualityControlWhereInput | QualityControlWhereInput[]
    OR?: QualityControlWhereInput[]
    NOT?: QualityControlWhereInput | QualityControlWhereInput[]
    id?: StringFilter<"QualityControl"> | string
    referenceNumber?: StringFilter<"QualityControl"> | string
    type?: EnumQCTypeFilter<"QualityControl"> | $Enums.QCType
    status?: EnumQCStatusFilter<"QualityControl"> | $Enums.QCStatus
    warehouseId?: StringFilter<"QualityControl"> | string
    purchaseOrderId?: StringNullableFilter<"QualityControl"> | string | null
    returnId?: StringNullableFilter<"QualityControl"> | string | null
    inspectionDate?: DateTimeFilter<"QualityControl"> | Date | string
    completedDate?: DateTimeNullableFilter<"QualityControl"> | Date | string | null
    inspectedById?: StringFilter<"QualityControl"> | string
    notes?: StringNullableFilter<"QualityControl"> | string | null
    createdAt?: DateTimeFilter<"QualityControl"> | Date | string
    updatedAt?: DateTimeFilter<"QualityControl"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    purchaseOrder?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
    return?: XOR<ReturnNullableScalarRelationFilter, ReturnWhereInput> | null
    inspectedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: QualityControlItemListRelationFilter
  }

  export type QualityControlOrderByWithRelationInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    warehouseId?: SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    returnId?: SortOrderInput | SortOrder
    inspectionDate?: SortOrder
    completedDate?: SortOrderInput | SortOrder
    inspectedById?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    warehouse?: WarehouseOrderByWithRelationInput
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    return?: ReturnOrderByWithRelationInput
    inspectedBy?: UserOrderByWithRelationInput
    items?: QualityControlItemOrderByRelationAggregateInput
  }

  export type QualityControlWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referenceNumber?: string
    AND?: QualityControlWhereInput | QualityControlWhereInput[]
    OR?: QualityControlWhereInput[]
    NOT?: QualityControlWhereInput | QualityControlWhereInput[]
    type?: EnumQCTypeFilter<"QualityControl"> | $Enums.QCType
    status?: EnumQCStatusFilter<"QualityControl"> | $Enums.QCStatus
    warehouseId?: StringFilter<"QualityControl"> | string
    purchaseOrderId?: StringNullableFilter<"QualityControl"> | string | null
    returnId?: StringNullableFilter<"QualityControl"> | string | null
    inspectionDate?: DateTimeFilter<"QualityControl"> | Date | string
    completedDate?: DateTimeNullableFilter<"QualityControl"> | Date | string | null
    inspectedById?: StringFilter<"QualityControl"> | string
    notes?: StringNullableFilter<"QualityControl"> | string | null
    createdAt?: DateTimeFilter<"QualityControl"> | Date | string
    updatedAt?: DateTimeFilter<"QualityControl"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    purchaseOrder?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
    return?: XOR<ReturnNullableScalarRelationFilter, ReturnWhereInput> | null
    inspectedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: QualityControlItemListRelationFilter
  }, "id" | "referenceNumber">

  export type QualityControlOrderByWithAggregationInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    warehouseId?: SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    returnId?: SortOrderInput | SortOrder
    inspectionDate?: SortOrder
    completedDate?: SortOrderInput | SortOrder
    inspectedById?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QualityControlCountOrderByAggregateInput
    _max?: QualityControlMaxOrderByAggregateInput
    _min?: QualityControlMinOrderByAggregateInput
  }

  export type QualityControlScalarWhereWithAggregatesInput = {
    AND?: QualityControlScalarWhereWithAggregatesInput | QualityControlScalarWhereWithAggregatesInput[]
    OR?: QualityControlScalarWhereWithAggregatesInput[]
    NOT?: QualityControlScalarWhereWithAggregatesInput | QualityControlScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QualityControl"> | string
    referenceNumber?: StringWithAggregatesFilter<"QualityControl"> | string
    type?: EnumQCTypeWithAggregatesFilter<"QualityControl"> | $Enums.QCType
    status?: EnumQCStatusWithAggregatesFilter<"QualityControl"> | $Enums.QCStatus
    warehouseId?: StringWithAggregatesFilter<"QualityControl"> | string
    purchaseOrderId?: StringNullableWithAggregatesFilter<"QualityControl"> | string | null
    returnId?: StringNullableWithAggregatesFilter<"QualityControl"> | string | null
    inspectionDate?: DateTimeWithAggregatesFilter<"QualityControl"> | Date | string
    completedDate?: DateTimeNullableWithAggregatesFilter<"QualityControl"> | Date | string | null
    inspectedById?: StringWithAggregatesFilter<"QualityControl"> | string
    notes?: StringNullableWithAggregatesFilter<"QualityControl"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QualityControl"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QualityControl"> | Date | string
  }

  export type QualityControlItemWhereInput = {
    AND?: QualityControlItemWhereInput | QualityControlItemWhereInput[]
    OR?: QualityControlItemWhereInput[]
    NOT?: QualityControlItemWhereInput | QualityControlItemWhereInput[]
    id?: StringFilter<"QualityControlItem"> | string
    qualityControlId?: StringFilter<"QualityControlItem"> | string
    productId?: StringFilter<"QualityControlItem"> | string
    quantity?: IntFilter<"QualityControlItem"> | number
    passedQuantity?: IntFilter<"QualityControlItem"> | number
    failedQuantity?: IntFilter<"QualityControlItem"> | number
    pendingQuantity?: IntFilter<"QualityControlItem"> | number
    status?: EnumQCItemStatusFilter<"QualityControlItem"> | $Enums.QCItemStatus
    reason?: StringNullableFilter<"QualityControlItem"> | string | null
    action?: EnumQCActionNullableFilter<"QualityControlItem"> | $Enums.QCAction | null
    notes?: StringNullableFilter<"QualityControlItem"> | string | null
    createdAt?: DateTimeFilter<"QualityControlItem"> | Date | string
    updatedAt?: DateTimeFilter<"QualityControlItem"> | Date | string
    qualityControl?: XOR<QualityControlScalarRelationFilter, QualityControlWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type QualityControlItemOrderByWithRelationInput = {
    id?: SortOrder
    qualityControlId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    passedQuantity?: SortOrder
    failedQuantity?: SortOrder
    pendingQuantity?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    qualityControl?: QualityControlOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type QualityControlItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QualityControlItemWhereInput | QualityControlItemWhereInput[]
    OR?: QualityControlItemWhereInput[]
    NOT?: QualityControlItemWhereInput | QualityControlItemWhereInput[]
    qualityControlId?: StringFilter<"QualityControlItem"> | string
    productId?: StringFilter<"QualityControlItem"> | string
    quantity?: IntFilter<"QualityControlItem"> | number
    passedQuantity?: IntFilter<"QualityControlItem"> | number
    failedQuantity?: IntFilter<"QualityControlItem"> | number
    pendingQuantity?: IntFilter<"QualityControlItem"> | number
    status?: EnumQCItemStatusFilter<"QualityControlItem"> | $Enums.QCItemStatus
    reason?: StringNullableFilter<"QualityControlItem"> | string | null
    action?: EnumQCActionNullableFilter<"QualityControlItem"> | $Enums.QCAction | null
    notes?: StringNullableFilter<"QualityControlItem"> | string | null
    createdAt?: DateTimeFilter<"QualityControlItem"> | Date | string
    updatedAt?: DateTimeFilter<"QualityControlItem"> | Date | string
    qualityControl?: XOR<QualityControlScalarRelationFilter, QualityControlWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type QualityControlItemOrderByWithAggregationInput = {
    id?: SortOrder
    qualityControlId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    passedQuantity?: SortOrder
    failedQuantity?: SortOrder
    pendingQuantity?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QualityControlItemCountOrderByAggregateInput
    _avg?: QualityControlItemAvgOrderByAggregateInput
    _max?: QualityControlItemMaxOrderByAggregateInput
    _min?: QualityControlItemMinOrderByAggregateInput
    _sum?: QualityControlItemSumOrderByAggregateInput
  }

  export type QualityControlItemScalarWhereWithAggregatesInput = {
    AND?: QualityControlItemScalarWhereWithAggregatesInput | QualityControlItemScalarWhereWithAggregatesInput[]
    OR?: QualityControlItemScalarWhereWithAggregatesInput[]
    NOT?: QualityControlItemScalarWhereWithAggregatesInput | QualityControlItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QualityControlItem"> | string
    qualityControlId?: StringWithAggregatesFilter<"QualityControlItem"> | string
    productId?: StringWithAggregatesFilter<"QualityControlItem"> | string
    quantity?: IntWithAggregatesFilter<"QualityControlItem"> | number
    passedQuantity?: IntWithAggregatesFilter<"QualityControlItem"> | number
    failedQuantity?: IntWithAggregatesFilter<"QualityControlItem"> | number
    pendingQuantity?: IntWithAggregatesFilter<"QualityControlItem"> | number
    status?: EnumQCItemStatusWithAggregatesFilter<"QualityControlItem"> | $Enums.QCItemStatus
    reason?: StringNullableWithAggregatesFilter<"QualityControlItem"> | string | null
    action?: EnumQCActionNullableWithAggregatesFilter<"QualityControlItem"> | $Enums.QCAction | null
    notes?: StringNullableWithAggregatesFilter<"QualityControlItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QualityControlItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QualityControlItem"> | Date | string
  }

  export type TransferWhereInput = {
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    id?: StringFilter<"Transfer"> | string
    transferNumber?: StringFilter<"Transfer"> | string
    fromWarehouseId?: StringNullableFilter<"Transfer"> | string | null
    fromStoreId?: StringNullableFilter<"Transfer"> | string | null
    toWarehouseId?: StringNullableFilter<"Transfer"> | string | null
    toStoreId?: StringNullableFilter<"Transfer"> | string | null
    status?: EnumTransferStatusFilter<"Transfer"> | $Enums.TransferStatus
    transferType?: EnumTransferTypeFilter<"Transfer"> | $Enums.TransferType
    priority?: EnumTransferPriorityFilter<"Transfer"> | $Enums.TransferPriority
    requestedById?: StringNullableFilter<"Transfer"> | string | null
    approvedById?: StringNullableFilter<"Transfer"> | string | null
    rejectedById?: StringNullableFilter<"Transfer"> | string | null
    completedById?: StringNullableFilter<"Transfer"> | string | null
    requestedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    approvedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    rejectedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    expectedDeliveryDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    actualDeliveryDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    shippingMethod?: StringNullableFilter<"Transfer"> | string | null
    trackingNumber?: StringNullableFilter<"Transfer"> | string | null
    totalItems?: IntFilter<"Transfer"> | number
    totalCost?: FloatFilter<"Transfer"> | number
    totalRetail?: FloatFilter<"Transfer"> | number
    rejectionReason?: StringNullableFilter<"Transfer"> | string | null
    notes?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    fromWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    fromStore?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    toWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    toStore?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    items?: TransferItemListRelationFilter
    documents?: TransferDocumentListRelationFilter
  }

  export type TransferOrderByWithRelationInput = {
    id?: SortOrder
    transferNumber?: SortOrder
    fromWarehouseId?: SortOrderInput | SortOrder
    fromStoreId?: SortOrderInput | SortOrder
    toWarehouseId?: SortOrderInput | SortOrder
    toStoreId?: SortOrderInput | SortOrder
    status?: SortOrder
    transferType?: SortOrder
    priority?: SortOrder
    requestedById?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    rejectedById?: SortOrderInput | SortOrder
    completedById?: SortOrderInput | SortOrder
    requestedDate?: SortOrderInput | SortOrder
    approvedDate?: SortOrderInput | SortOrder
    rejectedDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    expectedDeliveryDate?: SortOrderInput | SortOrder
    actualDeliveryDate?: SortOrderInput | SortOrder
    shippingMethod?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    totalItems?: SortOrder
    totalCost?: SortOrder
    totalRetail?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromWarehouse?: WarehouseOrderByWithRelationInput
    fromStore?: StoreOrderByWithRelationInput
    toWarehouse?: WarehouseOrderByWithRelationInput
    toStore?: StoreOrderByWithRelationInput
    items?: TransferItemOrderByRelationAggregateInput
    documents?: TransferDocumentOrderByRelationAggregateInput
  }

  export type TransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transferNumber?: string
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    fromWarehouseId?: StringNullableFilter<"Transfer"> | string | null
    fromStoreId?: StringNullableFilter<"Transfer"> | string | null
    toWarehouseId?: StringNullableFilter<"Transfer"> | string | null
    toStoreId?: StringNullableFilter<"Transfer"> | string | null
    status?: EnumTransferStatusFilter<"Transfer"> | $Enums.TransferStatus
    transferType?: EnumTransferTypeFilter<"Transfer"> | $Enums.TransferType
    priority?: EnumTransferPriorityFilter<"Transfer"> | $Enums.TransferPriority
    requestedById?: StringNullableFilter<"Transfer"> | string | null
    approvedById?: StringNullableFilter<"Transfer"> | string | null
    rejectedById?: StringNullableFilter<"Transfer"> | string | null
    completedById?: StringNullableFilter<"Transfer"> | string | null
    requestedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    approvedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    rejectedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    expectedDeliveryDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    actualDeliveryDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    shippingMethod?: StringNullableFilter<"Transfer"> | string | null
    trackingNumber?: StringNullableFilter<"Transfer"> | string | null
    totalItems?: IntFilter<"Transfer"> | number
    totalCost?: FloatFilter<"Transfer"> | number
    totalRetail?: FloatFilter<"Transfer"> | number
    rejectionReason?: StringNullableFilter<"Transfer"> | string | null
    notes?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    fromWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    fromStore?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    toWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    toStore?: XOR<StoreNullableScalarRelationFilter, StoreWhereInput> | null
    items?: TransferItemListRelationFilter
    documents?: TransferDocumentListRelationFilter
  }, "id" | "transferNumber">

  export type TransferOrderByWithAggregationInput = {
    id?: SortOrder
    transferNumber?: SortOrder
    fromWarehouseId?: SortOrderInput | SortOrder
    fromStoreId?: SortOrderInput | SortOrder
    toWarehouseId?: SortOrderInput | SortOrder
    toStoreId?: SortOrderInput | SortOrder
    status?: SortOrder
    transferType?: SortOrder
    priority?: SortOrder
    requestedById?: SortOrderInput | SortOrder
    approvedById?: SortOrderInput | SortOrder
    rejectedById?: SortOrderInput | SortOrder
    completedById?: SortOrderInput | SortOrder
    requestedDate?: SortOrderInput | SortOrder
    approvedDate?: SortOrderInput | SortOrder
    rejectedDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    expectedDeliveryDate?: SortOrderInput | SortOrder
    actualDeliveryDate?: SortOrderInput | SortOrder
    shippingMethod?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    totalItems?: SortOrder
    totalCost?: SortOrder
    totalRetail?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransferCountOrderByAggregateInput
    _avg?: TransferAvgOrderByAggregateInput
    _max?: TransferMaxOrderByAggregateInput
    _min?: TransferMinOrderByAggregateInput
    _sum?: TransferSumOrderByAggregateInput
  }

  export type TransferScalarWhereWithAggregatesInput = {
    AND?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    OR?: TransferScalarWhereWithAggregatesInput[]
    NOT?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transfer"> | string
    transferNumber?: StringWithAggregatesFilter<"Transfer"> | string
    fromWarehouseId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    fromStoreId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    toWarehouseId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    toStoreId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    status?: EnumTransferStatusWithAggregatesFilter<"Transfer"> | $Enums.TransferStatus
    transferType?: EnumTransferTypeWithAggregatesFilter<"Transfer"> | $Enums.TransferType
    priority?: EnumTransferPriorityWithAggregatesFilter<"Transfer"> | $Enums.TransferPriority
    requestedById?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    approvedById?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    rejectedById?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    completedById?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    requestedDate?: DateTimeNullableWithAggregatesFilter<"Transfer"> | Date | string | null
    approvedDate?: DateTimeNullableWithAggregatesFilter<"Transfer"> | Date | string | null
    rejectedDate?: DateTimeNullableWithAggregatesFilter<"Transfer"> | Date | string | null
    completedDate?: DateTimeNullableWithAggregatesFilter<"Transfer"> | Date | string | null
    expectedDeliveryDate?: DateTimeNullableWithAggregatesFilter<"Transfer"> | Date | string | null
    actualDeliveryDate?: DateTimeNullableWithAggregatesFilter<"Transfer"> | Date | string | null
    shippingMethod?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    trackingNumber?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    totalItems?: IntWithAggregatesFilter<"Transfer"> | number
    totalCost?: FloatWithAggregatesFilter<"Transfer"> | number
    totalRetail?: FloatWithAggregatesFilter<"Transfer"> | number
    rejectionReason?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
  }

  export type TransferDocumentWhereInput = {
    AND?: TransferDocumentWhereInput | TransferDocumentWhereInput[]
    OR?: TransferDocumentWhereInput[]
    NOT?: TransferDocumentWhereInput | TransferDocumentWhereInput[]
    id?: StringFilter<"TransferDocument"> | string
    transferId?: StringFilter<"TransferDocument"> | string
    name?: StringFilter<"TransferDocument"> | string
    type?: StringFilter<"TransferDocument"> | string
    url?: StringFilter<"TransferDocument"> | string
    createdById?: StringNullableFilter<"TransferDocument"> | string | null
    createdAt?: DateTimeFilter<"TransferDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TransferDocument"> | Date | string
    transfer?: XOR<TransferScalarRelationFilter, TransferWhereInput>
  }

  export type TransferDocumentOrderByWithRelationInput = {
    id?: SortOrder
    transferId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transfer?: TransferOrderByWithRelationInput
  }

  export type TransferDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransferDocumentWhereInput | TransferDocumentWhereInput[]
    OR?: TransferDocumentWhereInput[]
    NOT?: TransferDocumentWhereInput | TransferDocumentWhereInput[]
    transferId?: StringFilter<"TransferDocument"> | string
    name?: StringFilter<"TransferDocument"> | string
    type?: StringFilter<"TransferDocument"> | string
    url?: StringFilter<"TransferDocument"> | string
    createdById?: StringNullableFilter<"TransferDocument"> | string | null
    createdAt?: DateTimeFilter<"TransferDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TransferDocument"> | Date | string
    transfer?: XOR<TransferScalarRelationFilter, TransferWhereInput>
  }, "id">

  export type TransferDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    transferId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransferDocumentCountOrderByAggregateInput
    _max?: TransferDocumentMaxOrderByAggregateInput
    _min?: TransferDocumentMinOrderByAggregateInput
  }

  export type TransferDocumentScalarWhereWithAggregatesInput = {
    AND?: TransferDocumentScalarWhereWithAggregatesInput | TransferDocumentScalarWhereWithAggregatesInput[]
    OR?: TransferDocumentScalarWhereWithAggregatesInput[]
    NOT?: TransferDocumentScalarWhereWithAggregatesInput | TransferDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransferDocument"> | string
    transferId?: StringWithAggregatesFilter<"TransferDocument"> | string
    name?: StringWithAggregatesFilter<"TransferDocument"> | string
    type?: StringWithAggregatesFilter<"TransferDocument"> | string
    url?: StringWithAggregatesFilter<"TransferDocument"> | string
    createdById?: StringNullableWithAggregatesFilter<"TransferDocument"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TransferDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransferDocument"> | Date | string
  }

  export type TransferItemWhereInput = {
    AND?: TransferItemWhereInput | TransferItemWhereInput[]
    OR?: TransferItemWhereInput[]
    NOT?: TransferItemWhereInput | TransferItemWhereInput[]
    id?: StringFilter<"TransferItem"> | string
    transferId?: StringFilter<"TransferItem"> | string
    productId?: StringFilter<"TransferItem"> | string
    quantity?: IntFilter<"TransferItem"> | number
    sourceCostPrice?: FloatFilter<"TransferItem"> | number
    sourceRetailPrice?: FloatFilter<"TransferItem"> | number
    targetCostPrice?: FloatFilter<"TransferItem"> | number
    targetRetailPrice?: FloatFilter<"TransferItem"> | number
    condition?: EnumProductConditionFilter<"TransferItem"> | $Enums.ProductCondition
    adjustmentReason?: StringNullableFilter<"TransferItem"> | string | null
    notes?: StringNullableFilter<"TransferItem"> | string | null
    createdAt?: DateTimeFilter<"TransferItem"> | Date | string
    updatedAt?: DateTimeFilter<"TransferItem"> | Date | string
    transfer?: XOR<TransferScalarRelationFilter, TransferWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type TransferItemOrderByWithRelationInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sourceCostPrice?: SortOrder
    sourceRetailPrice?: SortOrder
    targetCostPrice?: SortOrder
    targetRetailPrice?: SortOrder
    condition?: SortOrder
    adjustmentReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transfer?: TransferOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type TransferItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransferItemWhereInput | TransferItemWhereInput[]
    OR?: TransferItemWhereInput[]
    NOT?: TransferItemWhereInput | TransferItemWhereInput[]
    transferId?: StringFilter<"TransferItem"> | string
    productId?: StringFilter<"TransferItem"> | string
    quantity?: IntFilter<"TransferItem"> | number
    sourceCostPrice?: FloatFilter<"TransferItem"> | number
    sourceRetailPrice?: FloatFilter<"TransferItem"> | number
    targetCostPrice?: FloatFilter<"TransferItem"> | number
    targetRetailPrice?: FloatFilter<"TransferItem"> | number
    condition?: EnumProductConditionFilter<"TransferItem"> | $Enums.ProductCondition
    adjustmentReason?: StringNullableFilter<"TransferItem"> | string | null
    notes?: StringNullableFilter<"TransferItem"> | string | null
    createdAt?: DateTimeFilter<"TransferItem"> | Date | string
    updatedAt?: DateTimeFilter<"TransferItem"> | Date | string
    transfer?: XOR<TransferScalarRelationFilter, TransferWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type TransferItemOrderByWithAggregationInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sourceCostPrice?: SortOrder
    sourceRetailPrice?: SortOrder
    targetCostPrice?: SortOrder
    targetRetailPrice?: SortOrder
    condition?: SortOrder
    adjustmentReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransferItemCountOrderByAggregateInput
    _avg?: TransferItemAvgOrderByAggregateInput
    _max?: TransferItemMaxOrderByAggregateInput
    _min?: TransferItemMinOrderByAggregateInput
    _sum?: TransferItemSumOrderByAggregateInput
  }

  export type TransferItemScalarWhereWithAggregatesInput = {
    AND?: TransferItemScalarWhereWithAggregatesInput | TransferItemScalarWhereWithAggregatesInput[]
    OR?: TransferItemScalarWhereWithAggregatesInput[]
    NOT?: TransferItemScalarWhereWithAggregatesInput | TransferItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransferItem"> | string
    transferId?: StringWithAggregatesFilter<"TransferItem"> | string
    productId?: StringWithAggregatesFilter<"TransferItem"> | string
    quantity?: IntWithAggregatesFilter<"TransferItem"> | number
    sourceCostPrice?: FloatWithAggregatesFilter<"TransferItem"> | number
    sourceRetailPrice?: FloatWithAggregatesFilter<"TransferItem"> | number
    targetCostPrice?: FloatWithAggregatesFilter<"TransferItem"> | number
    targetRetailPrice?: FloatWithAggregatesFilter<"TransferItem"> | number
    condition?: EnumProductConditionWithAggregatesFilter<"TransferItem"> | $Enums.ProductCondition
    adjustmentReason?: StringNullableWithAggregatesFilter<"TransferItem"> | string | null
    notes?: StringNullableWithAggregatesFilter<"TransferItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TransferItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransferItem"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    loyaltyTier?: EnumLoyaltyTierFilter<"Customer"> | $Enums.LoyaltyTier
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    sales?: SaleListRelationFilter
    returns?: ReturnListRelationFilter
    addresses?: AddressListRelationFilter
    loyaltyTransactions?: LoyaltyTransactionListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sales?: SaleOrderByRelationAggregateInput
    returns?: ReturnOrderByRelationAggregateInput
    addresses?: AddressOrderByRelationAggregateInput
    loyaltyTransactions?: LoyaltyTransactionOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    loyaltyTier?: EnumLoyaltyTierFilter<"Customer"> | $Enums.LoyaltyTier
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    sales?: SaleListRelationFilter
    returns?: ReturnListRelationFilter
    addresses?: AddressListRelationFilter
    loyaltyTransactions?: LoyaltyTransactionListRelationFilter
  }, "id" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    loyaltyPoints?: IntWithAggregatesFilter<"Customer"> | number
    loyaltyTier?: EnumLoyaltyTierWithAggregatesFilter<"Customer"> | $Enums.LoyaltyTier
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: StringFilter<"Address"> | string
    customerId?: StringFilter<"Address"> | string
    type?: StringFilter<"Address"> | string
    street?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringNullableFilter<"Address"> | string | null
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    isDefault?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    customerId?: StringFilter<"Address"> | string
    type?: StringFilter<"Address"> | string
    street?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringNullableFilter<"Address"> | string | null
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    isDefault?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Address"> | string
    customerId?: StringWithAggregatesFilter<"Address"> | string
    type?: StringWithAggregatesFilter<"Address"> | string
    street?: StringWithAggregatesFilter<"Address"> | string
    city?: StringWithAggregatesFilter<"Address"> | string
    state?: StringNullableWithAggregatesFilter<"Address"> | string | null
    postalCode?: StringWithAggregatesFilter<"Address"> | string
    country?: StringWithAggregatesFilter<"Address"> | string
    isDefault?: BoolWithAggregatesFilter<"Address"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
  }

  export type LoyaltyProgramWhereInput = {
    AND?: LoyaltyProgramWhereInput | LoyaltyProgramWhereInput[]
    OR?: LoyaltyProgramWhereInput[]
    NOT?: LoyaltyProgramWhereInput | LoyaltyProgramWhereInput[]
    id?: StringFilter<"LoyaltyProgram"> | string
    name?: StringFilter<"LoyaltyProgram"> | string
    description?: StringNullableFilter<"LoyaltyProgram"> | string | null
    pointsPerDollar?: FloatFilter<"LoyaltyProgram"> | number
    isActive?: BoolFilter<"LoyaltyProgram"> | boolean
    createdAt?: DateTimeFilter<"LoyaltyProgram"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyProgram"> | Date | string
    tiers?: LoyaltyProgramTierListRelationFilter
    transactions?: LoyaltyTransactionListRelationFilter
  }

  export type LoyaltyProgramOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    pointsPerDollar?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tiers?: LoyaltyProgramTierOrderByRelationAggregateInput
    transactions?: LoyaltyTransactionOrderByRelationAggregateInput
  }

  export type LoyaltyProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoyaltyProgramWhereInput | LoyaltyProgramWhereInput[]
    OR?: LoyaltyProgramWhereInput[]
    NOT?: LoyaltyProgramWhereInput | LoyaltyProgramWhereInput[]
    name?: StringFilter<"LoyaltyProgram"> | string
    description?: StringNullableFilter<"LoyaltyProgram"> | string | null
    pointsPerDollar?: FloatFilter<"LoyaltyProgram"> | number
    isActive?: BoolFilter<"LoyaltyProgram"> | boolean
    createdAt?: DateTimeFilter<"LoyaltyProgram"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyProgram"> | Date | string
    tiers?: LoyaltyProgramTierListRelationFilter
    transactions?: LoyaltyTransactionListRelationFilter
  }, "id">

  export type LoyaltyProgramOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    pointsPerDollar?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoyaltyProgramCountOrderByAggregateInput
    _avg?: LoyaltyProgramAvgOrderByAggregateInput
    _max?: LoyaltyProgramMaxOrderByAggregateInput
    _min?: LoyaltyProgramMinOrderByAggregateInput
    _sum?: LoyaltyProgramSumOrderByAggregateInput
  }

  export type LoyaltyProgramScalarWhereWithAggregatesInput = {
    AND?: LoyaltyProgramScalarWhereWithAggregatesInput | LoyaltyProgramScalarWhereWithAggregatesInput[]
    OR?: LoyaltyProgramScalarWhereWithAggregatesInput[]
    NOT?: LoyaltyProgramScalarWhereWithAggregatesInput | LoyaltyProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoyaltyProgram"> | string
    name?: StringWithAggregatesFilter<"LoyaltyProgram"> | string
    description?: StringNullableWithAggregatesFilter<"LoyaltyProgram"> | string | null
    pointsPerDollar?: FloatWithAggregatesFilter<"LoyaltyProgram"> | number
    isActive?: BoolWithAggregatesFilter<"LoyaltyProgram"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LoyaltyProgram"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LoyaltyProgram"> | Date | string
  }

  export type LoyaltyProgramTierWhereInput = {
    AND?: LoyaltyProgramTierWhereInput | LoyaltyProgramTierWhereInput[]
    OR?: LoyaltyProgramTierWhereInput[]
    NOT?: LoyaltyProgramTierWhereInput | LoyaltyProgramTierWhereInput[]
    id?: StringFilter<"LoyaltyProgramTier"> | string
    programId?: StringFilter<"LoyaltyProgramTier"> | string
    name?: StringFilter<"LoyaltyProgramTier"> | string
    description?: StringNullableFilter<"LoyaltyProgramTier"> | string | null
    requiredPoints?: IntFilter<"LoyaltyProgramTier"> | number
    pointsMultiplier?: FloatFilter<"LoyaltyProgramTier"> | number
    benefits?: StringNullableFilter<"LoyaltyProgramTier"> | string | null
    createdAt?: DateTimeFilter<"LoyaltyProgramTier"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyProgramTier"> | Date | string
    program?: XOR<LoyaltyProgramScalarRelationFilter, LoyaltyProgramWhereInput>
  }

  export type LoyaltyProgramTierOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    requiredPoints?: SortOrder
    pointsMultiplier?: SortOrder
    benefits?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    program?: LoyaltyProgramOrderByWithRelationInput
  }

  export type LoyaltyProgramTierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoyaltyProgramTierWhereInput | LoyaltyProgramTierWhereInput[]
    OR?: LoyaltyProgramTierWhereInput[]
    NOT?: LoyaltyProgramTierWhereInput | LoyaltyProgramTierWhereInput[]
    programId?: StringFilter<"LoyaltyProgramTier"> | string
    name?: StringFilter<"LoyaltyProgramTier"> | string
    description?: StringNullableFilter<"LoyaltyProgramTier"> | string | null
    requiredPoints?: IntFilter<"LoyaltyProgramTier"> | number
    pointsMultiplier?: FloatFilter<"LoyaltyProgramTier"> | number
    benefits?: StringNullableFilter<"LoyaltyProgramTier"> | string | null
    createdAt?: DateTimeFilter<"LoyaltyProgramTier"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyProgramTier"> | Date | string
    program?: XOR<LoyaltyProgramScalarRelationFilter, LoyaltyProgramWhereInput>
  }, "id">

  export type LoyaltyProgramTierOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    requiredPoints?: SortOrder
    pointsMultiplier?: SortOrder
    benefits?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoyaltyProgramTierCountOrderByAggregateInput
    _avg?: LoyaltyProgramTierAvgOrderByAggregateInput
    _max?: LoyaltyProgramTierMaxOrderByAggregateInput
    _min?: LoyaltyProgramTierMinOrderByAggregateInput
    _sum?: LoyaltyProgramTierSumOrderByAggregateInput
  }

  export type LoyaltyProgramTierScalarWhereWithAggregatesInput = {
    AND?: LoyaltyProgramTierScalarWhereWithAggregatesInput | LoyaltyProgramTierScalarWhereWithAggregatesInput[]
    OR?: LoyaltyProgramTierScalarWhereWithAggregatesInput[]
    NOT?: LoyaltyProgramTierScalarWhereWithAggregatesInput | LoyaltyProgramTierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoyaltyProgramTier"> | string
    programId?: StringWithAggregatesFilter<"LoyaltyProgramTier"> | string
    name?: StringWithAggregatesFilter<"LoyaltyProgramTier"> | string
    description?: StringNullableWithAggregatesFilter<"LoyaltyProgramTier"> | string | null
    requiredPoints?: IntWithAggregatesFilter<"LoyaltyProgramTier"> | number
    pointsMultiplier?: FloatWithAggregatesFilter<"LoyaltyProgramTier"> | number
    benefits?: StringNullableWithAggregatesFilter<"LoyaltyProgramTier"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LoyaltyProgramTier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LoyaltyProgramTier"> | Date | string
  }

  export type LoyaltyTransactionWhereInput = {
    AND?: LoyaltyTransactionWhereInput | LoyaltyTransactionWhereInput[]
    OR?: LoyaltyTransactionWhereInput[]
    NOT?: LoyaltyTransactionWhereInput | LoyaltyTransactionWhereInput[]
    id?: StringFilter<"LoyaltyTransaction"> | string
    customerId?: StringFilter<"LoyaltyTransaction"> | string
    programId?: StringFilter<"LoyaltyTransaction"> | string
    points?: IntFilter<"LoyaltyTransaction"> | number
    type?: EnumLoyaltyTransactionTypeFilter<"LoyaltyTransaction"> | $Enums.LoyaltyTransactionType
    description?: StringNullableFilter<"LoyaltyTransaction"> | string | null
    referenceId?: StringNullableFilter<"LoyaltyTransaction"> | string | null
    createdAt?: DateTimeFilter<"LoyaltyTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyTransaction"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    program?: XOR<LoyaltyProgramScalarRelationFilter, LoyaltyProgramWhereInput>
  }

  export type LoyaltyTransactionOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    programId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    referenceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    program?: LoyaltyProgramOrderByWithRelationInput
  }

  export type LoyaltyTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoyaltyTransactionWhereInput | LoyaltyTransactionWhereInput[]
    OR?: LoyaltyTransactionWhereInput[]
    NOT?: LoyaltyTransactionWhereInput | LoyaltyTransactionWhereInput[]
    customerId?: StringFilter<"LoyaltyTransaction"> | string
    programId?: StringFilter<"LoyaltyTransaction"> | string
    points?: IntFilter<"LoyaltyTransaction"> | number
    type?: EnumLoyaltyTransactionTypeFilter<"LoyaltyTransaction"> | $Enums.LoyaltyTransactionType
    description?: StringNullableFilter<"LoyaltyTransaction"> | string | null
    referenceId?: StringNullableFilter<"LoyaltyTransaction"> | string | null
    createdAt?: DateTimeFilter<"LoyaltyTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyTransaction"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    program?: XOR<LoyaltyProgramScalarRelationFilter, LoyaltyProgramWhereInput>
  }, "id">

  export type LoyaltyTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    programId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    referenceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoyaltyTransactionCountOrderByAggregateInput
    _avg?: LoyaltyTransactionAvgOrderByAggregateInput
    _max?: LoyaltyTransactionMaxOrderByAggregateInput
    _min?: LoyaltyTransactionMinOrderByAggregateInput
    _sum?: LoyaltyTransactionSumOrderByAggregateInput
  }

  export type LoyaltyTransactionScalarWhereWithAggregatesInput = {
    AND?: LoyaltyTransactionScalarWhereWithAggregatesInput | LoyaltyTransactionScalarWhereWithAggregatesInput[]
    OR?: LoyaltyTransactionScalarWhereWithAggregatesInput[]
    NOT?: LoyaltyTransactionScalarWhereWithAggregatesInput | LoyaltyTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoyaltyTransaction"> | string
    customerId?: StringWithAggregatesFilter<"LoyaltyTransaction"> | string
    programId?: StringWithAggregatesFilter<"LoyaltyTransaction"> | string
    points?: IntWithAggregatesFilter<"LoyaltyTransaction"> | number
    type?: EnumLoyaltyTransactionTypeWithAggregatesFilter<"LoyaltyTransaction"> | $Enums.LoyaltyTransactionType
    description?: StringNullableWithAggregatesFilter<"LoyaltyTransaction"> | string | null
    referenceId?: StringNullableWithAggregatesFilter<"LoyaltyTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LoyaltyTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LoyaltyTransaction"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    userId?: StringNullableFilter<"AuditLog"> | string | null
    userName?: StringNullableFilter<"AuditLog"> | string | null
    details?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    userId?: StringNullableFilter<"AuditLog"> | string | null
    userName?: StringNullableFilter<"AuditLog"> | string | null
    details?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: EnumAuditActionWithAggregatesFilter<"AuditLog"> | $Enums.AuditAction
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userName?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type AuditWhereInput = {
    AND?: AuditWhereInput | AuditWhereInput[]
    OR?: AuditWhereInput[]
    NOT?: AuditWhereInput | AuditWhereInput[]
    id?: StringFilter<"Audit"> | string
    referenceNumber?: StringFilter<"Audit"> | string
    warehouseId?: StringFilter<"Audit"> | string
    status?: EnumAuditStatusFilter<"Audit"> | $Enums.AuditStatus
    startDate?: DateTimeFilter<"Audit"> | Date | string
    endDate?: DateTimeNullableFilter<"Audit"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Audit"> | Date | string | null
    notes?: StringNullableFilter<"Audit"> | string | null
    createdById?: StringFilter<"Audit"> | string
    createdAt?: DateTimeFilter<"Audit"> | Date | string
    updatedAt?: DateTimeFilter<"Audit"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: AuditItemListRelationFilter
    assignments?: AuditAssignmentListRelationFilter
  }

  export type AuditOrderByWithRelationInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    warehouse?: WarehouseOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    items?: AuditItemOrderByRelationAggregateInput
    assignments?: AuditAssignmentOrderByRelationAggregateInput
  }

  export type AuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referenceNumber?: string
    AND?: AuditWhereInput | AuditWhereInput[]
    OR?: AuditWhereInput[]
    NOT?: AuditWhereInput | AuditWhereInput[]
    warehouseId?: StringFilter<"Audit"> | string
    status?: EnumAuditStatusFilter<"Audit"> | $Enums.AuditStatus
    startDate?: DateTimeFilter<"Audit"> | Date | string
    endDate?: DateTimeNullableFilter<"Audit"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Audit"> | Date | string | null
    notes?: StringNullableFilter<"Audit"> | string | null
    createdById?: StringFilter<"Audit"> | string
    createdAt?: DateTimeFilter<"Audit"> | Date | string
    updatedAt?: DateTimeFilter<"Audit"> | Date | string
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: AuditItemListRelationFilter
    assignments?: AuditAssignmentListRelationFilter
  }, "id" | "referenceNumber">

  export type AuditOrderByWithAggregationInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditCountOrderByAggregateInput
    _max?: AuditMaxOrderByAggregateInput
    _min?: AuditMinOrderByAggregateInput
  }

  export type AuditScalarWhereWithAggregatesInput = {
    AND?: AuditScalarWhereWithAggregatesInput | AuditScalarWhereWithAggregatesInput[]
    OR?: AuditScalarWhereWithAggregatesInput[]
    NOT?: AuditScalarWhereWithAggregatesInput | AuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Audit"> | string
    referenceNumber?: StringWithAggregatesFilter<"Audit"> | string
    warehouseId?: StringWithAggregatesFilter<"Audit"> | string
    status?: EnumAuditStatusWithAggregatesFilter<"Audit"> | $Enums.AuditStatus
    startDate?: DateTimeWithAggregatesFilter<"Audit"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Audit"> | Date | string | null
    completedDate?: DateTimeNullableWithAggregatesFilter<"Audit"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Audit"> | string | null
    createdById?: StringWithAggregatesFilter<"Audit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Audit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Audit"> | Date | string
  }

  export type AuditItemWhereInput = {
    AND?: AuditItemWhereInput | AuditItemWhereInput[]
    OR?: AuditItemWhereInput[]
    NOT?: AuditItemWhereInput | AuditItemWhereInput[]
    id?: StringFilter<"AuditItem"> | string
    auditId?: StringFilter<"AuditItem"> | string
    productId?: StringFilter<"AuditItem"> | string
    inventoryItemId?: StringFilter<"AuditItem"> | string
    expectedQuantity?: IntFilter<"AuditItem"> | number
    countedQuantity?: IntNullableFilter<"AuditItem"> | number | null
    discrepancy?: IntNullableFilter<"AuditItem"> | number | null
    notes?: StringNullableFilter<"AuditItem"> | string | null
    status?: EnumAuditItemStatusFilter<"AuditItem"> | $Enums.AuditItemStatus
    countedById?: StringNullableFilter<"AuditItem"> | string | null
    countedAt?: DateTimeNullableFilter<"AuditItem"> | Date | string | null
    createdAt?: DateTimeFilter<"AuditItem"> | Date | string
    updatedAt?: DateTimeFilter<"AuditItem"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
  }

  export type AuditItemOrderByWithRelationInput = {
    id?: SortOrder
    auditId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    expectedQuantity?: SortOrder
    countedQuantity?: SortOrderInput | SortOrder
    discrepancy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    countedById?: SortOrderInput | SortOrder
    countedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    audit?: AuditOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    inventoryItem?: InventoryItemOrderByWithRelationInput
  }

  export type AuditItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditItemWhereInput | AuditItemWhereInput[]
    OR?: AuditItemWhereInput[]
    NOT?: AuditItemWhereInput | AuditItemWhereInput[]
    auditId?: StringFilter<"AuditItem"> | string
    productId?: StringFilter<"AuditItem"> | string
    inventoryItemId?: StringFilter<"AuditItem"> | string
    expectedQuantity?: IntFilter<"AuditItem"> | number
    countedQuantity?: IntNullableFilter<"AuditItem"> | number | null
    discrepancy?: IntNullableFilter<"AuditItem"> | number | null
    notes?: StringNullableFilter<"AuditItem"> | string | null
    status?: EnumAuditItemStatusFilter<"AuditItem"> | $Enums.AuditItemStatus
    countedById?: StringNullableFilter<"AuditItem"> | string | null
    countedAt?: DateTimeNullableFilter<"AuditItem"> | Date | string | null
    createdAt?: DateTimeFilter<"AuditItem"> | Date | string
    updatedAt?: DateTimeFilter<"AuditItem"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    inventoryItem?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
  }, "id">

  export type AuditItemOrderByWithAggregationInput = {
    id?: SortOrder
    auditId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    expectedQuantity?: SortOrder
    countedQuantity?: SortOrderInput | SortOrder
    discrepancy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    countedById?: SortOrderInput | SortOrder
    countedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditItemCountOrderByAggregateInput
    _avg?: AuditItemAvgOrderByAggregateInput
    _max?: AuditItemMaxOrderByAggregateInput
    _min?: AuditItemMinOrderByAggregateInput
    _sum?: AuditItemSumOrderByAggregateInput
  }

  export type AuditItemScalarWhereWithAggregatesInput = {
    AND?: AuditItemScalarWhereWithAggregatesInput | AuditItemScalarWhereWithAggregatesInput[]
    OR?: AuditItemScalarWhereWithAggregatesInput[]
    NOT?: AuditItemScalarWhereWithAggregatesInput | AuditItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditItem"> | string
    auditId?: StringWithAggregatesFilter<"AuditItem"> | string
    productId?: StringWithAggregatesFilter<"AuditItem"> | string
    inventoryItemId?: StringWithAggregatesFilter<"AuditItem"> | string
    expectedQuantity?: IntWithAggregatesFilter<"AuditItem"> | number
    countedQuantity?: IntNullableWithAggregatesFilter<"AuditItem"> | number | null
    discrepancy?: IntNullableWithAggregatesFilter<"AuditItem"> | number | null
    notes?: StringNullableWithAggregatesFilter<"AuditItem"> | string | null
    status?: EnumAuditItemStatusWithAggregatesFilter<"AuditItem"> | $Enums.AuditItemStatus
    countedById?: StringNullableWithAggregatesFilter<"AuditItem"> | string | null
    countedAt?: DateTimeNullableWithAggregatesFilter<"AuditItem"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuditItem"> | Date | string
  }

  export type AuditAssignmentWhereInput = {
    AND?: AuditAssignmentWhereInput | AuditAssignmentWhereInput[]
    OR?: AuditAssignmentWhereInput[]
    NOT?: AuditAssignmentWhereInput | AuditAssignmentWhereInput[]
    id?: StringFilter<"AuditAssignment"> | string
    auditId?: StringFilter<"AuditAssignment"> | string
    userId?: StringFilter<"AuditAssignment"> | string
    assignedZones?: StringNullableFilter<"AuditAssignment"> | string | null
    status?: EnumAssignmentStatusFilter<"AuditAssignment"> | $Enums.AssignmentStatus
    startedAt?: DateTimeNullableFilter<"AuditAssignment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AuditAssignment"> | Date | string | null
    createdAt?: DateTimeFilter<"AuditAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"AuditAssignment"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    auditId?: SortOrder
    userId?: SortOrder
    assignedZones?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    audit?: AuditOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditAssignmentWhereInput | AuditAssignmentWhereInput[]
    OR?: AuditAssignmentWhereInput[]
    NOT?: AuditAssignmentWhereInput | AuditAssignmentWhereInput[]
    auditId?: StringFilter<"AuditAssignment"> | string
    userId?: StringFilter<"AuditAssignment"> | string
    assignedZones?: StringNullableFilter<"AuditAssignment"> | string | null
    status?: EnumAssignmentStatusFilter<"AuditAssignment"> | $Enums.AssignmentStatus
    startedAt?: DateTimeNullableFilter<"AuditAssignment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AuditAssignment"> | Date | string | null
    createdAt?: DateTimeFilter<"AuditAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"AuditAssignment"> | Date | string
    audit?: XOR<AuditScalarRelationFilter, AuditWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    auditId?: SortOrder
    userId?: SortOrder
    assignedZones?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditAssignmentCountOrderByAggregateInput
    _max?: AuditAssignmentMaxOrderByAggregateInput
    _min?: AuditAssignmentMinOrderByAggregateInput
  }

  export type AuditAssignmentScalarWhereWithAggregatesInput = {
    AND?: AuditAssignmentScalarWhereWithAggregatesInput | AuditAssignmentScalarWhereWithAggregatesInput[]
    OR?: AuditAssignmentScalarWhereWithAggregatesInput[]
    NOT?: AuditAssignmentScalarWhereWithAggregatesInput | AuditAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditAssignment"> | string
    auditId?: StringWithAggregatesFilter<"AuditAssignment"> | string
    userId?: StringWithAggregatesFilter<"AuditAssignment"> | string
    assignedZones?: StringNullableWithAggregatesFilter<"AuditAssignment"> | string | null
    status?: EnumAssignmentStatusWithAggregatesFilter<"AuditAssignment"> | $Enums.AssignmentStatus
    startedAt?: DateTimeNullableWithAggregatesFilter<"AuditAssignment"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"AuditAssignment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuditAssignment"> | Date | string
  }

  export type TaxRateWhereInput = {
    AND?: TaxRateWhereInput | TaxRateWhereInput[]
    OR?: TaxRateWhereInput[]
    NOT?: TaxRateWhereInput | TaxRateWhereInput[]
    id?: StringFilter<"TaxRate"> | string
    name?: StringFilter<"TaxRate"> | string
    rate?: FloatFilter<"TaxRate"> | number
    isDefault?: BoolFilter<"TaxRate"> | boolean
    isActive?: BoolFilter<"TaxRate"> | boolean
    createdAt?: DateTimeFilter<"TaxRate"> | Date | string
    updatedAt?: DateTimeFilter<"TaxRate"> | Date | string
  }

  export type TaxRateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxRateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaxRateWhereInput | TaxRateWhereInput[]
    OR?: TaxRateWhereInput[]
    NOT?: TaxRateWhereInput | TaxRateWhereInput[]
    name?: StringFilter<"TaxRate"> | string
    rate?: FloatFilter<"TaxRate"> | number
    isDefault?: BoolFilter<"TaxRate"> | boolean
    isActive?: BoolFilter<"TaxRate"> | boolean
    createdAt?: DateTimeFilter<"TaxRate"> | Date | string
    updatedAt?: DateTimeFilter<"TaxRate"> | Date | string
  }, "id">

  export type TaxRateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxRateCountOrderByAggregateInput
    _avg?: TaxRateAvgOrderByAggregateInput
    _max?: TaxRateMaxOrderByAggregateInput
    _min?: TaxRateMinOrderByAggregateInput
    _sum?: TaxRateSumOrderByAggregateInput
  }

  export type TaxRateScalarWhereWithAggregatesInput = {
    AND?: TaxRateScalarWhereWithAggregatesInput | TaxRateScalarWhereWithAggregatesInput[]
    OR?: TaxRateScalarWhereWithAggregatesInput[]
    NOT?: TaxRateScalarWhereWithAggregatesInput | TaxRateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxRate"> | string
    name?: StringWithAggregatesFilter<"TaxRate"> | string
    rate?: FloatWithAggregatesFilter<"TaxRate"> | number
    isDefault?: BoolWithAggregatesFilter<"TaxRate"> | boolean
    isActive?: BoolWithAggregatesFilter<"TaxRate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TaxRate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaxRate"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnUncheckedCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlUncheckedCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUncheckedUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUncheckedUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseCreateInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
    qualityControls?: QualityControlCreateNestedManyWithoutWarehouseInput
    audits?: AuditCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutWarehouseInput
    audits?: AuditUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
    qualityControls?: QualityControlUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseCreateManyInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseZoneCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutZonesInput
    aisles?: WarehouseAisleCreateNestedManyWithoutZoneInput
  }

  export type WarehouseZoneUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    warehouseId: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aisles?: WarehouseAisleUncheckedCreateNestedManyWithoutZoneInput
  }

  export type WarehouseZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutZonesNestedInput
    aisles?: WarehouseAisleUpdateManyWithoutZoneNestedInput
  }

  export type WarehouseZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aisles?: WarehouseAisleUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type WarehouseZoneCreateManyInput = {
    id?: string
    name: string
    code: string
    warehouseId: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseAisleCreateInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zone: WarehouseZoneCreateNestedOneWithoutAislesInput
    shelves?: WarehouseShelfCreateNestedManyWithoutAisleInput
  }

  export type WarehouseAisleUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    zoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    shelves?: WarehouseShelfUncheckedCreateNestedManyWithoutAisleInput
  }

  export type WarehouseAisleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: WarehouseZoneUpdateOneRequiredWithoutAislesNestedInput
    shelves?: WarehouseShelfUpdateManyWithoutAisleNestedInput
  }

  export type WarehouseAisleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shelves?: WarehouseShelfUncheckedUpdateManyWithoutAisleNestedInput
  }

  export type WarehouseAisleCreateManyInput = {
    id?: string
    name: string
    code: string
    zoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseAisleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseAisleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseShelfCreateInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aisle: WarehouseAisleCreateNestedOneWithoutShelvesInput
    bins?: WarehouseBinCreateNestedManyWithoutShelfInput
  }

  export type WarehouseShelfUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    aisleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bins?: WarehouseBinUncheckedCreateNestedManyWithoutShelfInput
  }

  export type WarehouseShelfUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aisle?: WarehouseAisleUpdateOneRequiredWithoutShelvesNestedInput
    bins?: WarehouseBinUpdateManyWithoutShelfNestedInput
  }

  export type WarehouseShelfUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    aisleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bins?: WarehouseBinUncheckedUpdateManyWithoutShelfNestedInput
  }

  export type WarehouseShelfCreateManyInput = {
    id?: string
    name: string
    code: string
    aisleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseShelfUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseShelfUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    aisleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseBinCreateInput = {
    id?: string
    name: string
    code: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shelf: WarehouseShelfCreateNestedOneWithoutBinsInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutBinInput
  }

  export type WarehouseBinUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    shelfId: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBinInput
  }

  export type WarehouseBinUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shelf?: WarehouseShelfUpdateOneRequiredWithoutBinsNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutBinNestedInput
  }

  export type WarehouseBinUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    shelfId?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBinNestedInput
  }

  export type WarehouseBinCreateManyInput = {
    id?: string
    name: string
    code: string
    shelfId: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseBinUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseBinUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    shelfId?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseStaffCreateInput = {
    id?: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWarehouseStaffInput
    warehouse: WarehouseCreateNestedOneWithoutStaffInput
  }

  export type WarehouseStaffUncheckedCreateInput = {
    id?: string
    userId: string
    warehouseId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseStaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWarehouseStaffNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutStaffNestedInput
  }

  export type WarehouseStaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseStaffCreateManyInput = {
    id?: string
    userId: string
    warehouseId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseStaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseStaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreCreateInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    returns?: ReturnCreateNestedManyWithoutStoreInput
    staff?: StoreStaffCreateNestedManyWithoutStoreInput
    transfersFrom?: TransferCreateNestedManyWithoutFromStoreInput
    transfersTo?: TransferCreateNestedManyWithoutToStoreInput
  }

  export type StoreUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    returns?: ReturnUncheckedCreateNestedManyWithoutStoreInput
    staff?: StoreStaffUncheckedCreateNestedManyWithoutStoreInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromStoreInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToStoreInput
  }

  export type StoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    returns?: ReturnUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUpdateManyWithoutStoreNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromStoreNestedInput
    transfersTo?: TransferUpdateManyWithoutToStoreNestedInput
  }

  export type StoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    returns?: ReturnUncheckedUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUncheckedUpdateManyWithoutStoreNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromStoreNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToStoreNestedInput
  }

  export type StoreCreateManyInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStaffCreateInput = {
    id?: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStoreStaffInput
    store: StoreCreateNestedOneWithoutStaffInput
  }

  export type StoreStaffUncheckedCreateInput = {
    id?: string
    userId: string
    storeId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStoreStaffNestedInput
    store?: StoreUpdateOneRequiredWithoutStaffNestedInput
  }

  export type StoreStaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStaffCreateManyInput = {
    id?: string
    userId: string
    storeId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    rating?: number | null
    isActive?: boolean
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutSupplierInput
    contracts?: SupplierContractCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    performanceMetrics?: SupplierPerformanceMetricCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    rating?: number | null
    isActive?: boolean
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    contracts?: SupplierContractUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    performanceMetrics?: SupplierPerformanceMetricUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutSupplierNestedInput
    contracts?: SupplierContractUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    performanceMetrics?: SupplierPerformanceMetricUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    contracts?: SupplierContractUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    performanceMetrics?: SupplierPerformanceMetricUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    rating?: number | null
    isActive?: boolean
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierContractCreateInput = {
    id?: string
    contractNumber: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    renewalDate?: Date | string | null
    value?: number | null
    terms?: string | null
    paymentTerms?: string | null
    status?: $Enums.ContractStatus
    documentUrl?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutContractsInput
  }

  export type SupplierContractUncheckedCreateInput = {
    id?: string
    supplierId: string
    contractNumber: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    renewalDate?: Date | string | null
    value?: number | null
    terms?: string | null
    paymentTerms?: string | null
    status?: $Enums.ContractStatus
    documentUrl?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierContractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutContractsNestedInput
  }

  export type SupplierContractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierContractCreateManyInput = {
    id?: string
    supplierId: string
    contractNumber: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    renewalDate?: Date | string | null
    value?: number | null
    terms?: string | null
    paymentTerms?: string | null
    status?: $Enums.ContractStatus
    documentUrl?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierContractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierContractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPerformanceMetricCreateInput = {
    id?: string
    metricType: $Enums.PerformanceMetricType
    date: Date | string
    value: number
    notes?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPerformanceMetricsInput
  }

  export type SupplierPerformanceMetricUncheckedCreateInput = {
    id?: string
    supplierId: string
    metricType: $Enums.PerformanceMetricType
    date: Date | string
    value: number
    notes?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierPerformanceMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: EnumPerformanceMetricTypeFieldUpdateOperationsInput | $Enums.PerformanceMetricType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPerformanceMetricsNestedInput
  }

  export type SupplierPerformanceMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    metricType?: EnumPerformanceMetricTypeFieldUpdateOperationsInput | $Enums.PerformanceMetricType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPerformanceMetricCreateManyInput = {
    id?: string
    supplierId: string
    metricType: $Enums.PerformanceMetricType
    date: Date | string
    value: number
    notes?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierPerformanceMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: EnumPerformanceMetricTypeFieldUpdateOperationsInput | $Enums.PerformanceMetricType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPerformanceMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    metricType?: EnumPerformanceMetricTypeFieldUpdateOperationsInput | $Enums.PerformanceMetricType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    orderNumber: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    status?: $Enums.PurchaseOrderStatus
    subtotal?: number
    taxAmount?: number
    totalAmount?: number
    notes?: string | null
    createdById?: string | null
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    warehouse: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    qualityControls?: QualityControlCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    supplierId: string
    warehouseId: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    status?: $Enums.PurchaseOrderStatus
    subtotal?: number
    taxAmount?: number
    totalAmount?: number
    notes?: string | null
    createdById?: string | null
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    qualityControls?: QualityControlUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    orderNumber: string
    supplierId: string
    warehouseId: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    status?: $Enums.PurchaseOrderStatus
    subtotal?: number
    taxAmount?: number
    totalAmount?: number
    notes?: string | null
    createdById?: string | null
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateInput = {
    id?: string
    quantity: number
    unitPrice: number
    totalPrice: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutPurchaseOrderItemsInput
  }

  export type PurchaseOrderItemUncheckedCreateInput = {
    id?: string
    purchaseOrderId: string
    productId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateManyInput = {
    id?: string
    purchaseOrderId: string
    productId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemUncheckedCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutProductsNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUncheckedUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoryInput
    priceRules?: CategoryPriceRuleCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    priceRules?: CategoryPriceRuleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
    priceRules?: CategoryPriceRuleUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    priceRules?: CategoryPriceRuleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryPriceRuleCreateInput = {
    id?: string
    adjustmentType: string
    adjustmentValue: number
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutPriceRulesInput
  }

  export type CategoryPriceRuleUncheckedCreateInput = {
    id?: string
    categoryId: string
    adjustmentType: string
    adjustmentValue: number
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryPriceRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: StringFieldUpdateOperationsInput | string
    adjustmentValue?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutPriceRulesNestedInput
  }

  export type CategoryPriceRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    adjustmentType?: StringFieldUpdateOperationsInput | string
    adjustmentValue?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryPriceRuleCreateManyInput = {
    id?: string
    categoryId: string
    adjustmentType: string
    adjustmentValue: number
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryPriceRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: StringFieldUpdateOperationsInput | string
    adjustmentValue?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryPriceRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    adjustmentType?: StringFieldUpdateOperationsInput | string
    adjustmentValue?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    store?: StoreCreateNestedOneWithoutInventoryItemsInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryItemsInput
    bin?: WarehouseBinCreateNestedOneWithoutInventoryItemsInput
    saleItems?: SaleItemCreateNestedManyWithoutInventoryItemInput
    auditItems?: AuditItemCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: string
    productId: string
    storeId?: string | null
    warehouseId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    store?: StoreUpdateOneWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryItemsNestedInput
    bin?: WarehouseBinUpdateOneWithoutInventoryItemsNestedInput
    saleItems?: SaleItemUpdateManyWithoutInventoryItemNestedInput
    auditItems?: AuditItemUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    auditItems?: AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemCreateManyInput = {
    id?: string
    productId: string
    storeId?: string | null
    warehouseId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateInput = {
    id?: string
    receiptNumber: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    createdBy: UserCreateNestedOneWithoutCreatedSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
    payments?: PaymentCreateNestedManyWithoutSaleInput
    returns?: ReturnCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateInput = {
    id?: string
    receiptNumber: string
    storeId: string
    customerId?: string | null
    createdById: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: PaymentUncheckedCreateNestedManyWithoutSaleInput
    returns?: ReturnUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
    payments?: PaymentUpdateManyWithoutSaleNestedInput
    returns?: ReturnUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutSaleNestedInput
    returns?: ReturnUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleCreateManyInput = {
    id?: string
    receiptNumber: string
    storeId: string
    customerId?: string | null
    createdById: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemCreateInput = {
    id?: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sale: SaleCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutSaleItemsInput
    inventoryItem: InventoryItemCreateNestedOneWithoutSaleItemsInput
    returnItems?: ReturnItemCreateNestedManyWithoutSaleItemInput
  }

  export type SaleItemUncheckedCreateInput = {
    id?: string
    saleId: string
    productId: string
    inventoryItemId: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    returnItems?: ReturnItemUncheckedCreateNestedManyWithoutSaleItemInput
  }

  export type SaleItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSaleItemsNestedInput
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutSaleItemsNestedInput
    returnItems?: ReturnItemUpdateManyWithoutSaleItemNestedInput
  }

  export type SaleItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnItems?: ReturnItemUncheckedUpdateManyWithoutSaleItemNestedInput
  }

  export type SaleItemCreateManyInput = {
    id?: string
    saleId: string
    productId: string
    inventoryItemId: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    paymentMethod: $Enums.PaymentMethod
    referenceNumber?: string | null
    notes?: string | null
    processedById: string
    processedByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sale: SaleCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    saleId: string
    amount: number
    paymentMethod: $Enums.PaymentMethod
    referenceNumber?: string | null
    notes?: string | null
    processedById: string
    processedByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    processedByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    processedByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    saleId: string
    amount: number
    paymentMethod: $Enums.PaymentMethod
    referenceNumber?: string | null
    notes?: string | null
    processedById: string
    processedByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    processedByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    processedByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnCreateInput = {
    id?: string
    returnNumber: string
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sale?: SaleCreateNestedOneWithoutReturnsInput
    store: StoreCreateNestedOneWithoutReturnsInput
    customer?: CustomerCreateNestedOneWithoutReturnsInput
    processedBy: UserCreateNestedOneWithoutProcessedReturnsInput
    items?: ReturnItemCreateNestedManyWithoutReturnInput
    qualityControls?: QualityControlCreateNestedManyWithoutReturnInput
  }

  export type ReturnUncheckedCreateInput = {
    id?: string
    returnNumber: string
    saleId?: string | null
    storeId: string
    customerId?: string | null
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    processedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ReturnItemUncheckedCreateNestedManyWithoutReturnInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutReturnInput
  }

  export type ReturnUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneWithoutReturnsNestedInput
    store?: StoreUpdateOneRequiredWithoutReturnsNestedInput
    customer?: CustomerUpdateOneWithoutReturnsNestedInput
    processedBy?: UserUpdateOneRequiredWithoutProcessedReturnsNestedInput
    items?: ReturnItemUpdateManyWithoutReturnNestedInput
    qualityControls?: QualityControlUpdateManyWithoutReturnNestedInput
  }

  export type ReturnUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ReturnItemUncheckedUpdateManyWithoutReturnNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutReturnNestedInput
  }

  export type ReturnCreateManyInput = {
    id?: string
    returnNumber: string
    saleId?: string | null
    storeId: string
    customerId?: string | null
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    processedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnItemCreateInput = {
    id?: string
    quantity: number
    unitPrice: number
    totalPrice: number
    reason: $Enums.ReturnReason
    condition?: $Enums.ItemCondition
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    return: ReturnCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutReturnItemsInput
    saleItem?: SaleItemCreateNestedOneWithoutReturnItemsInput
  }

  export type ReturnItemUncheckedCreateInput = {
    id?: string
    returnId: string
    productId: string
    saleItemId?: string | null
    quantity: number
    unitPrice: number
    totalPrice: number
    reason: $Enums.ReturnReason
    condition?: $Enums.ItemCondition
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    reason?: EnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason
    condition?: EnumItemConditionFieldUpdateOperationsInput | $Enums.ItemCondition
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    return?: ReturnUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutReturnItemsNestedInput
    saleItem?: SaleItemUpdateOneWithoutReturnItemsNestedInput
  }

  export type ReturnItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    saleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    reason?: EnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason
    condition?: EnumItemConditionFieldUpdateOperationsInput | $Enums.ItemCondition
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnItemCreateManyInput = {
    id?: string
    returnId: string
    productId: string
    saleItemId?: string | null
    quantity: number
    unitPrice: number
    totalPrice: number
    reason: $Enums.ReturnReason
    condition?: $Enums.ItemCondition
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    reason?: EnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason
    condition?: EnumItemConditionFieldUpdateOperationsInput | $Enums.ItemCondition
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    saleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    reason?: EnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason
    condition?: EnumItemConditionFieldUpdateOperationsInput | $Enums.ItemCondition
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityControlCreateInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutQualityControlsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutQualityControlsInput
    return?: ReturnCreateNestedOneWithoutQualityControlsInput
    inspectedBy: UserCreateNestedOneWithoutInspectedQCsInput
    items?: QualityControlItemCreateNestedManyWithoutQualityControlInput
  }

  export type QualityControlUncheckedCreateInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    warehouseId: string
    purchaseOrderId?: string | null
    returnId?: string | null
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    inspectedById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QualityControlItemUncheckedCreateNestedManyWithoutQualityControlInput
  }

  export type QualityControlUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutQualityControlsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutQualityControlsNestedInput
    return?: ReturnUpdateOneWithoutQualityControlsNestedInput
    inspectedBy?: UserUpdateOneRequiredWithoutInspectedQCsNestedInput
    items?: QualityControlItemUpdateManyWithoutQualityControlNestedInput
  }

  export type QualityControlUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    returnId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectedById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QualityControlItemUncheckedUpdateManyWithoutQualityControlNestedInput
  }

  export type QualityControlCreateManyInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    warehouseId: string
    purchaseOrderId?: string | null
    returnId?: string | null
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    inspectedById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualityControlUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityControlUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    returnId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectedById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityControlItemCreateInput = {
    id?: string
    quantity: number
    passedQuantity?: number
    failedQuantity?: number
    pendingQuantity?: number
    status?: $Enums.QCItemStatus
    reason?: string | null
    action?: $Enums.QCAction | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    qualityControl: QualityControlCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutQualityControlItemsInput
  }

  export type QualityControlItemUncheckedCreateInput = {
    id?: string
    qualityControlId: string
    productId: string
    quantity: number
    passedQuantity?: number
    failedQuantity?: number
    pendingQuantity?: number
    status?: $Enums.QCItemStatus
    reason?: string | null
    action?: $Enums.QCAction | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualityControlItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    passedQuantity?: IntFieldUpdateOperationsInput | number
    failedQuantity?: IntFieldUpdateOperationsInput | number
    pendingQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumQCItemStatusFieldUpdateOperationsInput | $Enums.QCItemStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableEnumQCActionFieldUpdateOperationsInput | $Enums.QCAction | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qualityControl?: QualityControlUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutQualityControlItemsNestedInput
  }

  export type QualityControlItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualityControlId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    passedQuantity?: IntFieldUpdateOperationsInput | number
    failedQuantity?: IntFieldUpdateOperationsInput | number
    pendingQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumQCItemStatusFieldUpdateOperationsInput | $Enums.QCItemStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableEnumQCActionFieldUpdateOperationsInput | $Enums.QCAction | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityControlItemCreateManyInput = {
    id?: string
    qualityControlId: string
    productId: string
    quantity: number
    passedQuantity?: number
    failedQuantity?: number
    pendingQuantity?: number
    status?: $Enums.QCItemStatus
    reason?: string | null
    action?: $Enums.QCAction | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualityControlItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    passedQuantity?: IntFieldUpdateOperationsInput | number
    failedQuantity?: IntFieldUpdateOperationsInput | number
    pendingQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumQCItemStatusFieldUpdateOperationsInput | $Enums.QCItemStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableEnumQCActionFieldUpdateOperationsInput | $Enums.QCAction | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityControlItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualityControlId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    passedQuantity?: IntFieldUpdateOperationsInput | number
    failedQuantity?: IntFieldUpdateOperationsInput | number
    pendingQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumQCItemStatusFieldUpdateOperationsInput | $Enums.QCItemStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableEnumQCActionFieldUpdateOperationsInput | $Enums.QCAction | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferCreateInput = {
    id?: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromWarehouse?: WarehouseCreateNestedOneWithoutTransfersFromInput
    fromStore?: StoreCreateNestedOneWithoutTransfersFromInput
    toWarehouse?: WarehouseCreateNestedOneWithoutTransfersToInput
    toStore?: StoreCreateNestedOneWithoutTransfersToInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
    documents?: TransferDocumentCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateInput = {
    id?: string
    transferNumber: string
    fromWarehouseId?: string | null
    fromStoreId?: string | null
    toWarehouseId?: string | null
    toStoreId?: string | null
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
    documents?: TransferDocumentUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromWarehouse?: WarehouseUpdateOneWithoutTransfersFromNestedInput
    fromStore?: StoreUpdateOneWithoutTransfersFromNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutTransfersToNestedInput
    toStore?: StoreUpdateOneWithoutTransfersToNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
    documents?: TransferDocumentUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    fromStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
    documents?: TransferDocumentUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferCreateManyInput = {
    id?: string
    transferNumber: string
    fromWarehouseId?: string | null
    fromStoreId?: string | null
    toWarehouseId?: string | null
    toStoreId?: string | null
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    fromStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferDocumentCreateInput = {
    id?: string
    name: string
    type: string
    url: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transfer: TransferCreateNestedOneWithoutDocumentsInput
  }

  export type TransferDocumentUncheckedCreateInput = {
    id?: string
    transferId: string
    name: string
    type: string
    url: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transfer?: TransferUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type TransferDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferDocumentCreateManyInput = {
    id?: string
    transferId: string
    name: string
    type: string
    url: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemCreateInput = {
    id?: string
    quantity: number
    sourceCostPrice: number
    sourceRetailPrice: number
    targetCostPrice: number
    targetRetailPrice: number
    condition?: $Enums.ProductCondition
    adjustmentReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transfer: TransferCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutTransferItemsInput
  }

  export type TransferItemUncheckedCreateInput = {
    id?: string
    transferId: string
    productId: string
    quantity: number
    sourceCostPrice: number
    sourceRetailPrice: number
    targetCostPrice: number
    targetRetailPrice: number
    condition?: $Enums.ProductCondition
    adjustmentReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sourceCostPrice?: FloatFieldUpdateOperationsInput | number
    sourceRetailPrice?: FloatFieldUpdateOperationsInput | number
    targetCostPrice?: FloatFieldUpdateOperationsInput | number
    targetRetailPrice?: FloatFieldUpdateOperationsInput | number
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    adjustmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transfer?: TransferUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutTransferItemsNestedInput
  }

  export type TransferItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sourceCostPrice?: FloatFieldUpdateOperationsInput | number
    sourceRetailPrice?: FloatFieldUpdateOperationsInput | number
    targetCostPrice?: FloatFieldUpdateOperationsInput | number
    targetRetailPrice?: FloatFieldUpdateOperationsInput | number
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    adjustmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemCreateManyInput = {
    id?: string
    transferId: string
    productId: string
    quantity: number
    sourceCostPrice: number
    sourceRetailPrice: number
    targetCostPrice: number
    targetRetailPrice: number
    condition?: $Enums.ProductCondition
    adjustmentReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sourceCostPrice?: FloatFieldUpdateOperationsInput | number
    sourceRetailPrice?: FloatFieldUpdateOperationsInput | number
    targetCostPrice?: FloatFieldUpdateOperationsInput | number
    targetRetailPrice?: FloatFieldUpdateOperationsInput | number
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    adjustmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sourceCostPrice?: FloatFieldUpdateOperationsInput | number
    sourceRetailPrice?: FloatFieldUpdateOperationsInput | number
    targetCostPrice?: FloatFieldUpdateOperationsInput | number
    targetRetailPrice?: FloatFieldUpdateOperationsInput | number
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    adjustmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleCreateNestedManyWithoutCustomerInput
    returns?: ReturnCreateNestedManyWithoutCustomerInput
    addresses?: AddressCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
    returns?: ReturnUncheckedCreateNestedManyWithoutCustomerInput
    addresses?: AddressUncheckedCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUpdateManyWithoutCustomerNestedInput
    returns?: ReturnUpdateManyWithoutCustomerNestedInput
    addresses?: AddressUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
    returns?: ReturnUncheckedUpdateManyWithoutCustomerNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    id?: string
    type?: string
    street: string
    city: string
    state?: string | null
    postalCode: string
    country: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutAddressesInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    customerId: string
    type?: string
    street: string
    city: string
    state?: string | null
    postalCode: string
    country: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyInput = {
    id?: string
    customerId: string
    type?: string
    street: string
    city: string
    state?: string | null
    postalCode: string
    country: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramCreateInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerDollar?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tiers?: LoyaltyProgramTierCreateNestedManyWithoutProgramInput
    transactions?: LoyaltyTransactionCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerDollar?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tiers?: LoyaltyProgramTierUncheckedCreateNestedManyWithoutProgramInput
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerDollar?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tiers?: LoyaltyProgramTierUpdateManyWithoutProgramNestedInput
    transactions?: LoyaltyTransactionUpdateManyWithoutProgramNestedInput
  }

  export type LoyaltyProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerDollar?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tiers?: LoyaltyProgramTierUncheckedUpdateManyWithoutProgramNestedInput
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type LoyaltyProgramCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerDollar?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerDollar?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerDollar?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramTierCreateInput = {
    id?: string
    name: string
    description?: string | null
    requiredPoints: number
    pointsMultiplier?: number
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    program: LoyaltyProgramCreateNestedOneWithoutTiersInput
  }

  export type LoyaltyProgramTierUncheckedCreateInput = {
    id?: string
    programId: string
    name: string
    description?: string | null
    requiredPoints: number
    pointsMultiplier?: number
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyProgramTierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredPoints?: IntFieldUpdateOperationsInput | number
    pointsMultiplier?: FloatFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: LoyaltyProgramUpdateOneRequiredWithoutTiersNestedInput
  }

  export type LoyaltyProgramTierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredPoints?: IntFieldUpdateOperationsInput | number
    pointsMultiplier?: FloatFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramTierCreateManyInput = {
    id?: string
    programId: string
    name: string
    description?: string | null
    requiredPoints: number
    pointsMultiplier?: number
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyProgramTierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredPoints?: IntFieldUpdateOperationsInput | number
    pointsMultiplier?: FloatFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramTierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredPoints?: IntFieldUpdateOperationsInput | number
    pointsMultiplier?: FloatFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionCreateInput = {
    id?: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutLoyaltyTransactionsInput
    program: LoyaltyProgramCreateNestedOneWithoutTransactionsInput
  }

  export type LoyaltyTransactionUncheckedCreateInput = {
    id?: string
    customerId: string
    programId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutLoyaltyTransactionsNestedInput
    program?: LoyaltyProgramUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type LoyaltyTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionCreateManyInput = {
    id?: string
    customerId: string
    programId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    entityType: string
    entityId: string
    action: $Enums.AuditAction
    userId?: string | null
    userName?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    entityType: string
    entityId: string
    action: $Enums.AuditAction
    userId?: string | null
    userName?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    entityType: string
    entityId: string
    action: $Enums.AuditAction
    userId?: string | null
    userName?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditCreateInput = {
    id?: string
    referenceNumber: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutAuditsInput
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    items?: AuditItemCreateNestedManyWithoutAuditInput
    assignments?: AuditAssignmentCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateInput = {
    id?: string
    referenceNumber: string
    warehouseId: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    completedDate?: Date | string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: AuditItemUncheckedCreateNestedManyWithoutAuditInput
    assignments?: AuditAssignmentUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutAuditsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    items?: AuditItemUpdateManyWithoutAuditNestedInput
    assignments?: AuditAssignmentUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: AuditItemUncheckedUpdateManyWithoutAuditNestedInput
    assignments?: AuditAssignmentUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type AuditCreateManyInput = {
    id?: string
    referenceNumber: string
    warehouseId: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    completedDate?: Date | string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemCreateInput = {
    id?: string
    expectedQuantity: number
    countedQuantity?: number | null
    discrepancy?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    countedById?: string | null
    countedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutAuditItemsInput
    inventoryItem: InventoryItemCreateNestedOneWithoutAuditItemsInput
  }

  export type AuditItemUncheckedCreateInput = {
    id?: string
    auditId: string
    productId: string
    inventoryItemId: string
    expectedQuantity: number
    countedQuantity?: number | null
    discrepancy?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    countedById?: string | null
    countedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    discrepancy?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    countedById?: NullableStringFieldUpdateOperationsInput | string | null
    countedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutAuditItemsNestedInput
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutAuditItemsNestedInput
  }

  export type AuditItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    discrepancy?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    countedById?: NullableStringFieldUpdateOperationsInput | string | null
    countedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemCreateManyInput = {
    id?: string
    auditId: string
    productId: string
    inventoryItemId: string
    expectedQuantity: number
    countedQuantity?: number | null
    discrepancy?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    countedById?: string | null
    countedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    discrepancy?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    countedById?: NullableStringFieldUpdateOperationsInput | string | null
    countedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    discrepancy?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    countedById?: NullableStringFieldUpdateOperationsInput | string | null
    countedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAssignmentCreateInput = {
    id?: string
    assignedZones?: string | null
    status?: $Enums.AssignmentStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutAssignmentsInput
    user: UserCreateNestedOneWithoutAuditAssignmentsInput
  }

  export type AuditAssignmentUncheckedCreateInput = {
    id?: string
    auditId: string
    userId: string
    assignedZones?: string | null
    status?: $Enums.AssignmentStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutAssignmentsNestedInput
    user?: UserUpdateOneRequiredWithoutAuditAssignmentsNestedInput
  }

  export type AuditAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAssignmentCreateManyInput = {
    id?: string
    auditId: string
    userId: string
    assignedZones?: string | null
    status?: $Enums.AssignmentStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRateCreateInput = {
    id?: string
    name: string
    rate: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRateUncheckedCreateInput = {
    id?: string
    name: string
    rate: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRateCreateManyInput = {
    id?: string
    name: string
    rate: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SaleListRelationFilter = {
    every?: SaleWhereInput
    some?: SaleWhereInput
    none?: SaleWhereInput
  }

  export type ReturnListRelationFilter = {
    every?: ReturnWhereInput
    some?: ReturnWhereInput
    none?: ReturnWhereInput
  }

  export type QualityControlListRelationFilter = {
    every?: QualityControlWhereInput
    some?: QualityControlWhereInput
    none?: QualityControlWhereInput
  }

  export type WarehouseStaffNullableScalarRelationFilter = {
    is?: WarehouseStaffWhereInput | null
    isNot?: WarehouseStaffWhereInput | null
  }

  export type StoreStaffNullableScalarRelationFilter = {
    is?: StoreStaffWhereInput | null
    isNot?: StoreStaffWhereInput | null
  }

  export type AuditListRelationFilter = {
    every?: AuditWhereInput
    some?: AuditWhereInput
    none?: AuditWhereInput
  }

  export type AuditAssignmentListRelationFilter = {
    every?: AuditAssignmentWhereInput
    some?: AuditAssignmentWhereInput
    none?: AuditAssignmentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReturnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QualityControlOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type WarehouseZoneListRelationFilter = {
    every?: WarehouseZoneWhereInput
    some?: WarehouseZoneWhereInput
    none?: WarehouseZoneWhereInput
  }

  export type InventoryItemListRelationFilter = {
    every?: InventoryItemWhereInput
    some?: InventoryItemWhereInput
    none?: InventoryItemWhereInput
  }

  export type WarehouseStaffListRelationFilter = {
    every?: WarehouseStaffWhereInput
    some?: WarehouseStaffWhereInput
    none?: WarehouseStaffWhereInput
  }

  export type TransferListRelationFilter = {
    every?: TransferWhereInput
    some?: TransferWhereInput
    none?: TransferWhereInput
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type WarehouseZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseStaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrder
    contactPerson?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrder
    contactPerson?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrder
    contactPerson?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseScalarRelationFilter = {
    is?: WarehouseWhereInput
    isNot?: WarehouseWhereInput
  }

  export type WarehouseAisleListRelationFilter = {
    every?: WarehouseAisleWhereInput
    some?: WarehouseAisleWhereInput
    none?: WarehouseAisleWhereInput
  }

  export type WarehouseAisleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseZoneWarehouseIdCodeCompoundUniqueInput = {
    warehouseId: string
    code: string
  }

  export type WarehouseZoneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    warehouseId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    warehouseId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseZoneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    warehouseId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseZoneScalarRelationFilter = {
    is?: WarehouseZoneWhereInput
    isNot?: WarehouseZoneWhereInput
  }

  export type WarehouseShelfListRelationFilter = {
    every?: WarehouseShelfWhereInput
    some?: WarehouseShelfWhereInput
    none?: WarehouseShelfWhereInput
  }

  export type WarehouseShelfOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseAisleZoneIdCodeCompoundUniqueInput = {
    zoneId: string
    code: string
  }

  export type WarehouseAisleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseAisleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseAisleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseAisleScalarRelationFilter = {
    is?: WarehouseAisleWhereInput
    isNot?: WarehouseAisleWhereInput
  }

  export type WarehouseBinListRelationFilter = {
    every?: WarehouseBinWhereInput
    some?: WarehouseBinWhereInput
    none?: WarehouseBinWhereInput
  }

  export type WarehouseBinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseShelfAisleIdCodeCompoundUniqueInput = {
    aisleId: string
    code: string
  }

  export type WarehouseShelfCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    aisleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseShelfMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    aisleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseShelfMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    aisleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseShelfScalarRelationFilter = {
    is?: WarehouseShelfWhereInput
    isNot?: WarehouseShelfWhereInput
  }

  export type WarehouseBinShelfIdCodeCompoundUniqueInput = {
    shelfId: string
    code: string
  }

  export type WarehouseBinCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    shelfId?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseBinAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type WarehouseBinMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    shelfId?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseBinMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    shelfId?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseBinSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type WarehouseStaffCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    position?: SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    position?: SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseStaffMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    warehouseId?: SortOrder
    position?: SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreStaffListRelationFilter = {
    every?: StoreStaffWhereInput
    some?: StoreStaffWhereInput
    none?: StoreStaffWhereInput
  }

  export type StoreStaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    openingHours?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    openingHours?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    openingHours?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreScalarRelationFilter = {
    is?: StoreWhereInput
    isNot?: StoreWhereInput
  }

  export type StoreStaffCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    position?: SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreStaffMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    position?: SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreStaffMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    storeId?: SortOrder
    position?: SortOrder
    isManager?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type SupplierContractListRelationFilter = {
    every?: SupplierContractWhereInput
    some?: SupplierContractWhereInput
    none?: SupplierContractWhereInput
  }

  export type SupplierPerformanceMetricListRelationFilter = {
    every?: SupplierPerformanceMetricWhereInput
    some?: SupplierPerformanceMetricWhereInput
    none?: SupplierPerformanceMetricWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierPerformanceMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    taxId?: SortOrder
    paymentTerms?: SortOrder
    notes?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    taxId?: SortOrder
    paymentTerms?: SortOrder
    notes?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    taxId?: SortOrder
    paymentTerms?: SortOrder
    notes?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumContractStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusFilter<$PrismaModel> | $Enums.ContractStatus
  }

  export type SupplierScalarRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type SupplierContractCountOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    contractNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    renewalDate?: SortOrder
    value?: SortOrder
    terms?: SortOrder
    paymentTerms?: SortOrder
    status?: SortOrder
    documentUrl?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierContractAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type SupplierContractMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    contractNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    renewalDate?: SortOrder
    value?: SortOrder
    terms?: SortOrder
    paymentTerms?: SortOrder
    status?: SortOrder
    documentUrl?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierContractMinOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    contractNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    renewalDate?: SortOrder
    value?: SortOrder
    terms?: SortOrder
    paymentTerms?: SortOrder
    status?: SortOrder
    documentUrl?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierContractSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumContractStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContractStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractStatusFilter<$PrismaModel>
    _max?: NestedEnumContractStatusFilter<$PrismaModel>
  }

  export type EnumPerformanceMetricTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PerformanceMetricType | EnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PerformanceMetricType[] | ListEnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PerformanceMetricType[] | ListEnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPerformanceMetricTypeFilter<$PrismaModel> | $Enums.PerformanceMetricType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SupplierPerformanceMetricCountOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    metricType?: SortOrder
    date?: SortOrder
    value?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierPerformanceMetricAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type SupplierPerformanceMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    metricType?: SortOrder
    date?: SortOrder
    value?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierPerformanceMetricMinOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    metricType?: SortOrder
    date?: SortOrder
    value?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierPerformanceMetricSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumPerformanceMetricTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PerformanceMetricType | EnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PerformanceMetricType[] | ListEnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PerformanceMetricType[] | ListEnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPerformanceMetricTypeWithAggregatesFilter<$PrismaModel> | $Enums.PerformanceMetricType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPerformanceMetricTypeFilter<$PrismaModel>
    _max?: NestedEnumPerformanceMetricTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPurchaseOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderStatus | EnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel> | $Enums.PurchaseOrderStatus
  }

  export type PurchaseOrderItemListRelationFilter = {
    every?: PurchaseOrderItemWhereInput
    some?: PurchaseOrderItemWhereInput
    none?: PurchaseOrderItemWhereInput
  }

  export type PurchaseOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    supplierId?: SortOrder
    warehouseId?: SortOrder
    orderDate?: SortOrder
    expectedDeliveryDate?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    supplierId?: SortOrder
    warehouseId?: SortOrder
    orderDate?: SortOrder
    expectedDeliveryDate?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    supplierId?: SortOrder
    warehouseId?: SortOrder
    orderDate?: SortOrder
    expectedDeliveryDate?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type EnumPurchaseOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderStatus | EnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PurchaseOrderScalarRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type PurchaseOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    receivedQuantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    receivedQuantity?: SortOrder
  }

  export type PurchaseOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    receivedQuantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    receivedQuantity?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    receivedQuantity?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumProductConditionFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCondition | EnumProductConditionFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumProductConditionFilter<$PrismaModel> | $Enums.ProductCondition
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type SupplierNullableScalarRelationFilter = {
    is?: SupplierWhereInput | null
    isNot?: SupplierWhereInput | null
  }

  export type QualityControlItemListRelationFilter = {
    every?: QualityControlItemWhereInput
    some?: QualityControlItemWhereInput
    none?: QualityControlItemWhereInput
  }

  export type ReturnItemListRelationFilter = {
    every?: ReturnItemWhereInput
    some?: ReturnItemWhereInput
    none?: ReturnItemWhereInput
  }

  export type SaleItemListRelationFilter = {
    every?: SaleItemWhereInput
    some?: SaleItemWhereInput
    none?: SaleItemWhereInput
  }

  export type TransferItemListRelationFilter = {
    every?: TransferItemWhereInput
    some?: TransferItemWhereInput
    none?: TransferItemWhereInput
  }

  export type AuditItemListRelationFilter = {
    every?: AuditItemWhereInput
    some?: AuditItemWhereInput
    none?: AuditItemWhereInput
  }

  export type QualityControlItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReturnItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    minStockLevel?: SortOrder
    reorderPoint?: SortOrder
    leadTime?: SortOrder
    condition?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    minStockLevel?: SortOrder
    reorderPoint?: SortOrder
    leadTime?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    minStockLevel?: SortOrder
    reorderPoint?: SortOrder
    leadTime?: SortOrder
    condition?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    categoryId?: SortOrder
    supplierId?: SortOrder
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    minStockLevel?: SortOrder
    reorderPoint?: SortOrder
    leadTime?: SortOrder
    condition?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    costPrice?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    minStockLevel?: SortOrder
    reorderPoint?: SortOrder
    leadTime?: SortOrder
  }

  export type EnumProductConditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCondition | EnumProductConditionFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumProductConditionWithAggregatesFilter<$PrismaModel> | $Enums.ProductCondition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductConditionFilter<$PrismaModel>
    _max?: NestedEnumProductConditionFilter<$PrismaModel>
  }

  export type CategoryPriceRuleListRelationFilter = {
    every?: CategoryPriceRuleWhereInput
    some?: CategoryPriceRuleWhereInput
    none?: CategoryPriceRuleWhereInput
  }

  export type CategoryPriceRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type CategoryPriceRuleCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    adjustmentType?: SortOrder
    adjustmentValue?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryPriceRuleAvgOrderByAggregateInput = {
    adjustmentValue?: SortOrder
  }

  export type CategoryPriceRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    adjustmentType?: SortOrder
    adjustmentValue?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryPriceRuleMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    adjustmentType?: SortOrder
    adjustmentValue?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryPriceRuleSumOrderByAggregateInput = {
    adjustmentValue?: SortOrder
  }

  export type EnumInventoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusFilter<$PrismaModel> | $Enums.InventoryStatus
  }

  export type EnumInventoryMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryMethod | EnumInventoryMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.InventoryMethod[] | ListEnumInventoryMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InventoryMethod[] | ListEnumInventoryMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInventoryMethodNullableFilter<$PrismaModel> | $Enums.InventoryMethod | null
  }

  export type StoreNullableScalarRelationFilter = {
    is?: StoreWhereInput | null
    isNot?: StoreWhereInput | null
  }

  export type WarehouseNullableScalarRelationFilter = {
    is?: WarehouseWhereInput | null
    isNot?: WarehouseWhereInput | null
  }

  export type WarehouseBinNullableScalarRelationFilter = {
    is?: WarehouseBinWhereInput | null
    isNot?: WarehouseBinWhereInput | null
  }

  export type InventoryItemProductIdStoreIdCompoundUniqueInput = {
    productId: string
    storeId: string
  }

  export type InventoryItemProductIdWarehouseIdBinIdCompoundUniqueInput = {
    productId: string
    warehouseId: string
    binId: string
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    warehouseId?: SortOrder
    binId?: SortOrder
    batchNumber?: SortOrder
    lotNumber?: SortOrder
    serialNumber?: SortOrder
    expiryDate?: SortOrder
    manufacturingDate?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    costPrice?: SortOrder
    retailPrice?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    inventoryMethod?: SortOrder
    receivedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    costPrice?: SortOrder
    retailPrice?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    warehouseId?: SortOrder
    binId?: SortOrder
    batchNumber?: SortOrder
    lotNumber?: SortOrder
    serialNumber?: SortOrder
    expiryDate?: SortOrder
    manufacturingDate?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    costPrice?: SortOrder
    retailPrice?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    inventoryMethod?: SortOrder
    receivedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    warehouseId?: SortOrder
    binId?: SortOrder
    batchNumber?: SortOrder
    lotNumber?: SortOrder
    serialNumber?: SortOrder
    expiryDate?: SortOrder
    manufacturingDate?: SortOrder
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    costPrice?: SortOrder
    retailPrice?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    inventoryMethod?: SortOrder
    receivedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    reservedQuantity?: SortOrder
    costPrice?: SortOrder
    retailPrice?: SortOrder
  }

  export type EnumInventoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InventoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryStatusFilter<$PrismaModel>
    _max?: NestedEnumInventoryStatusFilter<$PrismaModel>
  }

  export type EnumInventoryMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryMethod | EnumInventoryMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.InventoryMethod[] | ListEnumInventoryMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InventoryMethod[] | ListEnumInventoryMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInventoryMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.InventoryMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInventoryMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumInventoryMethodNullableFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleCountOrderByAggregateInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    saleDate?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type SaleMaxOrderByAggregateInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    saleDate?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleMinOrderByAggregateInput = {
    id?: SortOrder
    receiptNumber?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    saleDate?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type SaleScalarRelationFilter = {
    is?: SaleWhereInput
    isNot?: SaleWhereInput
  }

  export type InventoryItemScalarRelationFilter = {
    is?: InventoryItemWhereInput
    isNot?: InventoryItemWhereInput
  }

  export type SaleItemCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    totalPrice?: SortOrder
  }

  export type SaleItemMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleItemMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    totalPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    totalPrice?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    referenceNumber?: SortOrder
    notes?: SortOrder
    processedById?: SortOrder
    processedByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    referenceNumber?: SortOrder
    notes?: SortOrder
    processedById?: SortOrder
    processedByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    referenceNumber?: SortOrder
    notes?: SortOrder
    processedById?: SortOrder
    processedByName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumReturnStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnStatusFilter<$PrismaModel> | $Enums.ReturnStatus
  }

  export type EnumRefundMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundMethod | EnumRefundMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRefundMethodNullableFilter<$PrismaModel> | $Enums.RefundMethod | null
  }

  export type EnumRefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusFilter<$PrismaModel> | $Enums.RefundStatus
  }

  export type SaleNullableScalarRelationFilter = {
    is?: SaleWhereInput | null
    isNot?: SaleWhereInput | null
  }

  export type ReturnCountOrderByAggregateInput = {
    id?: SortOrder
    returnNumber?: SortOrder
    saleId?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrder
    returnDate?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    refundMethod?: SortOrder
    refundStatus?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    processedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReturnAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type ReturnMaxOrderByAggregateInput = {
    id?: SortOrder
    returnNumber?: SortOrder
    saleId?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrder
    returnDate?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    refundMethod?: SortOrder
    refundStatus?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    processedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReturnMinOrderByAggregateInput = {
    id?: SortOrder
    returnNumber?: SortOrder
    saleId?: SortOrder
    storeId?: SortOrder
    customerId?: SortOrder
    returnDate?: SortOrder
    status?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    refundMethod?: SortOrder
    refundStatus?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    processedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReturnSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type EnumReturnStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReturnStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReturnStatusFilter<$PrismaModel>
    _max?: NestedEnumReturnStatusFilter<$PrismaModel>
  }

  export type EnumRefundMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundMethod | EnumRefundMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRefundMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.RefundMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRefundMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumRefundMethodNullableFilter<$PrismaModel>
  }

  export type EnumRefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundStatusFilter<$PrismaModel>
    _max?: NestedEnumRefundStatusFilter<$PrismaModel>
  }

  export type EnumReturnReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnReason | EnumReturnReasonFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnReason[] | ListEnumReturnReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnReason[] | ListEnumReturnReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnReasonFilter<$PrismaModel> | $Enums.ReturnReason
  }

  export type EnumItemConditionFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemCondition | EnumItemConditionFieldRefInput<$PrismaModel>
    in?: $Enums.ItemCondition[] | ListEnumItemConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemCondition[] | ListEnumItemConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumItemConditionFilter<$PrismaModel> | $Enums.ItemCondition
  }

  export type ReturnScalarRelationFilter = {
    is?: ReturnWhereInput
    isNot?: ReturnWhereInput
  }

  export type SaleItemNullableScalarRelationFilter = {
    is?: SaleItemWhereInput | null
    isNot?: SaleItemWhereInput | null
  }

  export type ReturnItemCountOrderByAggregateInput = {
    id?: SortOrder
    returnId?: SortOrder
    productId?: SortOrder
    saleItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    reason?: SortOrder
    condition?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReturnItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type ReturnItemMaxOrderByAggregateInput = {
    id?: SortOrder
    returnId?: SortOrder
    productId?: SortOrder
    saleItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    reason?: SortOrder
    condition?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReturnItemMinOrderByAggregateInput = {
    id?: SortOrder
    returnId?: SortOrder
    productId?: SortOrder
    saleItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    reason?: SortOrder
    condition?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReturnItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnumReturnReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnReason | EnumReturnReasonFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnReason[] | ListEnumReturnReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnReason[] | ListEnumReturnReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnReasonWithAggregatesFilter<$PrismaModel> | $Enums.ReturnReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReturnReasonFilter<$PrismaModel>
    _max?: NestedEnumReturnReasonFilter<$PrismaModel>
  }

  export type EnumItemConditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemCondition | EnumItemConditionFieldRefInput<$PrismaModel>
    in?: $Enums.ItemCondition[] | ListEnumItemConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemCondition[] | ListEnumItemConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumItemConditionWithAggregatesFilter<$PrismaModel> | $Enums.ItemCondition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemConditionFilter<$PrismaModel>
    _max?: NestedEnumItemConditionFilter<$PrismaModel>
  }

  export type EnumQCTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QCType | EnumQCTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QCType[] | ListEnumQCTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCType[] | ListEnumQCTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTypeFilter<$PrismaModel> | $Enums.QCType
  }

  export type EnumQCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QCStatus | EnumQCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QCStatus[] | ListEnumQCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCStatus[] | ListEnumQCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQCStatusFilter<$PrismaModel> | $Enums.QCStatus
  }

  export type PurchaseOrderNullableScalarRelationFilter = {
    is?: PurchaseOrderWhereInput | null
    isNot?: PurchaseOrderWhereInput | null
  }

  export type ReturnNullableScalarRelationFilter = {
    is?: ReturnWhereInput | null
    isNot?: ReturnWhereInput | null
  }

  export type QualityControlCountOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    warehouseId?: SortOrder
    purchaseOrderId?: SortOrder
    returnId?: SortOrder
    inspectionDate?: SortOrder
    completedDate?: SortOrder
    inspectedById?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QualityControlMaxOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    warehouseId?: SortOrder
    purchaseOrderId?: SortOrder
    returnId?: SortOrder
    inspectionDate?: SortOrder
    completedDate?: SortOrder
    inspectedById?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QualityControlMinOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    warehouseId?: SortOrder
    purchaseOrderId?: SortOrder
    returnId?: SortOrder
    inspectionDate?: SortOrder
    completedDate?: SortOrder
    inspectedById?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumQCTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QCType | EnumQCTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QCType[] | ListEnumQCTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCType[] | ListEnumQCTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTypeWithAggregatesFilter<$PrismaModel> | $Enums.QCType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQCTypeFilter<$PrismaModel>
    _max?: NestedEnumQCTypeFilter<$PrismaModel>
  }

  export type EnumQCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QCStatus | EnumQCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QCStatus[] | ListEnumQCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCStatus[] | ListEnumQCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQCStatusWithAggregatesFilter<$PrismaModel> | $Enums.QCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQCStatusFilter<$PrismaModel>
    _max?: NestedEnumQCStatusFilter<$PrismaModel>
  }

  export type EnumQCItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QCItemStatus | EnumQCItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QCItemStatus[] | ListEnumQCItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCItemStatus[] | ListEnumQCItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQCItemStatusFilter<$PrismaModel> | $Enums.QCItemStatus
  }

  export type EnumQCActionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.QCAction | EnumQCActionFieldRefInput<$PrismaModel> | null
    in?: $Enums.QCAction[] | ListEnumQCActionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QCAction[] | ListEnumQCActionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQCActionNullableFilter<$PrismaModel> | $Enums.QCAction | null
  }

  export type QualityControlScalarRelationFilter = {
    is?: QualityControlWhereInput
    isNot?: QualityControlWhereInput
  }

  export type QualityControlItemCountOrderByAggregateInput = {
    id?: SortOrder
    qualityControlId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    passedQuantity?: SortOrder
    failedQuantity?: SortOrder
    pendingQuantity?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    action?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QualityControlItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    passedQuantity?: SortOrder
    failedQuantity?: SortOrder
    pendingQuantity?: SortOrder
  }

  export type QualityControlItemMaxOrderByAggregateInput = {
    id?: SortOrder
    qualityControlId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    passedQuantity?: SortOrder
    failedQuantity?: SortOrder
    pendingQuantity?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    action?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QualityControlItemMinOrderByAggregateInput = {
    id?: SortOrder
    qualityControlId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    passedQuantity?: SortOrder
    failedQuantity?: SortOrder
    pendingQuantity?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    action?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QualityControlItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    passedQuantity?: SortOrder
    failedQuantity?: SortOrder
    pendingQuantity?: SortOrder
  }

  export type EnumQCItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QCItemStatus | EnumQCItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QCItemStatus[] | ListEnumQCItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCItemStatus[] | ListEnumQCItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQCItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.QCItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQCItemStatusFilter<$PrismaModel>
    _max?: NestedEnumQCItemStatusFilter<$PrismaModel>
  }

  export type EnumQCActionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QCAction | EnumQCActionFieldRefInput<$PrismaModel> | null
    in?: $Enums.QCAction[] | ListEnumQCActionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QCAction[] | ListEnumQCActionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQCActionNullableWithAggregatesFilter<$PrismaModel> | $Enums.QCAction | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumQCActionNullableFilter<$PrismaModel>
    _max?: NestedEnumQCActionNullableFilter<$PrismaModel>
  }

  export type EnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type EnumTransferTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferType | EnumTransferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferTypeFilter<$PrismaModel> | $Enums.TransferType
  }

  export type EnumTransferPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferPriority | EnumTransferPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TransferPriority[] | ListEnumTransferPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferPriority[] | ListEnumTransferPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferPriorityFilter<$PrismaModel> | $Enums.TransferPriority
  }

  export type TransferDocumentListRelationFilter = {
    every?: TransferDocumentWhereInput
    some?: TransferDocumentWhereInput
    none?: TransferDocumentWhereInput
  }

  export type TransferDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferCountOrderByAggregateInput = {
    id?: SortOrder
    transferNumber?: SortOrder
    fromWarehouseId?: SortOrder
    fromStoreId?: SortOrder
    toWarehouseId?: SortOrder
    toStoreId?: SortOrder
    status?: SortOrder
    transferType?: SortOrder
    priority?: SortOrder
    requestedById?: SortOrder
    approvedById?: SortOrder
    rejectedById?: SortOrder
    completedById?: SortOrder
    requestedDate?: SortOrder
    approvedDate?: SortOrder
    rejectedDate?: SortOrder
    completedDate?: SortOrder
    expectedDeliveryDate?: SortOrder
    actualDeliveryDate?: SortOrder
    shippingMethod?: SortOrder
    trackingNumber?: SortOrder
    totalItems?: SortOrder
    totalCost?: SortOrder
    totalRetail?: SortOrder
    rejectionReason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferAvgOrderByAggregateInput = {
    totalItems?: SortOrder
    totalCost?: SortOrder
    totalRetail?: SortOrder
  }

  export type TransferMaxOrderByAggregateInput = {
    id?: SortOrder
    transferNumber?: SortOrder
    fromWarehouseId?: SortOrder
    fromStoreId?: SortOrder
    toWarehouseId?: SortOrder
    toStoreId?: SortOrder
    status?: SortOrder
    transferType?: SortOrder
    priority?: SortOrder
    requestedById?: SortOrder
    approvedById?: SortOrder
    rejectedById?: SortOrder
    completedById?: SortOrder
    requestedDate?: SortOrder
    approvedDate?: SortOrder
    rejectedDate?: SortOrder
    completedDate?: SortOrder
    expectedDeliveryDate?: SortOrder
    actualDeliveryDate?: SortOrder
    shippingMethod?: SortOrder
    trackingNumber?: SortOrder
    totalItems?: SortOrder
    totalCost?: SortOrder
    totalRetail?: SortOrder
    rejectionReason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferMinOrderByAggregateInput = {
    id?: SortOrder
    transferNumber?: SortOrder
    fromWarehouseId?: SortOrder
    fromStoreId?: SortOrder
    toWarehouseId?: SortOrder
    toStoreId?: SortOrder
    status?: SortOrder
    transferType?: SortOrder
    priority?: SortOrder
    requestedById?: SortOrder
    approvedById?: SortOrder
    rejectedById?: SortOrder
    completedById?: SortOrder
    requestedDate?: SortOrder
    approvedDate?: SortOrder
    rejectedDate?: SortOrder
    completedDate?: SortOrder
    expectedDeliveryDate?: SortOrder
    actualDeliveryDate?: SortOrder
    shippingMethod?: SortOrder
    trackingNumber?: SortOrder
    totalItems?: SortOrder
    totalCost?: SortOrder
    totalRetail?: SortOrder
    rejectionReason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferSumOrderByAggregateInput = {
    totalItems?: SortOrder
    totalCost?: SortOrder
    totalRetail?: SortOrder
  }

  export type EnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type EnumTransferTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferType | EnumTransferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransferType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferTypeFilter<$PrismaModel>
    _max?: NestedEnumTransferTypeFilter<$PrismaModel>
  }

  export type EnumTransferPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferPriority | EnumTransferPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TransferPriority[] | ListEnumTransferPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferPriority[] | ListEnumTransferPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TransferPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferPriorityFilter<$PrismaModel>
    _max?: NestedEnumTransferPriorityFilter<$PrismaModel>
  }

  export type TransferScalarRelationFilter = {
    is?: TransferWhereInput
    isNot?: TransferWhereInput
  }

  export type TransferDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferItemCountOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sourceCostPrice?: SortOrder
    sourceRetailPrice?: SortOrder
    targetCostPrice?: SortOrder
    targetRetailPrice?: SortOrder
    condition?: SortOrder
    adjustmentReason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    sourceCostPrice?: SortOrder
    sourceRetailPrice?: SortOrder
    targetCostPrice?: SortOrder
    targetRetailPrice?: SortOrder
  }

  export type TransferItemMaxOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sourceCostPrice?: SortOrder
    sourceRetailPrice?: SortOrder
    targetCostPrice?: SortOrder
    targetRetailPrice?: SortOrder
    condition?: SortOrder
    adjustmentReason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferItemMinOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    sourceCostPrice?: SortOrder
    sourceRetailPrice?: SortOrder
    targetCostPrice?: SortOrder
    targetRetailPrice?: SortOrder
    condition?: SortOrder
    adjustmentReason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    sourceCostPrice?: SortOrder
    sourceRetailPrice?: SortOrder
    targetCostPrice?: SortOrder
    targetRetailPrice?: SortOrder
  }

  export type EnumLoyaltyTierFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTierFilter<$PrismaModel> | $Enums.LoyaltyTier
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type LoyaltyTransactionListRelationFilter = {
    every?: LoyaltyTransactionWhereInput
    some?: LoyaltyTransactionWhereInput
    none?: LoyaltyTransactionWhereInput
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoyaltyTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    loyaltyPoints?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    loyaltyPoints?: SortOrder
  }

  export type EnumLoyaltyTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTierWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyTierFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyTierFilter<$PrismaModel>
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramTierListRelationFilter = {
    every?: LoyaltyProgramTierWhereInput
    some?: LoyaltyProgramTierWhereInput
    none?: LoyaltyProgramTierWhereInput
  }

  export type LoyaltyProgramTierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoyaltyProgramCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pointsPerDollar?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramAvgOrderByAggregateInput = {
    pointsPerDollar?: SortOrder
  }

  export type LoyaltyProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pointsPerDollar?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pointsPerDollar?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramSumOrderByAggregateInput = {
    pointsPerDollar?: SortOrder
  }

  export type LoyaltyProgramScalarRelationFilter = {
    is?: LoyaltyProgramWhereInput
    isNot?: LoyaltyProgramWhereInput
  }

  export type LoyaltyProgramTierCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    requiredPoints?: SortOrder
    pointsMultiplier?: SortOrder
    benefits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramTierAvgOrderByAggregateInput = {
    requiredPoints?: SortOrder
    pointsMultiplier?: SortOrder
  }

  export type LoyaltyProgramTierMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    requiredPoints?: SortOrder
    pointsMultiplier?: SortOrder
    benefits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramTierMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    requiredPoints?: SortOrder
    pointsMultiplier?: SortOrder
    benefits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyProgramTierSumOrderByAggregateInput = {
    requiredPoints?: SortOrder
    pointsMultiplier?: SortOrder
  }

  export type EnumLoyaltyTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
  }

  export type LoyaltyTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    programId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    description?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyTransactionAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type LoyaltyTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    programId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    description?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    programId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    description?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoyaltyTransactionSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
  }

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type EnumAuditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusFilter<$PrismaModel> | $Enums.AuditStatus
  }

  export type AuditCountOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    completedDate?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditMaxOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    completedDate?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditMinOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    warehouseId?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    completedDate?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAuditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditStatusFilter<$PrismaModel>
  }

  export type EnumAuditItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditItemStatus | EnumAuditItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditItemStatusFilter<$PrismaModel> | $Enums.AuditItemStatus
  }

  export type AuditScalarRelationFilter = {
    is?: AuditWhereInput
    isNot?: AuditWhereInput
  }

  export type AuditItemCountOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    expectedQuantity?: SortOrder
    countedQuantity?: SortOrder
    discrepancy?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    countedById?: SortOrder
    countedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditItemAvgOrderByAggregateInput = {
    expectedQuantity?: SortOrder
    countedQuantity?: SortOrder
    discrepancy?: SortOrder
  }

  export type AuditItemMaxOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    expectedQuantity?: SortOrder
    countedQuantity?: SortOrder
    discrepancy?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    countedById?: SortOrder
    countedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditItemMinOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    productId?: SortOrder
    inventoryItemId?: SortOrder
    expectedQuantity?: SortOrder
    countedQuantity?: SortOrder
    discrepancy?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    countedById?: SortOrder
    countedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditItemSumOrderByAggregateInput = {
    expectedQuantity?: SortOrder
    countedQuantity?: SortOrder
    discrepancy?: SortOrder
  }

  export type EnumAuditItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditItemStatus | EnumAuditItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditItemStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditItemStatusFilter<$PrismaModel>
  }

  export type EnumAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusFilter<$PrismaModel> | $Enums.AssignmentStatus
  }

  export type AuditAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    userId?: SortOrder
    assignedZones?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    userId?: SortOrder
    assignedZones?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    auditId?: SortOrder
    userId?: SortOrder
    assignedZones?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssignmentStatusFilter<$PrismaModel>
  }

  export type TaxRateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxRateAvgOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type TaxRateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxRateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxRateSumOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput> | SaleCreateWithoutCreatedByInput[] | SaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCreatedByInput | SaleCreateOrConnectWithoutCreatedByInput[]
    createMany?: SaleCreateManyCreatedByInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ReturnCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<ReturnCreateWithoutProcessedByInput, ReturnUncheckedCreateWithoutProcessedByInput> | ReturnCreateWithoutProcessedByInput[] | ReturnUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutProcessedByInput | ReturnCreateOrConnectWithoutProcessedByInput[]
    createMany?: ReturnCreateManyProcessedByInputEnvelope
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
  }

  export type QualityControlCreateNestedManyWithoutInspectedByInput = {
    create?: XOR<QualityControlCreateWithoutInspectedByInput, QualityControlUncheckedCreateWithoutInspectedByInput> | QualityControlCreateWithoutInspectedByInput[] | QualityControlUncheckedCreateWithoutInspectedByInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutInspectedByInput | QualityControlCreateOrConnectWithoutInspectedByInput[]
    createMany?: QualityControlCreateManyInspectedByInputEnvelope
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
  }

  export type WarehouseStaffCreateNestedOneWithoutUserInput = {
    create?: XOR<WarehouseStaffCreateWithoutUserInput, WarehouseStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutUserInput
    connect?: WarehouseStaffWhereUniqueInput
  }

  export type StoreStaffCreateNestedOneWithoutUserInput = {
    create?: XOR<StoreStaffCreateWithoutUserInput, StoreStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoreStaffCreateOrConnectWithoutUserInput
    connect?: StoreStaffWhereUniqueInput
  }

  export type AuditCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput> | AuditCreateWithoutCreatedByInput[] | AuditUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutCreatedByInput | AuditCreateOrConnectWithoutCreatedByInput[]
    createMany?: AuditCreateManyCreatedByInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type AuditAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditAssignmentCreateWithoutUserInput, AuditAssignmentUncheckedCreateWithoutUserInput> | AuditAssignmentCreateWithoutUserInput[] | AuditAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutUserInput | AuditAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: AuditAssignmentCreateManyUserInputEnvelope
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput> | SaleCreateWithoutCreatedByInput[] | SaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCreatedByInput | SaleCreateOrConnectWithoutCreatedByInput[]
    createMany?: SaleCreateManyCreatedByInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ReturnUncheckedCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<ReturnCreateWithoutProcessedByInput, ReturnUncheckedCreateWithoutProcessedByInput> | ReturnCreateWithoutProcessedByInput[] | ReturnUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutProcessedByInput | ReturnCreateOrConnectWithoutProcessedByInput[]
    createMany?: ReturnCreateManyProcessedByInputEnvelope
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
  }

  export type QualityControlUncheckedCreateNestedManyWithoutInspectedByInput = {
    create?: XOR<QualityControlCreateWithoutInspectedByInput, QualityControlUncheckedCreateWithoutInspectedByInput> | QualityControlCreateWithoutInspectedByInput[] | QualityControlUncheckedCreateWithoutInspectedByInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutInspectedByInput | QualityControlCreateOrConnectWithoutInspectedByInput[]
    createMany?: QualityControlCreateManyInspectedByInputEnvelope
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
  }

  export type WarehouseStaffUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WarehouseStaffCreateWithoutUserInput, WarehouseStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutUserInput
    connect?: WarehouseStaffWhereUniqueInput
  }

  export type StoreStaffUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StoreStaffCreateWithoutUserInput, StoreStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoreStaffCreateOrConnectWithoutUserInput
    connect?: StoreStaffWhereUniqueInput
  }

  export type AuditUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput> | AuditCreateWithoutCreatedByInput[] | AuditUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutCreatedByInput | AuditCreateOrConnectWithoutCreatedByInput[]
    createMany?: AuditCreateManyCreatedByInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type AuditAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditAssignmentCreateWithoutUserInput, AuditAssignmentUncheckedCreateWithoutUserInput> | AuditAssignmentCreateWithoutUserInput[] | AuditAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutUserInput | AuditAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: AuditAssignmentCreateManyUserInputEnvelope
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput> | SaleCreateWithoutCreatedByInput[] | SaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCreatedByInput | SaleCreateOrConnectWithoutCreatedByInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCreatedByInput | SaleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SaleCreateManyCreatedByInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCreatedByInput | SaleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCreatedByInput | SaleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ReturnUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<ReturnCreateWithoutProcessedByInput, ReturnUncheckedCreateWithoutProcessedByInput> | ReturnCreateWithoutProcessedByInput[] | ReturnUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutProcessedByInput | ReturnCreateOrConnectWithoutProcessedByInput[]
    upsert?: ReturnUpsertWithWhereUniqueWithoutProcessedByInput | ReturnUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: ReturnCreateManyProcessedByInputEnvelope
    set?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    disconnect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    delete?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    update?: ReturnUpdateWithWhereUniqueWithoutProcessedByInput | ReturnUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: ReturnUpdateManyWithWhereWithoutProcessedByInput | ReturnUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: ReturnScalarWhereInput | ReturnScalarWhereInput[]
  }

  export type QualityControlUpdateManyWithoutInspectedByNestedInput = {
    create?: XOR<QualityControlCreateWithoutInspectedByInput, QualityControlUncheckedCreateWithoutInspectedByInput> | QualityControlCreateWithoutInspectedByInput[] | QualityControlUncheckedCreateWithoutInspectedByInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutInspectedByInput | QualityControlCreateOrConnectWithoutInspectedByInput[]
    upsert?: QualityControlUpsertWithWhereUniqueWithoutInspectedByInput | QualityControlUpsertWithWhereUniqueWithoutInspectedByInput[]
    createMany?: QualityControlCreateManyInspectedByInputEnvelope
    set?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    disconnect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    delete?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    update?: QualityControlUpdateWithWhereUniqueWithoutInspectedByInput | QualityControlUpdateWithWhereUniqueWithoutInspectedByInput[]
    updateMany?: QualityControlUpdateManyWithWhereWithoutInspectedByInput | QualityControlUpdateManyWithWhereWithoutInspectedByInput[]
    deleteMany?: QualityControlScalarWhereInput | QualityControlScalarWhereInput[]
  }

  export type WarehouseStaffUpdateOneWithoutUserNestedInput = {
    create?: XOR<WarehouseStaffCreateWithoutUserInput, WarehouseStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutUserInput
    upsert?: WarehouseStaffUpsertWithoutUserInput
    disconnect?: WarehouseStaffWhereInput | boolean
    delete?: WarehouseStaffWhereInput | boolean
    connect?: WarehouseStaffWhereUniqueInput
    update?: XOR<XOR<WarehouseStaffUpdateToOneWithWhereWithoutUserInput, WarehouseStaffUpdateWithoutUserInput>, WarehouseStaffUncheckedUpdateWithoutUserInput>
  }

  export type StoreStaffUpdateOneWithoutUserNestedInput = {
    create?: XOR<StoreStaffCreateWithoutUserInput, StoreStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoreStaffCreateOrConnectWithoutUserInput
    upsert?: StoreStaffUpsertWithoutUserInput
    disconnect?: StoreStaffWhereInput | boolean
    delete?: StoreStaffWhereInput | boolean
    connect?: StoreStaffWhereUniqueInput
    update?: XOR<XOR<StoreStaffUpdateToOneWithWhereWithoutUserInput, StoreStaffUpdateWithoutUserInput>, StoreStaffUncheckedUpdateWithoutUserInput>
  }

  export type AuditUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput> | AuditCreateWithoutCreatedByInput[] | AuditUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutCreatedByInput | AuditCreateOrConnectWithoutCreatedByInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutCreatedByInput | AuditUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AuditCreateManyCreatedByInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutCreatedByInput | AuditUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutCreatedByInput | AuditUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type AuditAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditAssignmentCreateWithoutUserInput, AuditAssignmentUncheckedCreateWithoutUserInput> | AuditAssignmentCreateWithoutUserInput[] | AuditAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutUserInput | AuditAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: AuditAssignmentUpsertWithWhereUniqueWithoutUserInput | AuditAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditAssignmentCreateManyUserInputEnvelope
    set?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    disconnect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    delete?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    update?: AuditAssignmentUpdateWithWhereUniqueWithoutUserInput | AuditAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditAssignmentUpdateManyWithWhereWithoutUserInput | AuditAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditAssignmentScalarWhereInput | AuditAssignmentScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput> | SaleCreateWithoutCreatedByInput[] | SaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCreatedByInput | SaleCreateOrConnectWithoutCreatedByInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCreatedByInput | SaleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SaleCreateManyCreatedByInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCreatedByInput | SaleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCreatedByInput | SaleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ReturnUncheckedUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<ReturnCreateWithoutProcessedByInput, ReturnUncheckedCreateWithoutProcessedByInput> | ReturnCreateWithoutProcessedByInput[] | ReturnUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutProcessedByInput | ReturnCreateOrConnectWithoutProcessedByInput[]
    upsert?: ReturnUpsertWithWhereUniqueWithoutProcessedByInput | ReturnUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: ReturnCreateManyProcessedByInputEnvelope
    set?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    disconnect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    delete?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    update?: ReturnUpdateWithWhereUniqueWithoutProcessedByInput | ReturnUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: ReturnUpdateManyWithWhereWithoutProcessedByInput | ReturnUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: ReturnScalarWhereInput | ReturnScalarWhereInput[]
  }

  export type QualityControlUncheckedUpdateManyWithoutInspectedByNestedInput = {
    create?: XOR<QualityControlCreateWithoutInspectedByInput, QualityControlUncheckedCreateWithoutInspectedByInput> | QualityControlCreateWithoutInspectedByInput[] | QualityControlUncheckedCreateWithoutInspectedByInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutInspectedByInput | QualityControlCreateOrConnectWithoutInspectedByInput[]
    upsert?: QualityControlUpsertWithWhereUniqueWithoutInspectedByInput | QualityControlUpsertWithWhereUniqueWithoutInspectedByInput[]
    createMany?: QualityControlCreateManyInspectedByInputEnvelope
    set?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    disconnect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    delete?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    update?: QualityControlUpdateWithWhereUniqueWithoutInspectedByInput | QualityControlUpdateWithWhereUniqueWithoutInspectedByInput[]
    updateMany?: QualityControlUpdateManyWithWhereWithoutInspectedByInput | QualityControlUpdateManyWithWhereWithoutInspectedByInput[]
    deleteMany?: QualityControlScalarWhereInput | QualityControlScalarWhereInput[]
  }

  export type WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WarehouseStaffCreateWithoutUserInput, WarehouseStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutUserInput
    upsert?: WarehouseStaffUpsertWithoutUserInput
    disconnect?: WarehouseStaffWhereInput | boolean
    delete?: WarehouseStaffWhereInput | boolean
    connect?: WarehouseStaffWhereUniqueInput
    update?: XOR<XOR<WarehouseStaffUpdateToOneWithWhereWithoutUserInput, WarehouseStaffUpdateWithoutUserInput>, WarehouseStaffUncheckedUpdateWithoutUserInput>
  }

  export type StoreStaffUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StoreStaffCreateWithoutUserInput, StoreStaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StoreStaffCreateOrConnectWithoutUserInput
    upsert?: StoreStaffUpsertWithoutUserInput
    disconnect?: StoreStaffWhereInput | boolean
    delete?: StoreStaffWhereInput | boolean
    connect?: StoreStaffWhereUniqueInput
    update?: XOR<XOR<StoreStaffUpdateToOneWithWhereWithoutUserInput, StoreStaffUpdateWithoutUserInput>, StoreStaffUncheckedUpdateWithoutUserInput>
  }

  export type AuditUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput> | AuditCreateWithoutCreatedByInput[] | AuditUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutCreatedByInput | AuditCreateOrConnectWithoutCreatedByInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutCreatedByInput | AuditUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AuditCreateManyCreatedByInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutCreatedByInput | AuditUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutCreatedByInput | AuditUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditAssignmentCreateWithoutUserInput, AuditAssignmentUncheckedCreateWithoutUserInput> | AuditAssignmentCreateWithoutUserInput[] | AuditAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutUserInput | AuditAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: AuditAssignmentUpsertWithWhereUniqueWithoutUserInput | AuditAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditAssignmentCreateManyUserInputEnvelope
    set?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    disconnect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    delete?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    update?: AuditAssignmentUpdateWithWhereUniqueWithoutUserInput | AuditAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditAssignmentUpdateManyWithWhereWithoutUserInput | AuditAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditAssignmentScalarWhereInput | AuditAssignmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type WarehouseZoneCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<WarehouseZoneCreateWithoutWarehouseInput, WarehouseZoneUncheckedCreateWithoutWarehouseInput> | WarehouseZoneCreateWithoutWarehouseInput[] | WarehouseZoneUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseZoneCreateOrConnectWithoutWarehouseInput | WarehouseZoneCreateOrConnectWithoutWarehouseInput[]
    createMany?: WarehouseZoneCreateManyWarehouseInputEnvelope
    connect?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
  }

  export type InventoryItemCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type WarehouseStaffCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<WarehouseStaffCreateWithoutWarehouseInput, WarehouseStaffUncheckedCreateWithoutWarehouseInput> | WarehouseStaffCreateWithoutWarehouseInput[] | WarehouseStaffUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutWarehouseInput | WarehouseStaffCreateOrConnectWithoutWarehouseInput[]
    createMany?: WarehouseStaffCreateManyWarehouseInputEnvelope
    connect?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutFromWarehouseInput = {
    create?: XOR<TransferCreateWithoutFromWarehouseInput, TransferUncheckedCreateWithoutFromWarehouseInput> | TransferCreateWithoutFromWarehouseInput[] | TransferUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromWarehouseInput | TransferCreateOrConnectWithoutFromWarehouseInput[]
    createMany?: TransferCreateManyFromWarehouseInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutToWarehouseInput = {
    create?: XOR<TransferCreateWithoutToWarehouseInput, TransferUncheckedCreateWithoutToWarehouseInput> | TransferCreateWithoutToWarehouseInput[] | TransferUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToWarehouseInput | TransferCreateOrConnectWithoutToWarehouseInput[]
    createMany?: TransferCreateManyToWarehouseInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput> | PurchaseOrderCreateWithoutWarehouseInput[] | PurchaseOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutWarehouseInput | PurchaseOrderCreateOrConnectWithoutWarehouseInput[]
    createMany?: PurchaseOrderCreateManyWarehouseInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type QualityControlCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<QualityControlCreateWithoutWarehouseInput, QualityControlUncheckedCreateWithoutWarehouseInput> | QualityControlCreateWithoutWarehouseInput[] | QualityControlUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutWarehouseInput | QualityControlCreateOrConnectWithoutWarehouseInput[]
    createMany?: QualityControlCreateManyWarehouseInputEnvelope
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
  }

  export type AuditCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<AuditCreateWithoutWarehouseInput, AuditUncheckedCreateWithoutWarehouseInput> | AuditCreateWithoutWarehouseInput[] | AuditUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutWarehouseInput | AuditCreateOrConnectWithoutWarehouseInput[]
    createMany?: AuditCreateManyWarehouseInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<WarehouseZoneCreateWithoutWarehouseInput, WarehouseZoneUncheckedCreateWithoutWarehouseInput> | WarehouseZoneCreateWithoutWarehouseInput[] | WarehouseZoneUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseZoneCreateOrConnectWithoutWarehouseInput | WarehouseZoneCreateOrConnectWithoutWarehouseInput[]
    createMany?: WarehouseZoneCreateManyWarehouseInputEnvelope
    connect?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<WarehouseStaffCreateWithoutWarehouseInput, WarehouseStaffUncheckedCreateWithoutWarehouseInput> | WarehouseStaffCreateWithoutWarehouseInput[] | WarehouseStaffUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutWarehouseInput | WarehouseStaffCreateOrConnectWithoutWarehouseInput[]
    createMany?: WarehouseStaffCreateManyWarehouseInputEnvelope
    connect?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutFromWarehouseInput = {
    create?: XOR<TransferCreateWithoutFromWarehouseInput, TransferUncheckedCreateWithoutFromWarehouseInput> | TransferCreateWithoutFromWarehouseInput[] | TransferUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromWarehouseInput | TransferCreateOrConnectWithoutFromWarehouseInput[]
    createMany?: TransferCreateManyFromWarehouseInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutToWarehouseInput = {
    create?: XOR<TransferCreateWithoutToWarehouseInput, TransferUncheckedCreateWithoutToWarehouseInput> | TransferCreateWithoutToWarehouseInput[] | TransferUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToWarehouseInput | TransferCreateOrConnectWithoutToWarehouseInput[]
    createMany?: TransferCreateManyToWarehouseInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput> | PurchaseOrderCreateWithoutWarehouseInput[] | PurchaseOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutWarehouseInput | PurchaseOrderCreateOrConnectWithoutWarehouseInput[]
    createMany?: PurchaseOrderCreateManyWarehouseInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type QualityControlUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<QualityControlCreateWithoutWarehouseInput, QualityControlUncheckedCreateWithoutWarehouseInput> | QualityControlCreateWithoutWarehouseInput[] | QualityControlUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutWarehouseInput | QualityControlCreateOrConnectWithoutWarehouseInput[]
    createMany?: QualityControlCreateManyWarehouseInputEnvelope
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
  }

  export type AuditUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<AuditCreateWithoutWarehouseInput, AuditUncheckedCreateWithoutWarehouseInput> | AuditCreateWithoutWarehouseInput[] | AuditUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutWarehouseInput | AuditCreateOrConnectWithoutWarehouseInput[]
    createMany?: AuditCreateManyWarehouseInputEnvelope
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
  }

  export type WarehouseZoneUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<WarehouseZoneCreateWithoutWarehouseInput, WarehouseZoneUncheckedCreateWithoutWarehouseInput> | WarehouseZoneCreateWithoutWarehouseInput[] | WarehouseZoneUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseZoneCreateOrConnectWithoutWarehouseInput | WarehouseZoneCreateOrConnectWithoutWarehouseInput[]
    upsert?: WarehouseZoneUpsertWithWhereUniqueWithoutWarehouseInput | WarehouseZoneUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: WarehouseZoneCreateManyWarehouseInputEnvelope
    set?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    disconnect?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    delete?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    connect?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    update?: WarehouseZoneUpdateWithWhereUniqueWithoutWarehouseInput | WarehouseZoneUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: WarehouseZoneUpdateManyWithWhereWithoutWarehouseInput | WarehouseZoneUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: WarehouseZoneScalarWhereInput | WarehouseZoneScalarWhereInput[]
  }

  export type InventoryItemUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput | InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput | InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutWarehouseInput | InventoryItemUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type WarehouseStaffUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<WarehouseStaffCreateWithoutWarehouseInput, WarehouseStaffUncheckedCreateWithoutWarehouseInput> | WarehouseStaffCreateWithoutWarehouseInput[] | WarehouseStaffUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutWarehouseInput | WarehouseStaffCreateOrConnectWithoutWarehouseInput[]
    upsert?: WarehouseStaffUpsertWithWhereUniqueWithoutWarehouseInput | WarehouseStaffUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: WarehouseStaffCreateManyWarehouseInputEnvelope
    set?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    disconnect?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    delete?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    connect?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    update?: WarehouseStaffUpdateWithWhereUniqueWithoutWarehouseInput | WarehouseStaffUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: WarehouseStaffUpdateManyWithWhereWithoutWarehouseInput | WarehouseStaffUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: WarehouseStaffScalarWhereInput | WarehouseStaffScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutFromWarehouseNestedInput = {
    create?: XOR<TransferCreateWithoutFromWarehouseInput, TransferUncheckedCreateWithoutFromWarehouseInput> | TransferCreateWithoutFromWarehouseInput[] | TransferUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromWarehouseInput | TransferCreateOrConnectWithoutFromWarehouseInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutFromWarehouseInput | TransferUpsertWithWhereUniqueWithoutFromWarehouseInput[]
    createMany?: TransferCreateManyFromWarehouseInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutFromWarehouseInput | TransferUpdateWithWhereUniqueWithoutFromWarehouseInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutFromWarehouseInput | TransferUpdateManyWithWhereWithoutFromWarehouseInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutToWarehouseNestedInput = {
    create?: XOR<TransferCreateWithoutToWarehouseInput, TransferUncheckedCreateWithoutToWarehouseInput> | TransferCreateWithoutToWarehouseInput[] | TransferUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToWarehouseInput | TransferCreateOrConnectWithoutToWarehouseInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutToWarehouseInput | TransferUpsertWithWhereUniqueWithoutToWarehouseInput[]
    createMany?: TransferCreateManyToWarehouseInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutToWarehouseInput | TransferUpdateWithWhereUniqueWithoutToWarehouseInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutToWarehouseInput | TransferUpdateManyWithWhereWithoutToWarehouseInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput> | PurchaseOrderCreateWithoutWarehouseInput[] | PurchaseOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutWarehouseInput | PurchaseOrderCreateOrConnectWithoutWarehouseInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutWarehouseInput | PurchaseOrderUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: PurchaseOrderCreateManyWarehouseInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutWarehouseInput | PurchaseOrderUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutWarehouseInput | PurchaseOrderUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type QualityControlUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<QualityControlCreateWithoutWarehouseInput, QualityControlUncheckedCreateWithoutWarehouseInput> | QualityControlCreateWithoutWarehouseInput[] | QualityControlUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutWarehouseInput | QualityControlCreateOrConnectWithoutWarehouseInput[]
    upsert?: QualityControlUpsertWithWhereUniqueWithoutWarehouseInput | QualityControlUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: QualityControlCreateManyWarehouseInputEnvelope
    set?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    disconnect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    delete?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    update?: QualityControlUpdateWithWhereUniqueWithoutWarehouseInput | QualityControlUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: QualityControlUpdateManyWithWhereWithoutWarehouseInput | QualityControlUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: QualityControlScalarWhereInput | QualityControlScalarWhereInput[]
  }

  export type AuditUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<AuditCreateWithoutWarehouseInput, AuditUncheckedCreateWithoutWarehouseInput> | AuditCreateWithoutWarehouseInput[] | AuditUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutWarehouseInput | AuditCreateOrConnectWithoutWarehouseInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutWarehouseInput | AuditUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: AuditCreateManyWarehouseInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutWarehouseInput | AuditUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutWarehouseInput | AuditUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<WarehouseZoneCreateWithoutWarehouseInput, WarehouseZoneUncheckedCreateWithoutWarehouseInput> | WarehouseZoneCreateWithoutWarehouseInput[] | WarehouseZoneUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseZoneCreateOrConnectWithoutWarehouseInput | WarehouseZoneCreateOrConnectWithoutWarehouseInput[]
    upsert?: WarehouseZoneUpsertWithWhereUniqueWithoutWarehouseInput | WarehouseZoneUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: WarehouseZoneCreateManyWarehouseInputEnvelope
    set?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    disconnect?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    delete?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    connect?: WarehouseZoneWhereUniqueInput | WarehouseZoneWhereUniqueInput[]
    update?: WarehouseZoneUpdateWithWhereUniqueWithoutWarehouseInput | WarehouseZoneUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: WarehouseZoneUpdateManyWithWhereWithoutWarehouseInput | WarehouseZoneUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: WarehouseZoneScalarWhereInput | WarehouseZoneScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput | InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput | InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutWarehouseInput | InventoryItemUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<WarehouseStaffCreateWithoutWarehouseInput, WarehouseStaffUncheckedCreateWithoutWarehouseInput> | WarehouseStaffCreateWithoutWarehouseInput[] | WarehouseStaffUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: WarehouseStaffCreateOrConnectWithoutWarehouseInput | WarehouseStaffCreateOrConnectWithoutWarehouseInput[]
    upsert?: WarehouseStaffUpsertWithWhereUniqueWithoutWarehouseInput | WarehouseStaffUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: WarehouseStaffCreateManyWarehouseInputEnvelope
    set?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    disconnect?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    delete?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    connect?: WarehouseStaffWhereUniqueInput | WarehouseStaffWhereUniqueInput[]
    update?: WarehouseStaffUpdateWithWhereUniqueWithoutWarehouseInput | WarehouseStaffUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: WarehouseStaffUpdateManyWithWhereWithoutWarehouseInput | WarehouseStaffUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: WarehouseStaffScalarWhereInput | WarehouseStaffScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput = {
    create?: XOR<TransferCreateWithoutFromWarehouseInput, TransferUncheckedCreateWithoutFromWarehouseInput> | TransferCreateWithoutFromWarehouseInput[] | TransferUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromWarehouseInput | TransferCreateOrConnectWithoutFromWarehouseInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutFromWarehouseInput | TransferUpsertWithWhereUniqueWithoutFromWarehouseInput[]
    createMany?: TransferCreateManyFromWarehouseInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutFromWarehouseInput | TransferUpdateWithWhereUniqueWithoutFromWarehouseInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutFromWarehouseInput | TransferUpdateManyWithWhereWithoutFromWarehouseInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutToWarehouseNestedInput = {
    create?: XOR<TransferCreateWithoutToWarehouseInput, TransferUncheckedCreateWithoutToWarehouseInput> | TransferCreateWithoutToWarehouseInput[] | TransferUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToWarehouseInput | TransferCreateOrConnectWithoutToWarehouseInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutToWarehouseInput | TransferUpsertWithWhereUniqueWithoutToWarehouseInput[]
    createMany?: TransferCreateManyToWarehouseInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutToWarehouseInput | TransferUpdateWithWhereUniqueWithoutToWarehouseInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutToWarehouseInput | TransferUpdateManyWithWhereWithoutToWarehouseInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput> | PurchaseOrderCreateWithoutWarehouseInput[] | PurchaseOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutWarehouseInput | PurchaseOrderCreateOrConnectWithoutWarehouseInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutWarehouseInput | PurchaseOrderUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: PurchaseOrderCreateManyWarehouseInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutWarehouseInput | PurchaseOrderUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutWarehouseInput | PurchaseOrderUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type QualityControlUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<QualityControlCreateWithoutWarehouseInput, QualityControlUncheckedCreateWithoutWarehouseInput> | QualityControlCreateWithoutWarehouseInput[] | QualityControlUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutWarehouseInput | QualityControlCreateOrConnectWithoutWarehouseInput[]
    upsert?: QualityControlUpsertWithWhereUniqueWithoutWarehouseInput | QualityControlUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: QualityControlCreateManyWarehouseInputEnvelope
    set?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    disconnect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    delete?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    update?: QualityControlUpdateWithWhereUniqueWithoutWarehouseInput | QualityControlUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: QualityControlUpdateManyWithWhereWithoutWarehouseInput | QualityControlUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: QualityControlScalarWhereInput | QualityControlScalarWhereInput[]
  }

  export type AuditUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<AuditCreateWithoutWarehouseInput, AuditUncheckedCreateWithoutWarehouseInput> | AuditCreateWithoutWarehouseInput[] | AuditUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: AuditCreateOrConnectWithoutWarehouseInput | AuditCreateOrConnectWithoutWarehouseInput[]
    upsert?: AuditUpsertWithWhereUniqueWithoutWarehouseInput | AuditUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: AuditCreateManyWarehouseInputEnvelope
    set?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    disconnect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    delete?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    connect?: AuditWhereUniqueInput | AuditWhereUniqueInput[]
    update?: AuditUpdateWithWhereUniqueWithoutWarehouseInput | AuditUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: AuditUpdateManyWithWhereWithoutWarehouseInput | AuditUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: AuditScalarWhereInput | AuditScalarWhereInput[]
  }

  export type WarehouseCreateNestedOneWithoutZonesInput = {
    create?: XOR<WarehouseCreateWithoutZonesInput, WarehouseUncheckedCreateWithoutZonesInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutZonesInput
    connect?: WarehouseWhereUniqueInput
  }

  export type WarehouseAisleCreateNestedManyWithoutZoneInput = {
    create?: XOR<WarehouseAisleCreateWithoutZoneInput, WarehouseAisleUncheckedCreateWithoutZoneInput> | WarehouseAisleCreateWithoutZoneInput[] | WarehouseAisleUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: WarehouseAisleCreateOrConnectWithoutZoneInput | WarehouseAisleCreateOrConnectWithoutZoneInput[]
    createMany?: WarehouseAisleCreateManyZoneInputEnvelope
    connect?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
  }

  export type WarehouseAisleUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<WarehouseAisleCreateWithoutZoneInput, WarehouseAisleUncheckedCreateWithoutZoneInput> | WarehouseAisleCreateWithoutZoneInput[] | WarehouseAisleUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: WarehouseAisleCreateOrConnectWithoutZoneInput | WarehouseAisleCreateOrConnectWithoutZoneInput[]
    createMany?: WarehouseAisleCreateManyZoneInputEnvelope
    connect?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
  }

  export type WarehouseUpdateOneRequiredWithoutZonesNestedInput = {
    create?: XOR<WarehouseCreateWithoutZonesInput, WarehouseUncheckedCreateWithoutZonesInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutZonesInput
    upsert?: WarehouseUpsertWithoutZonesInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutZonesInput, WarehouseUpdateWithoutZonesInput>, WarehouseUncheckedUpdateWithoutZonesInput>
  }

  export type WarehouseAisleUpdateManyWithoutZoneNestedInput = {
    create?: XOR<WarehouseAisleCreateWithoutZoneInput, WarehouseAisleUncheckedCreateWithoutZoneInput> | WarehouseAisleCreateWithoutZoneInput[] | WarehouseAisleUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: WarehouseAisleCreateOrConnectWithoutZoneInput | WarehouseAisleCreateOrConnectWithoutZoneInput[]
    upsert?: WarehouseAisleUpsertWithWhereUniqueWithoutZoneInput | WarehouseAisleUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: WarehouseAisleCreateManyZoneInputEnvelope
    set?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    disconnect?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    delete?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    connect?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    update?: WarehouseAisleUpdateWithWhereUniqueWithoutZoneInput | WarehouseAisleUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: WarehouseAisleUpdateManyWithWhereWithoutZoneInput | WarehouseAisleUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: WarehouseAisleScalarWhereInput | WarehouseAisleScalarWhereInput[]
  }

  export type WarehouseAisleUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<WarehouseAisleCreateWithoutZoneInput, WarehouseAisleUncheckedCreateWithoutZoneInput> | WarehouseAisleCreateWithoutZoneInput[] | WarehouseAisleUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: WarehouseAisleCreateOrConnectWithoutZoneInput | WarehouseAisleCreateOrConnectWithoutZoneInput[]
    upsert?: WarehouseAisleUpsertWithWhereUniqueWithoutZoneInput | WarehouseAisleUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: WarehouseAisleCreateManyZoneInputEnvelope
    set?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    disconnect?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    delete?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    connect?: WarehouseAisleWhereUniqueInput | WarehouseAisleWhereUniqueInput[]
    update?: WarehouseAisleUpdateWithWhereUniqueWithoutZoneInput | WarehouseAisleUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: WarehouseAisleUpdateManyWithWhereWithoutZoneInput | WarehouseAisleUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: WarehouseAisleScalarWhereInput | WarehouseAisleScalarWhereInput[]
  }

  export type WarehouseZoneCreateNestedOneWithoutAislesInput = {
    create?: XOR<WarehouseZoneCreateWithoutAislesInput, WarehouseZoneUncheckedCreateWithoutAislesInput>
    connectOrCreate?: WarehouseZoneCreateOrConnectWithoutAislesInput
    connect?: WarehouseZoneWhereUniqueInput
  }

  export type WarehouseShelfCreateNestedManyWithoutAisleInput = {
    create?: XOR<WarehouseShelfCreateWithoutAisleInput, WarehouseShelfUncheckedCreateWithoutAisleInput> | WarehouseShelfCreateWithoutAisleInput[] | WarehouseShelfUncheckedCreateWithoutAisleInput[]
    connectOrCreate?: WarehouseShelfCreateOrConnectWithoutAisleInput | WarehouseShelfCreateOrConnectWithoutAisleInput[]
    createMany?: WarehouseShelfCreateManyAisleInputEnvelope
    connect?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
  }

  export type WarehouseShelfUncheckedCreateNestedManyWithoutAisleInput = {
    create?: XOR<WarehouseShelfCreateWithoutAisleInput, WarehouseShelfUncheckedCreateWithoutAisleInput> | WarehouseShelfCreateWithoutAisleInput[] | WarehouseShelfUncheckedCreateWithoutAisleInput[]
    connectOrCreate?: WarehouseShelfCreateOrConnectWithoutAisleInput | WarehouseShelfCreateOrConnectWithoutAisleInput[]
    createMany?: WarehouseShelfCreateManyAisleInputEnvelope
    connect?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
  }

  export type WarehouseZoneUpdateOneRequiredWithoutAislesNestedInput = {
    create?: XOR<WarehouseZoneCreateWithoutAislesInput, WarehouseZoneUncheckedCreateWithoutAislesInput>
    connectOrCreate?: WarehouseZoneCreateOrConnectWithoutAislesInput
    upsert?: WarehouseZoneUpsertWithoutAislesInput
    connect?: WarehouseZoneWhereUniqueInput
    update?: XOR<XOR<WarehouseZoneUpdateToOneWithWhereWithoutAislesInput, WarehouseZoneUpdateWithoutAislesInput>, WarehouseZoneUncheckedUpdateWithoutAislesInput>
  }

  export type WarehouseShelfUpdateManyWithoutAisleNestedInput = {
    create?: XOR<WarehouseShelfCreateWithoutAisleInput, WarehouseShelfUncheckedCreateWithoutAisleInput> | WarehouseShelfCreateWithoutAisleInput[] | WarehouseShelfUncheckedCreateWithoutAisleInput[]
    connectOrCreate?: WarehouseShelfCreateOrConnectWithoutAisleInput | WarehouseShelfCreateOrConnectWithoutAisleInput[]
    upsert?: WarehouseShelfUpsertWithWhereUniqueWithoutAisleInput | WarehouseShelfUpsertWithWhereUniqueWithoutAisleInput[]
    createMany?: WarehouseShelfCreateManyAisleInputEnvelope
    set?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    disconnect?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    delete?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    connect?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    update?: WarehouseShelfUpdateWithWhereUniqueWithoutAisleInput | WarehouseShelfUpdateWithWhereUniqueWithoutAisleInput[]
    updateMany?: WarehouseShelfUpdateManyWithWhereWithoutAisleInput | WarehouseShelfUpdateManyWithWhereWithoutAisleInput[]
    deleteMany?: WarehouseShelfScalarWhereInput | WarehouseShelfScalarWhereInput[]
  }

  export type WarehouseShelfUncheckedUpdateManyWithoutAisleNestedInput = {
    create?: XOR<WarehouseShelfCreateWithoutAisleInput, WarehouseShelfUncheckedCreateWithoutAisleInput> | WarehouseShelfCreateWithoutAisleInput[] | WarehouseShelfUncheckedCreateWithoutAisleInput[]
    connectOrCreate?: WarehouseShelfCreateOrConnectWithoutAisleInput | WarehouseShelfCreateOrConnectWithoutAisleInput[]
    upsert?: WarehouseShelfUpsertWithWhereUniqueWithoutAisleInput | WarehouseShelfUpsertWithWhereUniqueWithoutAisleInput[]
    createMany?: WarehouseShelfCreateManyAisleInputEnvelope
    set?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    disconnect?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    delete?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    connect?: WarehouseShelfWhereUniqueInput | WarehouseShelfWhereUniqueInput[]
    update?: WarehouseShelfUpdateWithWhereUniqueWithoutAisleInput | WarehouseShelfUpdateWithWhereUniqueWithoutAisleInput[]
    updateMany?: WarehouseShelfUpdateManyWithWhereWithoutAisleInput | WarehouseShelfUpdateManyWithWhereWithoutAisleInput[]
    deleteMany?: WarehouseShelfScalarWhereInput | WarehouseShelfScalarWhereInput[]
  }

  export type WarehouseAisleCreateNestedOneWithoutShelvesInput = {
    create?: XOR<WarehouseAisleCreateWithoutShelvesInput, WarehouseAisleUncheckedCreateWithoutShelvesInput>
    connectOrCreate?: WarehouseAisleCreateOrConnectWithoutShelvesInput
    connect?: WarehouseAisleWhereUniqueInput
  }

  export type WarehouseBinCreateNestedManyWithoutShelfInput = {
    create?: XOR<WarehouseBinCreateWithoutShelfInput, WarehouseBinUncheckedCreateWithoutShelfInput> | WarehouseBinCreateWithoutShelfInput[] | WarehouseBinUncheckedCreateWithoutShelfInput[]
    connectOrCreate?: WarehouseBinCreateOrConnectWithoutShelfInput | WarehouseBinCreateOrConnectWithoutShelfInput[]
    createMany?: WarehouseBinCreateManyShelfInputEnvelope
    connect?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
  }

  export type WarehouseBinUncheckedCreateNestedManyWithoutShelfInput = {
    create?: XOR<WarehouseBinCreateWithoutShelfInput, WarehouseBinUncheckedCreateWithoutShelfInput> | WarehouseBinCreateWithoutShelfInput[] | WarehouseBinUncheckedCreateWithoutShelfInput[]
    connectOrCreate?: WarehouseBinCreateOrConnectWithoutShelfInput | WarehouseBinCreateOrConnectWithoutShelfInput[]
    createMany?: WarehouseBinCreateManyShelfInputEnvelope
    connect?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
  }

  export type WarehouseAisleUpdateOneRequiredWithoutShelvesNestedInput = {
    create?: XOR<WarehouseAisleCreateWithoutShelvesInput, WarehouseAisleUncheckedCreateWithoutShelvesInput>
    connectOrCreate?: WarehouseAisleCreateOrConnectWithoutShelvesInput
    upsert?: WarehouseAisleUpsertWithoutShelvesInput
    connect?: WarehouseAisleWhereUniqueInput
    update?: XOR<XOR<WarehouseAisleUpdateToOneWithWhereWithoutShelvesInput, WarehouseAisleUpdateWithoutShelvesInput>, WarehouseAisleUncheckedUpdateWithoutShelvesInput>
  }

  export type WarehouseBinUpdateManyWithoutShelfNestedInput = {
    create?: XOR<WarehouseBinCreateWithoutShelfInput, WarehouseBinUncheckedCreateWithoutShelfInput> | WarehouseBinCreateWithoutShelfInput[] | WarehouseBinUncheckedCreateWithoutShelfInput[]
    connectOrCreate?: WarehouseBinCreateOrConnectWithoutShelfInput | WarehouseBinCreateOrConnectWithoutShelfInput[]
    upsert?: WarehouseBinUpsertWithWhereUniqueWithoutShelfInput | WarehouseBinUpsertWithWhereUniqueWithoutShelfInput[]
    createMany?: WarehouseBinCreateManyShelfInputEnvelope
    set?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    disconnect?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    delete?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    connect?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    update?: WarehouseBinUpdateWithWhereUniqueWithoutShelfInput | WarehouseBinUpdateWithWhereUniqueWithoutShelfInput[]
    updateMany?: WarehouseBinUpdateManyWithWhereWithoutShelfInput | WarehouseBinUpdateManyWithWhereWithoutShelfInput[]
    deleteMany?: WarehouseBinScalarWhereInput | WarehouseBinScalarWhereInput[]
  }

  export type WarehouseBinUncheckedUpdateManyWithoutShelfNestedInput = {
    create?: XOR<WarehouseBinCreateWithoutShelfInput, WarehouseBinUncheckedCreateWithoutShelfInput> | WarehouseBinCreateWithoutShelfInput[] | WarehouseBinUncheckedCreateWithoutShelfInput[]
    connectOrCreate?: WarehouseBinCreateOrConnectWithoutShelfInput | WarehouseBinCreateOrConnectWithoutShelfInput[]
    upsert?: WarehouseBinUpsertWithWhereUniqueWithoutShelfInput | WarehouseBinUpsertWithWhereUniqueWithoutShelfInput[]
    createMany?: WarehouseBinCreateManyShelfInputEnvelope
    set?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    disconnect?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    delete?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    connect?: WarehouseBinWhereUniqueInput | WarehouseBinWhereUniqueInput[]
    update?: WarehouseBinUpdateWithWhereUniqueWithoutShelfInput | WarehouseBinUpdateWithWhereUniqueWithoutShelfInput[]
    updateMany?: WarehouseBinUpdateManyWithWhereWithoutShelfInput | WarehouseBinUpdateManyWithWhereWithoutShelfInput[]
    deleteMany?: WarehouseBinScalarWhereInput | WarehouseBinScalarWhereInput[]
  }

  export type WarehouseShelfCreateNestedOneWithoutBinsInput = {
    create?: XOR<WarehouseShelfCreateWithoutBinsInput, WarehouseShelfUncheckedCreateWithoutBinsInput>
    connectOrCreate?: WarehouseShelfCreateOrConnectWithoutBinsInput
    connect?: WarehouseShelfWhereUniqueInput
  }

  export type InventoryItemCreateNestedManyWithoutBinInput = {
    create?: XOR<InventoryItemCreateWithoutBinInput, InventoryItemUncheckedCreateWithoutBinInput> | InventoryItemCreateWithoutBinInput[] | InventoryItemUncheckedCreateWithoutBinInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBinInput | InventoryItemCreateOrConnectWithoutBinInput[]
    createMany?: InventoryItemCreateManyBinInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutBinInput = {
    create?: XOR<InventoryItemCreateWithoutBinInput, InventoryItemUncheckedCreateWithoutBinInput> | InventoryItemCreateWithoutBinInput[] | InventoryItemUncheckedCreateWithoutBinInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBinInput | InventoryItemCreateOrConnectWithoutBinInput[]
    createMany?: InventoryItemCreateManyBinInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type WarehouseShelfUpdateOneRequiredWithoutBinsNestedInput = {
    create?: XOR<WarehouseShelfCreateWithoutBinsInput, WarehouseShelfUncheckedCreateWithoutBinsInput>
    connectOrCreate?: WarehouseShelfCreateOrConnectWithoutBinsInput
    upsert?: WarehouseShelfUpsertWithoutBinsInput
    connect?: WarehouseShelfWhereUniqueInput
    update?: XOR<XOR<WarehouseShelfUpdateToOneWithWhereWithoutBinsInput, WarehouseShelfUpdateWithoutBinsInput>, WarehouseShelfUncheckedUpdateWithoutBinsInput>
  }

  export type InventoryItemUpdateManyWithoutBinNestedInput = {
    create?: XOR<InventoryItemCreateWithoutBinInput, InventoryItemUncheckedCreateWithoutBinInput> | InventoryItemCreateWithoutBinInput[] | InventoryItemUncheckedCreateWithoutBinInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBinInput | InventoryItemCreateOrConnectWithoutBinInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutBinInput | InventoryItemUpsertWithWhereUniqueWithoutBinInput[]
    createMany?: InventoryItemCreateManyBinInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutBinInput | InventoryItemUpdateWithWhereUniqueWithoutBinInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutBinInput | InventoryItemUpdateManyWithWhereWithoutBinInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutBinNestedInput = {
    create?: XOR<InventoryItemCreateWithoutBinInput, InventoryItemUncheckedCreateWithoutBinInput> | InventoryItemCreateWithoutBinInput[] | InventoryItemUncheckedCreateWithoutBinInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutBinInput | InventoryItemCreateOrConnectWithoutBinInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutBinInput | InventoryItemUpsertWithWhereUniqueWithoutBinInput[]
    createMany?: InventoryItemCreateManyBinInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutBinInput | InventoryItemUpdateWithWhereUniqueWithoutBinInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutBinInput | InventoryItemUpdateManyWithWhereWithoutBinInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWarehouseStaffInput = {
    create?: XOR<UserCreateWithoutWarehouseStaffInput, UserUncheckedCreateWithoutWarehouseStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutWarehouseStaffInput
    connect?: UserWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutStaffInput = {
    create?: XOR<WarehouseCreateWithoutStaffInput, WarehouseUncheckedCreateWithoutStaffInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStaffInput
    connect?: WarehouseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWarehouseStaffNestedInput = {
    create?: XOR<UserCreateWithoutWarehouseStaffInput, UserUncheckedCreateWithoutWarehouseStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutWarehouseStaffInput
    upsert?: UserUpsertWithoutWarehouseStaffInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWarehouseStaffInput, UserUpdateWithoutWarehouseStaffInput>, UserUncheckedUpdateWithoutWarehouseStaffInput>
  }

  export type WarehouseUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<WarehouseCreateWithoutStaffInput, WarehouseUncheckedCreateWithoutStaffInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutStaffInput
    upsert?: WarehouseUpsertWithoutStaffInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutStaffInput, WarehouseUpdateWithoutStaffInput>, WarehouseUncheckedUpdateWithoutStaffInput>
  }

  export type InventoryItemCreateNestedManyWithoutStoreInput = {
    create?: XOR<InventoryItemCreateWithoutStoreInput, InventoryItemUncheckedCreateWithoutStoreInput> | InventoryItemCreateWithoutStoreInput[] | InventoryItemUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutStoreInput | InventoryItemCreateOrConnectWithoutStoreInput[]
    createMany?: InventoryItemCreateManyStoreInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutStoreInput = {
    create?: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput> | SaleCreateWithoutStoreInput[] | SaleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutStoreInput | SaleCreateOrConnectWithoutStoreInput[]
    createMany?: SaleCreateManyStoreInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ReturnCreateNestedManyWithoutStoreInput = {
    create?: XOR<ReturnCreateWithoutStoreInput, ReturnUncheckedCreateWithoutStoreInput> | ReturnCreateWithoutStoreInput[] | ReturnUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutStoreInput | ReturnCreateOrConnectWithoutStoreInput[]
    createMany?: ReturnCreateManyStoreInputEnvelope
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
  }

  export type StoreStaffCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreStaffCreateWithoutStoreInput, StoreStaffUncheckedCreateWithoutStoreInput> | StoreStaffCreateWithoutStoreInput[] | StoreStaffUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreStaffCreateOrConnectWithoutStoreInput | StoreStaffCreateOrConnectWithoutStoreInput[]
    createMany?: StoreStaffCreateManyStoreInputEnvelope
    connect?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutFromStoreInput = {
    create?: XOR<TransferCreateWithoutFromStoreInput, TransferUncheckedCreateWithoutFromStoreInput> | TransferCreateWithoutFromStoreInput[] | TransferUncheckedCreateWithoutFromStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromStoreInput | TransferCreateOrConnectWithoutFromStoreInput[]
    createMany?: TransferCreateManyFromStoreInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutToStoreInput = {
    create?: XOR<TransferCreateWithoutToStoreInput, TransferUncheckedCreateWithoutToStoreInput> | TransferCreateWithoutToStoreInput[] | TransferUncheckedCreateWithoutToStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToStoreInput | TransferCreateOrConnectWithoutToStoreInput[]
    createMany?: TransferCreateManyToStoreInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<InventoryItemCreateWithoutStoreInput, InventoryItemUncheckedCreateWithoutStoreInput> | InventoryItemCreateWithoutStoreInput[] | InventoryItemUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutStoreInput | InventoryItemCreateOrConnectWithoutStoreInput[]
    createMany?: InventoryItemCreateManyStoreInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput> | SaleCreateWithoutStoreInput[] | SaleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutStoreInput | SaleCreateOrConnectWithoutStoreInput[]
    createMany?: SaleCreateManyStoreInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ReturnUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<ReturnCreateWithoutStoreInput, ReturnUncheckedCreateWithoutStoreInput> | ReturnCreateWithoutStoreInput[] | ReturnUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutStoreInput | ReturnCreateOrConnectWithoutStoreInput[]
    createMany?: ReturnCreateManyStoreInputEnvelope
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
  }

  export type StoreStaffUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreStaffCreateWithoutStoreInput, StoreStaffUncheckedCreateWithoutStoreInput> | StoreStaffCreateWithoutStoreInput[] | StoreStaffUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreStaffCreateOrConnectWithoutStoreInput | StoreStaffCreateOrConnectWithoutStoreInput[]
    createMany?: StoreStaffCreateManyStoreInputEnvelope
    connect?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutFromStoreInput = {
    create?: XOR<TransferCreateWithoutFromStoreInput, TransferUncheckedCreateWithoutFromStoreInput> | TransferCreateWithoutFromStoreInput[] | TransferUncheckedCreateWithoutFromStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromStoreInput | TransferCreateOrConnectWithoutFromStoreInput[]
    createMany?: TransferCreateManyFromStoreInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutToStoreInput = {
    create?: XOR<TransferCreateWithoutToStoreInput, TransferUncheckedCreateWithoutToStoreInput> | TransferCreateWithoutToStoreInput[] | TransferUncheckedCreateWithoutToStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToStoreInput | TransferCreateOrConnectWithoutToStoreInput[]
    createMany?: TransferCreateManyToStoreInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type InventoryItemUpdateManyWithoutStoreNestedInput = {
    create?: XOR<InventoryItemCreateWithoutStoreInput, InventoryItemUncheckedCreateWithoutStoreInput> | InventoryItemCreateWithoutStoreInput[] | InventoryItemUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutStoreInput | InventoryItemCreateOrConnectWithoutStoreInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutStoreInput | InventoryItemUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: InventoryItemCreateManyStoreInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutStoreInput | InventoryItemUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutStoreInput | InventoryItemUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput> | SaleCreateWithoutStoreInput[] | SaleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutStoreInput | SaleCreateOrConnectWithoutStoreInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutStoreInput | SaleUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SaleCreateManyStoreInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutStoreInput | SaleUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutStoreInput | SaleUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ReturnUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ReturnCreateWithoutStoreInput, ReturnUncheckedCreateWithoutStoreInput> | ReturnCreateWithoutStoreInput[] | ReturnUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutStoreInput | ReturnCreateOrConnectWithoutStoreInput[]
    upsert?: ReturnUpsertWithWhereUniqueWithoutStoreInput | ReturnUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ReturnCreateManyStoreInputEnvelope
    set?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    disconnect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    delete?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    update?: ReturnUpdateWithWhereUniqueWithoutStoreInput | ReturnUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ReturnUpdateManyWithWhereWithoutStoreInput | ReturnUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ReturnScalarWhereInput | ReturnScalarWhereInput[]
  }

  export type StoreStaffUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreStaffCreateWithoutStoreInput, StoreStaffUncheckedCreateWithoutStoreInput> | StoreStaffCreateWithoutStoreInput[] | StoreStaffUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreStaffCreateOrConnectWithoutStoreInput | StoreStaffCreateOrConnectWithoutStoreInput[]
    upsert?: StoreStaffUpsertWithWhereUniqueWithoutStoreInput | StoreStaffUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreStaffCreateManyStoreInputEnvelope
    set?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    disconnect?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    delete?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    connect?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    update?: StoreStaffUpdateWithWhereUniqueWithoutStoreInput | StoreStaffUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreStaffUpdateManyWithWhereWithoutStoreInput | StoreStaffUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreStaffScalarWhereInput | StoreStaffScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutFromStoreNestedInput = {
    create?: XOR<TransferCreateWithoutFromStoreInput, TransferUncheckedCreateWithoutFromStoreInput> | TransferCreateWithoutFromStoreInput[] | TransferUncheckedCreateWithoutFromStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromStoreInput | TransferCreateOrConnectWithoutFromStoreInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutFromStoreInput | TransferUpsertWithWhereUniqueWithoutFromStoreInput[]
    createMany?: TransferCreateManyFromStoreInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutFromStoreInput | TransferUpdateWithWhereUniqueWithoutFromStoreInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutFromStoreInput | TransferUpdateManyWithWhereWithoutFromStoreInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutToStoreNestedInput = {
    create?: XOR<TransferCreateWithoutToStoreInput, TransferUncheckedCreateWithoutToStoreInput> | TransferCreateWithoutToStoreInput[] | TransferUncheckedCreateWithoutToStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToStoreInput | TransferCreateOrConnectWithoutToStoreInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutToStoreInput | TransferUpsertWithWhereUniqueWithoutToStoreInput[]
    createMany?: TransferCreateManyToStoreInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutToStoreInput | TransferUpdateWithWhereUniqueWithoutToStoreInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutToStoreInput | TransferUpdateManyWithWhereWithoutToStoreInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<InventoryItemCreateWithoutStoreInput, InventoryItemUncheckedCreateWithoutStoreInput> | InventoryItemCreateWithoutStoreInput[] | InventoryItemUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutStoreInput | InventoryItemCreateOrConnectWithoutStoreInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutStoreInput | InventoryItemUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: InventoryItemCreateManyStoreInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutStoreInput | InventoryItemUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutStoreInput | InventoryItemUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput> | SaleCreateWithoutStoreInput[] | SaleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutStoreInput | SaleCreateOrConnectWithoutStoreInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutStoreInput | SaleUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SaleCreateManyStoreInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutStoreInput | SaleUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutStoreInput | SaleUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ReturnUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ReturnCreateWithoutStoreInput, ReturnUncheckedCreateWithoutStoreInput> | ReturnCreateWithoutStoreInput[] | ReturnUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutStoreInput | ReturnCreateOrConnectWithoutStoreInput[]
    upsert?: ReturnUpsertWithWhereUniqueWithoutStoreInput | ReturnUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ReturnCreateManyStoreInputEnvelope
    set?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    disconnect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    delete?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    update?: ReturnUpdateWithWhereUniqueWithoutStoreInput | ReturnUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ReturnUpdateManyWithWhereWithoutStoreInput | ReturnUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ReturnScalarWhereInput | ReturnScalarWhereInput[]
  }

  export type StoreStaffUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreStaffCreateWithoutStoreInput, StoreStaffUncheckedCreateWithoutStoreInput> | StoreStaffCreateWithoutStoreInput[] | StoreStaffUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreStaffCreateOrConnectWithoutStoreInput | StoreStaffCreateOrConnectWithoutStoreInput[]
    upsert?: StoreStaffUpsertWithWhereUniqueWithoutStoreInput | StoreStaffUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreStaffCreateManyStoreInputEnvelope
    set?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    disconnect?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    delete?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    connect?: StoreStaffWhereUniqueInput | StoreStaffWhereUniqueInput[]
    update?: StoreStaffUpdateWithWhereUniqueWithoutStoreInput | StoreStaffUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreStaffUpdateManyWithWhereWithoutStoreInput | StoreStaffUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreStaffScalarWhereInput | StoreStaffScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutFromStoreNestedInput = {
    create?: XOR<TransferCreateWithoutFromStoreInput, TransferUncheckedCreateWithoutFromStoreInput> | TransferCreateWithoutFromStoreInput[] | TransferUncheckedCreateWithoutFromStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutFromStoreInput | TransferCreateOrConnectWithoutFromStoreInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutFromStoreInput | TransferUpsertWithWhereUniqueWithoutFromStoreInput[]
    createMany?: TransferCreateManyFromStoreInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutFromStoreInput | TransferUpdateWithWhereUniqueWithoutFromStoreInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutFromStoreInput | TransferUpdateManyWithWhereWithoutFromStoreInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutToStoreNestedInput = {
    create?: XOR<TransferCreateWithoutToStoreInput, TransferUncheckedCreateWithoutToStoreInput> | TransferCreateWithoutToStoreInput[] | TransferUncheckedCreateWithoutToStoreInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutToStoreInput | TransferCreateOrConnectWithoutToStoreInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutToStoreInput | TransferUpsertWithWhereUniqueWithoutToStoreInput[]
    createMany?: TransferCreateManyToStoreInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutToStoreInput | TransferUpdateWithWhereUniqueWithoutToStoreInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutToStoreInput | TransferUpdateManyWithWhereWithoutToStoreInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStoreStaffInput = {
    create?: XOR<UserCreateWithoutStoreStaffInput, UserUncheckedCreateWithoutStoreStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoreStaffInput
    connect?: UserWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutStaffInput = {
    create?: XOR<StoreCreateWithoutStaffInput, StoreUncheckedCreateWithoutStaffInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStaffInput
    connect?: StoreWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStoreStaffNestedInput = {
    create?: XOR<UserCreateWithoutStoreStaffInput, UserUncheckedCreateWithoutStoreStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoreStaffInput
    upsert?: UserUpsertWithoutStoreStaffInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoreStaffInput, UserUpdateWithoutStoreStaffInput>, UserUncheckedUpdateWithoutStoreStaffInput>
  }

  export type StoreUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<StoreCreateWithoutStaffInput, StoreUncheckedCreateWithoutStaffInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStaffInput
    upsert?: StoreUpsertWithoutStaffInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutStaffInput, StoreUpdateWithoutStaffInput>, StoreUncheckedUpdateWithoutStaffInput>
  }

  export type ProductCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SupplierContractCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierContractCreateWithoutSupplierInput, SupplierContractUncheckedCreateWithoutSupplierInput> | SupplierContractCreateWithoutSupplierInput[] | SupplierContractUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierContractCreateOrConnectWithoutSupplierInput | SupplierContractCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierContractCreateManySupplierInputEnvelope
    connect?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SupplierPerformanceMetricCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierPerformanceMetricCreateWithoutSupplierInput, SupplierPerformanceMetricUncheckedCreateWithoutSupplierInput> | SupplierPerformanceMetricCreateWithoutSupplierInput[] | SupplierPerformanceMetricUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierPerformanceMetricCreateOrConnectWithoutSupplierInput | SupplierPerformanceMetricCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierPerformanceMetricCreateManySupplierInputEnvelope
    connect?: SupplierPerformanceMetricWhereUniqueInput | SupplierPerformanceMetricWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SupplierContractUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierContractCreateWithoutSupplierInput, SupplierContractUncheckedCreateWithoutSupplierInput> | SupplierContractCreateWithoutSupplierInput[] | SupplierContractUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierContractCreateOrConnectWithoutSupplierInput | SupplierContractCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierContractCreateManySupplierInputEnvelope
    connect?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SupplierPerformanceMetricUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierPerformanceMetricCreateWithoutSupplierInput, SupplierPerformanceMetricUncheckedCreateWithoutSupplierInput> | SupplierPerformanceMetricCreateWithoutSupplierInput[] | SupplierPerformanceMetricUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierPerformanceMetricCreateOrConnectWithoutSupplierInput | SupplierPerformanceMetricCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierPerformanceMetricCreateManySupplierInputEnvelope
    connect?: SupplierPerformanceMetricWhereUniqueInput | SupplierPerformanceMetricWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSupplierInput | ProductUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSupplierInput | ProductUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSupplierInput | ProductUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SupplierContractUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierContractCreateWithoutSupplierInput, SupplierContractUncheckedCreateWithoutSupplierInput> | SupplierContractCreateWithoutSupplierInput[] | SupplierContractUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierContractCreateOrConnectWithoutSupplierInput | SupplierContractCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierContractUpsertWithWhereUniqueWithoutSupplierInput | SupplierContractUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierContractCreateManySupplierInputEnvelope
    set?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    disconnect?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    delete?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    connect?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    update?: SupplierContractUpdateWithWhereUniqueWithoutSupplierInput | SupplierContractUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierContractUpdateManyWithWhereWithoutSupplierInput | SupplierContractUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierContractScalarWhereInput | SupplierContractScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SupplierPerformanceMetricUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierPerformanceMetricCreateWithoutSupplierInput, SupplierPerformanceMetricUncheckedCreateWithoutSupplierInput> | SupplierPerformanceMetricCreateWithoutSupplierInput[] | SupplierPerformanceMetricUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierPerformanceMetricCreateOrConnectWithoutSupplierInput | SupplierPerformanceMetricCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierPerformanceMetricUpsertWithWhereUniqueWithoutSupplierInput | SupplierPerformanceMetricUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierPerformanceMetricCreateManySupplierInputEnvelope
    set?: SupplierPerformanceMetricWhereUniqueInput | SupplierPerformanceMetricWhereUniqueInput[]
    disconnect?: SupplierPerformanceMetricWhereUniqueInput | SupplierPerformanceMetricWhereUniqueInput[]
    delete?: SupplierPerformanceMetricWhereUniqueInput | SupplierPerformanceMetricWhereUniqueInput[]
    connect?: SupplierPerformanceMetricWhereUniqueInput | SupplierPerformanceMetricWhereUniqueInput[]
    update?: SupplierPerformanceMetricUpdateWithWhereUniqueWithoutSupplierInput | SupplierPerformanceMetricUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierPerformanceMetricUpdateManyWithWhereWithoutSupplierInput | SupplierPerformanceMetricUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierPerformanceMetricScalarWhereInput | SupplierPerformanceMetricScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSupplierInput | ProductUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSupplierInput | ProductUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSupplierInput | ProductUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SupplierContractUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierContractCreateWithoutSupplierInput, SupplierContractUncheckedCreateWithoutSupplierInput> | SupplierContractCreateWithoutSupplierInput[] | SupplierContractUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierContractCreateOrConnectWithoutSupplierInput | SupplierContractCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierContractUpsertWithWhereUniqueWithoutSupplierInput | SupplierContractUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierContractCreateManySupplierInputEnvelope
    set?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    disconnect?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    delete?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    connect?: SupplierContractWhereUniqueInput | SupplierContractWhereUniqueInput[]
    update?: SupplierContractUpdateWithWhereUniqueWithoutSupplierInput | SupplierContractUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierContractUpdateManyWithWhereWithoutSupplierInput | SupplierContractUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierContractScalarWhereInput | SupplierContractScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SupplierPerformanceMetricUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierPerformanceMetricCreateWithoutSupplierInput, SupplierPerformanceMetricUncheckedCreateWithoutSupplierInput> | SupplierPerformanceMetricCreateWithoutSupplierInput[] | SupplierPerformanceMetricUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierPerformanceMetricCreateOrConnectWithoutSupplierInput | SupplierPerformanceMetricCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierPerformanceMetricUpsertWithWhereUniqueWithoutSupplierInput | SupplierPerformanceMetricUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierPerformanceMetricCreateManySupplierInputEnvelope
    set?: SupplierPerformanceMetricWhereUniqueInput | SupplierPerformanceMetricWhereUniqueInput[]
    disconnect?: SupplierPerformanceMetricWhereUniqueInput | SupplierPerformanceMetricWhereUniqueInput[]
    delete?: SupplierPerformanceMetricWhereUniqueInput | SupplierPerformanceMetricWhereUniqueInput[]
    connect?: SupplierPerformanceMetricWhereUniqueInput | SupplierPerformanceMetricWhereUniqueInput[]
    update?: SupplierPerformanceMetricUpdateWithWhereUniqueWithoutSupplierInput | SupplierPerformanceMetricUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierPerformanceMetricUpdateManyWithWhereWithoutSupplierInput | SupplierPerformanceMetricUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierPerformanceMetricScalarWhereInput | SupplierPerformanceMetricScalarWhereInput[]
  }

  export type SupplierCreateNestedOneWithoutContractsInput = {
    create?: XOR<SupplierCreateWithoutContractsInput, SupplierUncheckedCreateWithoutContractsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutContractsInput
    connect?: SupplierWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumContractStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContractStatus
  }

  export type SupplierUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<SupplierCreateWithoutContractsInput, SupplierUncheckedCreateWithoutContractsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutContractsInput
    upsert?: SupplierUpsertWithoutContractsInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutContractsInput, SupplierUpdateWithoutContractsInput>, SupplierUncheckedUpdateWithoutContractsInput>
  }

  export type SupplierCreateNestedOneWithoutPerformanceMetricsInput = {
    create?: XOR<SupplierCreateWithoutPerformanceMetricsInput, SupplierUncheckedCreateWithoutPerformanceMetricsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPerformanceMetricsInput
    connect?: SupplierWhereUniqueInput
  }

  export type EnumPerformanceMetricTypeFieldUpdateOperationsInput = {
    set?: $Enums.PerformanceMetricType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SupplierUpdateOneRequiredWithoutPerformanceMetricsNestedInput = {
    create?: XOR<SupplierCreateWithoutPerformanceMetricsInput, SupplierUncheckedCreateWithoutPerformanceMetricsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPerformanceMetricsInput
    upsert?: SupplierUpsertWithoutPerformanceMetricsInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPerformanceMetricsInput, SupplierUpdateWithoutPerformanceMetricsInput>, SupplierUncheckedUpdateWithoutPerformanceMetricsInput>
  }

  export type SupplierCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    connect?: SupplierWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<WarehouseCreateWithoutPurchaseOrdersInput, WarehouseUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutPurchaseOrdersInput
    connect?: WarehouseWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type QualityControlCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<QualityControlCreateWithoutPurchaseOrderInput, QualityControlUncheckedCreateWithoutPurchaseOrderInput> | QualityControlCreateWithoutPurchaseOrderInput[] | QualityControlUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutPurchaseOrderInput | QualityControlCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: QualityControlCreateManyPurchaseOrderInputEnvelope
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type QualityControlUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<QualityControlCreateWithoutPurchaseOrderInput, QualityControlUncheckedCreateWithoutPurchaseOrderInput> | QualityControlCreateWithoutPurchaseOrderInput[] | QualityControlUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutPurchaseOrderInput | QualityControlCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: QualityControlCreateManyPurchaseOrderInputEnvelope
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
  }

  export type EnumPurchaseOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.PurchaseOrderStatus
  }

  export type SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: SupplierUpsertWithoutPurchaseOrdersInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput, SupplierUpdateWithoutPurchaseOrdersInput>, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type WarehouseUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<WarehouseCreateWithoutPurchaseOrdersInput, WarehouseUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: WarehouseUpsertWithoutPurchaseOrdersInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutPurchaseOrdersInput, WarehouseUpdateWithoutPurchaseOrdersInput>, WarehouseUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type QualityControlUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<QualityControlCreateWithoutPurchaseOrderInput, QualityControlUncheckedCreateWithoutPurchaseOrderInput> | QualityControlCreateWithoutPurchaseOrderInput[] | QualityControlUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutPurchaseOrderInput | QualityControlCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: QualityControlUpsertWithWhereUniqueWithoutPurchaseOrderInput | QualityControlUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: QualityControlCreateManyPurchaseOrderInputEnvelope
    set?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    disconnect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    delete?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    update?: QualityControlUpdateWithWhereUniqueWithoutPurchaseOrderInput | QualityControlUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: QualityControlUpdateManyWithWhereWithoutPurchaseOrderInput | QualityControlUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: QualityControlScalarWhereInput | QualityControlScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type QualityControlUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<QualityControlCreateWithoutPurchaseOrderInput, QualityControlUncheckedCreateWithoutPurchaseOrderInput> | QualityControlCreateWithoutPurchaseOrderInput[] | QualityControlUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutPurchaseOrderInput | QualityControlCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: QualityControlUpsertWithWhereUniqueWithoutPurchaseOrderInput | QualityControlUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: QualityControlCreateManyPurchaseOrderInputEnvelope
    set?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    disconnect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    delete?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    update?: QualityControlUpdateWithWhereUniqueWithoutPurchaseOrderInput | QualityControlUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: QualityControlUpdateManyWithWhereWithoutPurchaseOrderInput | QualityControlUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: QualityControlScalarWhereInput | QualityControlScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPurchaseOrderItemsInput = {
    create?: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    upsert?: PurchaseOrderUpsertWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutItemsInput, PurchaseOrderUpdateWithoutItemsInput>, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseOrderItemsInput
    upsert?: ProductUpsertWithoutPurchaseOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchaseOrderItemsInput, ProductUpdateWithoutPurchaseOrderItemsInput>, ProductUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutProductsInput = {
    create?: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutProductsInput
    connect?: SupplierWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type QualityControlItemCreateNestedManyWithoutProductInput = {
    create?: XOR<QualityControlItemCreateWithoutProductInput, QualityControlItemUncheckedCreateWithoutProductInput> | QualityControlItemCreateWithoutProductInput[] | QualityControlItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: QualityControlItemCreateOrConnectWithoutProductInput | QualityControlItemCreateOrConnectWithoutProductInput[]
    createMany?: QualityControlItemCreateManyProductInputEnvelope
    connect?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
  }

  export type ReturnItemCreateNestedManyWithoutProductInput = {
    create?: XOR<ReturnItemCreateWithoutProductInput, ReturnItemUncheckedCreateWithoutProductInput> | ReturnItemCreateWithoutProductInput[] | ReturnItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReturnItemCreateOrConnectWithoutProductInput | ReturnItemCreateOrConnectWithoutProductInput[]
    createMany?: ReturnItemCreateManyProductInputEnvelope
    connect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
  }

  export type InventoryItemCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput> | InventoryItemCreateWithoutProductInput[] | InventoryItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProductInput | InventoryItemCreateOrConnectWithoutProductInput[]
    createMany?: InventoryItemCreateManyProductInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type SaleItemCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type TransferItemCreateNestedManyWithoutProductInput = {
    create?: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput> | TransferItemCreateWithoutProductInput[] | TransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutProductInput | TransferItemCreateOrConnectWithoutProductInput[]
    createMany?: TransferItemCreateManyProductInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type AuditItemCreateNestedManyWithoutProductInput = {
    create?: XOR<AuditItemCreateWithoutProductInput, AuditItemUncheckedCreateWithoutProductInput> | AuditItemCreateWithoutProductInput[] | AuditItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutProductInput | AuditItemCreateOrConnectWithoutProductInput[]
    createMany?: AuditItemCreateManyProductInputEnvelope
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type QualityControlItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<QualityControlItemCreateWithoutProductInput, QualityControlItemUncheckedCreateWithoutProductInput> | QualityControlItemCreateWithoutProductInput[] | QualityControlItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: QualityControlItemCreateOrConnectWithoutProductInput | QualityControlItemCreateOrConnectWithoutProductInput[]
    createMany?: QualityControlItemCreateManyProductInputEnvelope
    connect?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
  }

  export type ReturnItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ReturnItemCreateWithoutProductInput, ReturnItemUncheckedCreateWithoutProductInput> | ReturnItemCreateWithoutProductInput[] | ReturnItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReturnItemCreateOrConnectWithoutProductInput | ReturnItemCreateOrConnectWithoutProductInput[]
    createMany?: ReturnItemCreateManyProductInputEnvelope
    connect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput> | InventoryItemCreateWithoutProductInput[] | InventoryItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProductInput | InventoryItemCreateOrConnectWithoutProductInput[]
    createMany?: InventoryItemCreateManyProductInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type SaleItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type TransferItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput> | TransferItemCreateWithoutProductInput[] | TransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutProductInput | TransferItemCreateOrConnectWithoutProductInput[]
    createMany?: TransferItemCreateManyProductInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type AuditItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<AuditItemCreateWithoutProductInput, AuditItemUncheckedCreateWithoutProductInput> | AuditItemCreateWithoutProductInput[] | AuditItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutProductInput | AuditItemCreateOrConnectWithoutProductInput[]
    createMany?: AuditItemCreateManyProductInputEnvelope
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
  }

  export type EnumProductConditionFieldUpdateOperationsInput = {
    set?: $Enums.ProductCondition
  }

  export type CategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type SupplierUpdateOneWithoutProductsNestedInput = {
    create?: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutProductsInput
    upsert?: SupplierUpsertWithoutProductsInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutProductsInput, SupplierUpdateWithoutProductsInput>, SupplierUncheckedUpdateWithoutProductsInput>
  }

  export type PurchaseOrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutProductInput | PurchaseOrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type QualityControlItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<QualityControlItemCreateWithoutProductInput, QualityControlItemUncheckedCreateWithoutProductInput> | QualityControlItemCreateWithoutProductInput[] | QualityControlItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: QualityControlItemCreateOrConnectWithoutProductInput | QualityControlItemCreateOrConnectWithoutProductInput[]
    upsert?: QualityControlItemUpsertWithWhereUniqueWithoutProductInput | QualityControlItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: QualityControlItemCreateManyProductInputEnvelope
    set?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    disconnect?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    delete?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    connect?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    update?: QualityControlItemUpdateWithWhereUniqueWithoutProductInput | QualityControlItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: QualityControlItemUpdateManyWithWhereWithoutProductInput | QualityControlItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: QualityControlItemScalarWhereInput | QualityControlItemScalarWhereInput[]
  }

  export type ReturnItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReturnItemCreateWithoutProductInput, ReturnItemUncheckedCreateWithoutProductInput> | ReturnItemCreateWithoutProductInput[] | ReturnItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReturnItemCreateOrConnectWithoutProductInput | ReturnItemCreateOrConnectWithoutProductInput[]
    upsert?: ReturnItemUpsertWithWhereUniqueWithoutProductInput | ReturnItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReturnItemCreateManyProductInputEnvelope
    set?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    disconnect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    delete?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    connect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    update?: ReturnItemUpdateWithWhereUniqueWithoutProductInput | ReturnItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReturnItemUpdateManyWithWhereWithoutProductInput | ReturnItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReturnItemScalarWhereInput | ReturnItemScalarWhereInput[]
  }

  export type InventoryItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput> | InventoryItemCreateWithoutProductInput[] | InventoryItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProductInput | InventoryItemCreateOrConnectWithoutProductInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutProductInput | InventoryItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryItemCreateManyProductInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutProductInput | InventoryItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutProductInput | InventoryItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type SaleItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutProductInput | SaleItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutProductInput | SaleItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutProductInput | SaleItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type TransferItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput> | TransferItemCreateWithoutProductInput[] | TransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutProductInput | TransferItemCreateOrConnectWithoutProductInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutProductInput | TransferItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransferItemCreateManyProductInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutProductInput | TransferItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutProductInput | TransferItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type AuditItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<AuditItemCreateWithoutProductInput, AuditItemUncheckedCreateWithoutProductInput> | AuditItemCreateWithoutProductInput[] | AuditItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutProductInput | AuditItemCreateOrConnectWithoutProductInput[]
    upsert?: AuditItemUpsertWithWhereUniqueWithoutProductInput | AuditItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AuditItemCreateManyProductInputEnvelope
    set?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    disconnect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    delete?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    update?: AuditItemUpdateWithWhereUniqueWithoutProductInput | AuditItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AuditItemUpdateManyWithWhereWithoutProductInput | AuditItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput> | PurchaseOrderItemCreateWithoutProductInput[] | PurchaseOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutProductInput | PurchaseOrderItemCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseOrderItemCreateManyProductInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutProductInput | PurchaseOrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type QualityControlItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<QualityControlItemCreateWithoutProductInput, QualityControlItemUncheckedCreateWithoutProductInput> | QualityControlItemCreateWithoutProductInput[] | QualityControlItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: QualityControlItemCreateOrConnectWithoutProductInput | QualityControlItemCreateOrConnectWithoutProductInput[]
    upsert?: QualityControlItemUpsertWithWhereUniqueWithoutProductInput | QualityControlItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: QualityControlItemCreateManyProductInputEnvelope
    set?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    disconnect?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    delete?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    connect?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    update?: QualityControlItemUpdateWithWhereUniqueWithoutProductInput | QualityControlItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: QualityControlItemUpdateManyWithWhereWithoutProductInput | QualityControlItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: QualityControlItemScalarWhereInput | QualityControlItemScalarWhereInput[]
  }

  export type ReturnItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReturnItemCreateWithoutProductInput, ReturnItemUncheckedCreateWithoutProductInput> | ReturnItemCreateWithoutProductInput[] | ReturnItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReturnItemCreateOrConnectWithoutProductInput | ReturnItemCreateOrConnectWithoutProductInput[]
    upsert?: ReturnItemUpsertWithWhereUniqueWithoutProductInput | ReturnItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReturnItemCreateManyProductInputEnvelope
    set?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    disconnect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    delete?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    connect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    update?: ReturnItemUpdateWithWhereUniqueWithoutProductInput | ReturnItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReturnItemUpdateManyWithWhereWithoutProductInput | ReturnItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReturnItemScalarWhereInput | ReturnItemScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput> | InventoryItemCreateWithoutProductInput[] | InventoryItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProductInput | InventoryItemCreateOrConnectWithoutProductInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutProductInput | InventoryItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryItemCreateManyProductInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutProductInput | InventoryItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutProductInput | InventoryItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type SaleItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutProductInput | SaleItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutProductInput | SaleItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutProductInput | SaleItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type TransferItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput> | TransferItemCreateWithoutProductInput[] | TransferItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutProductInput | TransferItemCreateOrConnectWithoutProductInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutProductInput | TransferItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransferItemCreateManyProductInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutProductInput | TransferItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutProductInput | TransferItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type AuditItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<AuditItemCreateWithoutProductInput, AuditItemUncheckedCreateWithoutProductInput> | AuditItemCreateWithoutProductInput[] | AuditItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutProductInput | AuditItemCreateOrConnectWithoutProductInput[]
    upsert?: AuditItemUpsertWithWhereUniqueWithoutProductInput | AuditItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AuditItemCreateManyProductInputEnvelope
    set?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    disconnect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    delete?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    update?: AuditItemUpdateWithWhereUniqueWithoutProductInput | AuditItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AuditItemUpdateManyWithWhereWithoutProductInput | AuditItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryPriceRuleCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategoryPriceRuleCreateWithoutCategoryInput, CategoryPriceRuleUncheckedCreateWithoutCategoryInput> | CategoryPriceRuleCreateWithoutCategoryInput[] | CategoryPriceRuleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryPriceRuleCreateOrConnectWithoutCategoryInput | CategoryPriceRuleCreateOrConnectWithoutCategoryInput[]
    createMany?: CategoryPriceRuleCreateManyCategoryInputEnvelope
    connect?: CategoryPriceRuleWhereUniqueInput | CategoryPriceRuleWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryPriceRuleUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CategoryPriceRuleCreateWithoutCategoryInput, CategoryPriceRuleUncheckedCreateWithoutCategoryInput> | CategoryPriceRuleCreateWithoutCategoryInput[] | CategoryPriceRuleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryPriceRuleCreateOrConnectWithoutCategoryInput | CategoryPriceRuleCreateOrConnectWithoutCategoryInput[]
    createMany?: CategoryPriceRuleCreateManyCategoryInputEnvelope
    connect?: CategoryPriceRuleWhereUniqueInput | CategoryPriceRuleWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryPriceRuleUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategoryPriceRuleCreateWithoutCategoryInput, CategoryPriceRuleUncheckedCreateWithoutCategoryInput> | CategoryPriceRuleCreateWithoutCategoryInput[] | CategoryPriceRuleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryPriceRuleCreateOrConnectWithoutCategoryInput | CategoryPriceRuleCreateOrConnectWithoutCategoryInput[]
    upsert?: CategoryPriceRuleUpsertWithWhereUniqueWithoutCategoryInput | CategoryPriceRuleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategoryPriceRuleCreateManyCategoryInputEnvelope
    set?: CategoryPriceRuleWhereUniqueInput | CategoryPriceRuleWhereUniqueInput[]
    disconnect?: CategoryPriceRuleWhereUniqueInput | CategoryPriceRuleWhereUniqueInput[]
    delete?: CategoryPriceRuleWhereUniqueInput | CategoryPriceRuleWhereUniqueInput[]
    connect?: CategoryPriceRuleWhereUniqueInput | CategoryPriceRuleWhereUniqueInput[]
    update?: CategoryPriceRuleUpdateWithWhereUniqueWithoutCategoryInput | CategoryPriceRuleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategoryPriceRuleUpdateManyWithWhereWithoutCategoryInput | CategoryPriceRuleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategoryPriceRuleScalarWhereInput | CategoryPriceRuleScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryPriceRuleUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CategoryPriceRuleCreateWithoutCategoryInput, CategoryPriceRuleUncheckedCreateWithoutCategoryInput> | CategoryPriceRuleCreateWithoutCategoryInput[] | CategoryPriceRuleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CategoryPriceRuleCreateOrConnectWithoutCategoryInput | CategoryPriceRuleCreateOrConnectWithoutCategoryInput[]
    upsert?: CategoryPriceRuleUpsertWithWhereUniqueWithoutCategoryInput | CategoryPriceRuleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CategoryPriceRuleCreateManyCategoryInputEnvelope
    set?: CategoryPriceRuleWhereUniqueInput | CategoryPriceRuleWhereUniqueInput[]
    disconnect?: CategoryPriceRuleWhereUniqueInput | CategoryPriceRuleWhereUniqueInput[]
    delete?: CategoryPriceRuleWhereUniqueInput | CategoryPriceRuleWhereUniqueInput[]
    connect?: CategoryPriceRuleWhereUniqueInput | CategoryPriceRuleWhereUniqueInput[]
    update?: CategoryPriceRuleUpdateWithWhereUniqueWithoutCategoryInput | CategoryPriceRuleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CategoryPriceRuleUpdateManyWithWhereWithoutCategoryInput | CategoryPriceRuleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CategoryPriceRuleScalarWhereInput | CategoryPriceRuleScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutPriceRulesInput = {
    create?: XOR<CategoryCreateWithoutPriceRulesInput, CategoryUncheckedCreateWithoutPriceRulesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPriceRulesInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryUpdateOneRequiredWithoutPriceRulesNestedInput = {
    create?: XOR<CategoryCreateWithoutPriceRulesInput, CategoryUncheckedCreateWithoutPriceRulesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPriceRulesInput
    upsert?: CategoryUpsertWithoutPriceRulesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutPriceRulesInput, CategoryUpdateWithoutPriceRulesInput>, CategoryUncheckedUpdateWithoutPriceRulesInput>
  }

  export type ProductCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<StoreCreateWithoutInventoryItemsInput, StoreUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutInventoryItemsInput
    connect?: StoreWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryItemsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type WarehouseBinCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<WarehouseBinCreateWithoutInventoryItemsInput, WarehouseBinUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: WarehouseBinCreateOrConnectWithoutInventoryItemsInput
    connect?: WarehouseBinWhereUniqueInput
  }

  export type SaleItemCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<SaleItemCreateWithoutInventoryItemInput, SaleItemUncheckedCreateWithoutInventoryItemInput> | SaleItemCreateWithoutInventoryItemInput[] | SaleItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutInventoryItemInput | SaleItemCreateOrConnectWithoutInventoryItemInput[]
    createMany?: SaleItemCreateManyInventoryItemInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type AuditItemCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<AuditItemCreateWithoutInventoryItemInput, AuditItemUncheckedCreateWithoutInventoryItemInput> | AuditItemCreateWithoutInventoryItemInput[] | AuditItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutInventoryItemInput | AuditItemCreateOrConnectWithoutInventoryItemInput[]
    createMany?: AuditItemCreateManyInventoryItemInputEnvelope
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
  }

  export type SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<SaleItemCreateWithoutInventoryItemInput, SaleItemUncheckedCreateWithoutInventoryItemInput> | SaleItemCreateWithoutInventoryItemInput[] | SaleItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutInventoryItemInput | SaleItemCreateOrConnectWithoutInventoryItemInput[]
    createMany?: SaleItemCreateManyInventoryItemInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<AuditItemCreateWithoutInventoryItemInput, AuditItemUncheckedCreateWithoutInventoryItemInput> | AuditItemCreateWithoutInventoryItemInput[] | AuditItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutInventoryItemInput | AuditItemCreateOrConnectWithoutInventoryItemInput[]
    createMany?: AuditItemCreateManyInventoryItemInputEnvelope
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
  }

  export type EnumInventoryStatusFieldUpdateOperationsInput = {
    set?: $Enums.InventoryStatus
  }

  export type NullableEnumInventoryMethodFieldUpdateOperationsInput = {
    set?: $Enums.InventoryMethod | null
  }

  export type ProductUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryItemsInput
    upsert?: ProductUpsertWithoutInventoryItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInventoryItemsInput, ProductUpdateWithoutInventoryItemsInput>, ProductUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type StoreUpdateOneWithoutInventoryItemsNestedInput = {
    create?: XOR<StoreCreateWithoutInventoryItemsInput, StoreUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutInventoryItemsInput
    upsert?: StoreUpsertWithoutInventoryItemsInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutInventoryItemsInput, StoreUpdateWithoutInventoryItemsInput>, StoreUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type WarehouseUpdateOneWithoutInventoryItemsNestedInput = {
    create?: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryItemsInput
    upsert?: WarehouseUpsertWithoutInventoryItemsInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutInventoryItemsInput, WarehouseUpdateWithoutInventoryItemsInput>, WarehouseUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type WarehouseBinUpdateOneWithoutInventoryItemsNestedInput = {
    create?: XOR<WarehouseBinCreateWithoutInventoryItemsInput, WarehouseBinUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: WarehouseBinCreateOrConnectWithoutInventoryItemsInput
    upsert?: WarehouseBinUpsertWithoutInventoryItemsInput
    disconnect?: WarehouseBinWhereInput | boolean
    delete?: WarehouseBinWhereInput | boolean
    connect?: WarehouseBinWhereUniqueInput
    update?: XOR<XOR<WarehouseBinUpdateToOneWithWhereWithoutInventoryItemsInput, WarehouseBinUpdateWithoutInventoryItemsInput>, WarehouseBinUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type SaleItemUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<SaleItemCreateWithoutInventoryItemInput, SaleItemUncheckedCreateWithoutInventoryItemInput> | SaleItemCreateWithoutInventoryItemInput[] | SaleItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutInventoryItemInput | SaleItemCreateOrConnectWithoutInventoryItemInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutInventoryItemInput | SaleItemUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: SaleItemCreateManyInventoryItemInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutInventoryItemInput | SaleItemUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutInventoryItemInput | SaleItemUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type AuditItemUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<AuditItemCreateWithoutInventoryItemInput, AuditItemUncheckedCreateWithoutInventoryItemInput> | AuditItemCreateWithoutInventoryItemInput[] | AuditItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutInventoryItemInput | AuditItemCreateOrConnectWithoutInventoryItemInput[]
    upsert?: AuditItemUpsertWithWhereUniqueWithoutInventoryItemInput | AuditItemUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: AuditItemCreateManyInventoryItemInputEnvelope
    set?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    disconnect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    delete?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    update?: AuditItemUpdateWithWhereUniqueWithoutInventoryItemInput | AuditItemUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: AuditItemUpdateManyWithWhereWithoutInventoryItemInput | AuditItemUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
  }

  export type SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<SaleItemCreateWithoutInventoryItemInput, SaleItemUncheckedCreateWithoutInventoryItemInput> | SaleItemCreateWithoutInventoryItemInput[] | SaleItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutInventoryItemInput | SaleItemCreateOrConnectWithoutInventoryItemInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutInventoryItemInput | SaleItemUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: SaleItemCreateManyInventoryItemInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutInventoryItemInput | SaleItemUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutInventoryItemInput | SaleItemUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<AuditItemCreateWithoutInventoryItemInput, AuditItemUncheckedCreateWithoutInventoryItemInput> | AuditItemCreateWithoutInventoryItemInput[] | AuditItemUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutInventoryItemInput | AuditItemCreateOrConnectWithoutInventoryItemInput[]
    upsert?: AuditItemUpsertWithWhereUniqueWithoutInventoryItemInput | AuditItemUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: AuditItemCreateManyInventoryItemInputEnvelope
    set?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    disconnect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    delete?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    update?: AuditItemUpdateWithWhereUniqueWithoutInventoryItemInput | AuditItemUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: AuditItemUpdateManyWithWhereWithoutInventoryItemInput | AuditItemUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
  }

  export type StoreCreateNestedOneWithoutSalesInput = {
    create?: XOR<StoreCreateWithoutSalesInput, StoreUncheckedCreateWithoutSalesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSalesInput
    connect?: StoreWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutSalesInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedSalesInput = {
    create?: XOR<UserCreateWithoutCreatedSalesInput, UserUncheckedCreateWithoutCreatedSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSalesInput
    connect?: UserWhereUniqueInput
  }

  export type SaleItemCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutSaleInput = {
    create?: XOR<PaymentCreateWithoutSaleInput, PaymentUncheckedCreateWithoutSaleInput> | PaymentCreateWithoutSaleInput[] | PaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSaleInput | PaymentCreateOrConnectWithoutSaleInput[]
    createMany?: PaymentCreateManySaleInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReturnCreateNestedManyWithoutSaleInput = {
    create?: XOR<ReturnCreateWithoutSaleInput, ReturnUncheckedCreateWithoutSaleInput> | ReturnCreateWithoutSaleInput[] | ReturnUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutSaleInput | ReturnCreateOrConnectWithoutSaleInput[]
    createMany?: ReturnCreateManySaleInputEnvelope
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
  }

  export type SaleItemUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<PaymentCreateWithoutSaleInput, PaymentUncheckedCreateWithoutSaleInput> | PaymentCreateWithoutSaleInput[] | PaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSaleInput | PaymentCreateOrConnectWithoutSaleInput[]
    createMany?: PaymentCreateManySaleInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReturnUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<ReturnCreateWithoutSaleInput, ReturnUncheckedCreateWithoutSaleInput> | ReturnCreateWithoutSaleInput[] | ReturnUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutSaleInput | ReturnCreateOrConnectWithoutSaleInput[]
    createMany?: ReturnCreateManySaleInputEnvelope
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type StoreUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<StoreCreateWithoutSalesInput, StoreUncheckedCreateWithoutSalesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSalesInput
    upsert?: StoreUpsertWithoutSalesInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutSalesInput, StoreUpdateWithoutSalesInput>, StoreUncheckedUpdateWithoutSalesInput>
  }

  export type CustomerUpdateOneWithoutSalesNestedInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    upsert?: CustomerUpsertWithoutSalesInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSalesInput, CustomerUpdateWithoutSalesInput>, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedSalesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedSalesInput, UserUncheckedCreateWithoutCreatedSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSalesInput
    upsert?: UserUpsertWithoutCreatedSalesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedSalesInput, UserUpdateWithoutCreatedSalesInput>, UserUncheckedUpdateWithoutCreatedSalesInput>
  }

  export type SaleItemUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutSaleInput | SaleItemUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutSaleInput | SaleItemUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutSaleInput | SaleItemUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutSaleNestedInput = {
    create?: XOR<PaymentCreateWithoutSaleInput, PaymentUncheckedCreateWithoutSaleInput> | PaymentCreateWithoutSaleInput[] | PaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSaleInput | PaymentCreateOrConnectWithoutSaleInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSaleInput | PaymentUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: PaymentCreateManySaleInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSaleInput | PaymentUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSaleInput | PaymentUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReturnUpdateManyWithoutSaleNestedInput = {
    create?: XOR<ReturnCreateWithoutSaleInput, ReturnUncheckedCreateWithoutSaleInput> | ReturnCreateWithoutSaleInput[] | ReturnUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutSaleInput | ReturnCreateOrConnectWithoutSaleInput[]
    upsert?: ReturnUpsertWithWhereUniqueWithoutSaleInput | ReturnUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: ReturnCreateManySaleInputEnvelope
    set?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    disconnect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    delete?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    update?: ReturnUpdateWithWhereUniqueWithoutSaleInput | ReturnUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: ReturnUpdateManyWithWhereWithoutSaleInput | ReturnUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: ReturnScalarWhereInput | ReturnScalarWhereInput[]
  }

  export type SaleItemUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutSaleInput | SaleItemUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutSaleInput | SaleItemUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutSaleInput | SaleItemUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<PaymentCreateWithoutSaleInput, PaymentUncheckedCreateWithoutSaleInput> | PaymentCreateWithoutSaleInput[] | PaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSaleInput | PaymentCreateOrConnectWithoutSaleInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSaleInput | PaymentUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: PaymentCreateManySaleInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSaleInput | PaymentUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSaleInput | PaymentUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReturnUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<ReturnCreateWithoutSaleInput, ReturnUncheckedCreateWithoutSaleInput> | ReturnCreateWithoutSaleInput[] | ReturnUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutSaleInput | ReturnCreateOrConnectWithoutSaleInput[]
    upsert?: ReturnUpsertWithWhereUniqueWithoutSaleInput | ReturnUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: ReturnCreateManySaleInputEnvelope
    set?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    disconnect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    delete?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    update?: ReturnUpdateWithWhereUniqueWithoutSaleInput | ReturnUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: ReturnUpdateManyWithWhereWithoutSaleInput | ReturnUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: ReturnScalarWhereInput | ReturnScalarWhereInput[]
  }

  export type SaleCreateNestedOneWithoutItemsInput = {
    create?: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutItemsInput
    connect?: SaleWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSaleItemsInput = {
    create?: XOR<ProductCreateWithoutSaleItemsInput, ProductUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSaleItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type InventoryItemCreateNestedOneWithoutSaleItemsInput = {
    create?: XOR<InventoryItemCreateWithoutSaleItemsInput, InventoryItemUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutSaleItemsInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type ReturnItemCreateNestedManyWithoutSaleItemInput = {
    create?: XOR<ReturnItemCreateWithoutSaleItemInput, ReturnItemUncheckedCreateWithoutSaleItemInput> | ReturnItemCreateWithoutSaleItemInput[] | ReturnItemUncheckedCreateWithoutSaleItemInput[]
    connectOrCreate?: ReturnItemCreateOrConnectWithoutSaleItemInput | ReturnItemCreateOrConnectWithoutSaleItemInput[]
    createMany?: ReturnItemCreateManySaleItemInputEnvelope
    connect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
  }

  export type ReturnItemUncheckedCreateNestedManyWithoutSaleItemInput = {
    create?: XOR<ReturnItemCreateWithoutSaleItemInput, ReturnItemUncheckedCreateWithoutSaleItemInput> | ReturnItemCreateWithoutSaleItemInput[] | ReturnItemUncheckedCreateWithoutSaleItemInput[]
    connectOrCreate?: ReturnItemCreateOrConnectWithoutSaleItemInput | ReturnItemCreateOrConnectWithoutSaleItemInput[]
    createMany?: ReturnItemCreateManySaleItemInputEnvelope
    connect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
  }

  export type SaleUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutItemsInput
    upsert?: SaleUpsertWithoutItemsInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutItemsInput, SaleUpdateWithoutItemsInput>, SaleUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutSaleItemsNestedInput = {
    create?: XOR<ProductCreateWithoutSaleItemsInput, ProductUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSaleItemsInput
    upsert?: ProductUpsertWithoutSaleItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSaleItemsInput, ProductUpdateWithoutSaleItemsInput>, ProductUncheckedUpdateWithoutSaleItemsInput>
  }

  export type InventoryItemUpdateOneRequiredWithoutSaleItemsNestedInput = {
    create?: XOR<InventoryItemCreateWithoutSaleItemsInput, InventoryItemUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutSaleItemsInput
    upsert?: InventoryItemUpsertWithoutSaleItemsInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutSaleItemsInput, InventoryItemUpdateWithoutSaleItemsInput>, InventoryItemUncheckedUpdateWithoutSaleItemsInput>
  }

  export type ReturnItemUpdateManyWithoutSaleItemNestedInput = {
    create?: XOR<ReturnItemCreateWithoutSaleItemInput, ReturnItemUncheckedCreateWithoutSaleItemInput> | ReturnItemCreateWithoutSaleItemInput[] | ReturnItemUncheckedCreateWithoutSaleItemInput[]
    connectOrCreate?: ReturnItemCreateOrConnectWithoutSaleItemInput | ReturnItemCreateOrConnectWithoutSaleItemInput[]
    upsert?: ReturnItemUpsertWithWhereUniqueWithoutSaleItemInput | ReturnItemUpsertWithWhereUniqueWithoutSaleItemInput[]
    createMany?: ReturnItemCreateManySaleItemInputEnvelope
    set?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    disconnect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    delete?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    connect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    update?: ReturnItemUpdateWithWhereUniqueWithoutSaleItemInput | ReturnItemUpdateWithWhereUniqueWithoutSaleItemInput[]
    updateMany?: ReturnItemUpdateManyWithWhereWithoutSaleItemInput | ReturnItemUpdateManyWithWhereWithoutSaleItemInput[]
    deleteMany?: ReturnItemScalarWhereInput | ReturnItemScalarWhereInput[]
  }

  export type ReturnItemUncheckedUpdateManyWithoutSaleItemNestedInput = {
    create?: XOR<ReturnItemCreateWithoutSaleItemInput, ReturnItemUncheckedCreateWithoutSaleItemInput> | ReturnItemCreateWithoutSaleItemInput[] | ReturnItemUncheckedCreateWithoutSaleItemInput[]
    connectOrCreate?: ReturnItemCreateOrConnectWithoutSaleItemInput | ReturnItemCreateOrConnectWithoutSaleItemInput[]
    upsert?: ReturnItemUpsertWithWhereUniqueWithoutSaleItemInput | ReturnItemUpsertWithWhereUniqueWithoutSaleItemInput[]
    createMany?: ReturnItemCreateManySaleItemInputEnvelope
    set?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    disconnect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    delete?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    connect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    update?: ReturnItemUpdateWithWhereUniqueWithoutSaleItemInput | ReturnItemUpdateWithWhereUniqueWithoutSaleItemInput[]
    updateMany?: ReturnItemUpdateManyWithWhereWithoutSaleItemInput | ReturnItemUpdateManyWithWhereWithoutSaleItemInput[]
    deleteMany?: ReturnItemScalarWhereInput | ReturnItemScalarWhereInput[]
  }

  export type SaleCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SaleCreateWithoutPaymentsInput, SaleUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutPaymentsInput
    connect?: SaleWhereUniqueInput
  }

  export type SaleUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<SaleCreateWithoutPaymentsInput, SaleUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutPaymentsInput
    upsert?: SaleUpsertWithoutPaymentsInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutPaymentsInput, SaleUpdateWithoutPaymentsInput>, SaleUncheckedUpdateWithoutPaymentsInput>
  }

  export type SaleCreateNestedOneWithoutReturnsInput = {
    create?: XOR<SaleCreateWithoutReturnsInput, SaleUncheckedCreateWithoutReturnsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutReturnsInput
    connect?: SaleWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutReturnsInput = {
    create?: XOR<StoreCreateWithoutReturnsInput, StoreUncheckedCreateWithoutReturnsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutReturnsInput
    connect?: StoreWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutReturnsInput = {
    create?: XOR<CustomerCreateWithoutReturnsInput, CustomerUncheckedCreateWithoutReturnsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReturnsInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProcessedReturnsInput = {
    create?: XOR<UserCreateWithoutProcessedReturnsInput, UserUncheckedCreateWithoutProcessedReturnsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessedReturnsInput
    connect?: UserWhereUniqueInput
  }

  export type ReturnItemCreateNestedManyWithoutReturnInput = {
    create?: XOR<ReturnItemCreateWithoutReturnInput, ReturnItemUncheckedCreateWithoutReturnInput> | ReturnItemCreateWithoutReturnInput[] | ReturnItemUncheckedCreateWithoutReturnInput[]
    connectOrCreate?: ReturnItemCreateOrConnectWithoutReturnInput | ReturnItemCreateOrConnectWithoutReturnInput[]
    createMany?: ReturnItemCreateManyReturnInputEnvelope
    connect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
  }

  export type QualityControlCreateNestedManyWithoutReturnInput = {
    create?: XOR<QualityControlCreateWithoutReturnInput, QualityControlUncheckedCreateWithoutReturnInput> | QualityControlCreateWithoutReturnInput[] | QualityControlUncheckedCreateWithoutReturnInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutReturnInput | QualityControlCreateOrConnectWithoutReturnInput[]
    createMany?: QualityControlCreateManyReturnInputEnvelope
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
  }

  export type ReturnItemUncheckedCreateNestedManyWithoutReturnInput = {
    create?: XOR<ReturnItemCreateWithoutReturnInput, ReturnItemUncheckedCreateWithoutReturnInput> | ReturnItemCreateWithoutReturnInput[] | ReturnItemUncheckedCreateWithoutReturnInput[]
    connectOrCreate?: ReturnItemCreateOrConnectWithoutReturnInput | ReturnItemCreateOrConnectWithoutReturnInput[]
    createMany?: ReturnItemCreateManyReturnInputEnvelope
    connect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
  }

  export type QualityControlUncheckedCreateNestedManyWithoutReturnInput = {
    create?: XOR<QualityControlCreateWithoutReturnInput, QualityControlUncheckedCreateWithoutReturnInput> | QualityControlCreateWithoutReturnInput[] | QualityControlUncheckedCreateWithoutReturnInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutReturnInput | QualityControlCreateOrConnectWithoutReturnInput[]
    createMany?: QualityControlCreateManyReturnInputEnvelope
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
  }

  export type EnumReturnStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReturnStatus
  }

  export type NullableEnumRefundMethodFieldUpdateOperationsInput = {
    set?: $Enums.RefundMethod | null
  }

  export type EnumRefundStatusFieldUpdateOperationsInput = {
    set?: $Enums.RefundStatus
  }

  export type SaleUpdateOneWithoutReturnsNestedInput = {
    create?: XOR<SaleCreateWithoutReturnsInput, SaleUncheckedCreateWithoutReturnsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutReturnsInput
    upsert?: SaleUpsertWithoutReturnsInput
    disconnect?: SaleWhereInput | boolean
    delete?: SaleWhereInput | boolean
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutReturnsInput, SaleUpdateWithoutReturnsInput>, SaleUncheckedUpdateWithoutReturnsInput>
  }

  export type StoreUpdateOneRequiredWithoutReturnsNestedInput = {
    create?: XOR<StoreCreateWithoutReturnsInput, StoreUncheckedCreateWithoutReturnsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutReturnsInput
    upsert?: StoreUpsertWithoutReturnsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutReturnsInput, StoreUpdateWithoutReturnsInput>, StoreUncheckedUpdateWithoutReturnsInput>
  }

  export type CustomerUpdateOneWithoutReturnsNestedInput = {
    create?: XOR<CustomerCreateWithoutReturnsInput, CustomerUncheckedCreateWithoutReturnsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReturnsInput
    upsert?: CustomerUpsertWithoutReturnsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutReturnsInput, CustomerUpdateWithoutReturnsInput>, CustomerUncheckedUpdateWithoutReturnsInput>
  }

  export type UserUpdateOneRequiredWithoutProcessedReturnsNestedInput = {
    create?: XOR<UserCreateWithoutProcessedReturnsInput, UserUncheckedCreateWithoutProcessedReturnsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessedReturnsInput
    upsert?: UserUpsertWithoutProcessedReturnsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessedReturnsInput, UserUpdateWithoutProcessedReturnsInput>, UserUncheckedUpdateWithoutProcessedReturnsInput>
  }

  export type ReturnItemUpdateManyWithoutReturnNestedInput = {
    create?: XOR<ReturnItemCreateWithoutReturnInput, ReturnItemUncheckedCreateWithoutReturnInput> | ReturnItemCreateWithoutReturnInput[] | ReturnItemUncheckedCreateWithoutReturnInput[]
    connectOrCreate?: ReturnItemCreateOrConnectWithoutReturnInput | ReturnItemCreateOrConnectWithoutReturnInput[]
    upsert?: ReturnItemUpsertWithWhereUniqueWithoutReturnInput | ReturnItemUpsertWithWhereUniqueWithoutReturnInput[]
    createMany?: ReturnItemCreateManyReturnInputEnvelope
    set?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    disconnect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    delete?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    connect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    update?: ReturnItemUpdateWithWhereUniqueWithoutReturnInput | ReturnItemUpdateWithWhereUniqueWithoutReturnInput[]
    updateMany?: ReturnItemUpdateManyWithWhereWithoutReturnInput | ReturnItemUpdateManyWithWhereWithoutReturnInput[]
    deleteMany?: ReturnItemScalarWhereInput | ReturnItemScalarWhereInput[]
  }

  export type QualityControlUpdateManyWithoutReturnNestedInput = {
    create?: XOR<QualityControlCreateWithoutReturnInput, QualityControlUncheckedCreateWithoutReturnInput> | QualityControlCreateWithoutReturnInput[] | QualityControlUncheckedCreateWithoutReturnInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutReturnInput | QualityControlCreateOrConnectWithoutReturnInput[]
    upsert?: QualityControlUpsertWithWhereUniqueWithoutReturnInput | QualityControlUpsertWithWhereUniqueWithoutReturnInput[]
    createMany?: QualityControlCreateManyReturnInputEnvelope
    set?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    disconnect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    delete?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    update?: QualityControlUpdateWithWhereUniqueWithoutReturnInput | QualityControlUpdateWithWhereUniqueWithoutReturnInput[]
    updateMany?: QualityControlUpdateManyWithWhereWithoutReturnInput | QualityControlUpdateManyWithWhereWithoutReturnInput[]
    deleteMany?: QualityControlScalarWhereInput | QualityControlScalarWhereInput[]
  }

  export type ReturnItemUncheckedUpdateManyWithoutReturnNestedInput = {
    create?: XOR<ReturnItemCreateWithoutReturnInput, ReturnItemUncheckedCreateWithoutReturnInput> | ReturnItemCreateWithoutReturnInput[] | ReturnItemUncheckedCreateWithoutReturnInput[]
    connectOrCreate?: ReturnItemCreateOrConnectWithoutReturnInput | ReturnItemCreateOrConnectWithoutReturnInput[]
    upsert?: ReturnItemUpsertWithWhereUniqueWithoutReturnInput | ReturnItemUpsertWithWhereUniqueWithoutReturnInput[]
    createMany?: ReturnItemCreateManyReturnInputEnvelope
    set?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    disconnect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    delete?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    connect?: ReturnItemWhereUniqueInput | ReturnItemWhereUniqueInput[]
    update?: ReturnItemUpdateWithWhereUniqueWithoutReturnInput | ReturnItemUpdateWithWhereUniqueWithoutReturnInput[]
    updateMany?: ReturnItemUpdateManyWithWhereWithoutReturnInput | ReturnItemUpdateManyWithWhereWithoutReturnInput[]
    deleteMany?: ReturnItemScalarWhereInput | ReturnItemScalarWhereInput[]
  }

  export type QualityControlUncheckedUpdateManyWithoutReturnNestedInput = {
    create?: XOR<QualityControlCreateWithoutReturnInput, QualityControlUncheckedCreateWithoutReturnInput> | QualityControlCreateWithoutReturnInput[] | QualityControlUncheckedCreateWithoutReturnInput[]
    connectOrCreate?: QualityControlCreateOrConnectWithoutReturnInput | QualityControlCreateOrConnectWithoutReturnInput[]
    upsert?: QualityControlUpsertWithWhereUniqueWithoutReturnInput | QualityControlUpsertWithWhereUniqueWithoutReturnInput[]
    createMany?: QualityControlCreateManyReturnInputEnvelope
    set?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    disconnect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    delete?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    connect?: QualityControlWhereUniqueInput | QualityControlWhereUniqueInput[]
    update?: QualityControlUpdateWithWhereUniqueWithoutReturnInput | QualityControlUpdateWithWhereUniqueWithoutReturnInput[]
    updateMany?: QualityControlUpdateManyWithWhereWithoutReturnInput | QualityControlUpdateManyWithWhereWithoutReturnInput[]
    deleteMany?: QualityControlScalarWhereInput | QualityControlScalarWhereInput[]
  }

  export type ReturnCreateNestedOneWithoutItemsInput = {
    create?: XOR<ReturnCreateWithoutItemsInput, ReturnUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ReturnCreateOrConnectWithoutItemsInput
    connect?: ReturnWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutReturnItemsInput = {
    create?: XOR<ProductCreateWithoutReturnItemsInput, ProductUncheckedCreateWithoutReturnItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReturnItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type SaleItemCreateNestedOneWithoutReturnItemsInput = {
    create?: XOR<SaleItemCreateWithoutReturnItemsInput, SaleItemUncheckedCreateWithoutReturnItemsInput>
    connectOrCreate?: SaleItemCreateOrConnectWithoutReturnItemsInput
    connect?: SaleItemWhereUniqueInput
  }

  export type EnumReturnReasonFieldUpdateOperationsInput = {
    set?: $Enums.ReturnReason
  }

  export type EnumItemConditionFieldUpdateOperationsInput = {
    set?: $Enums.ItemCondition
  }

  export type ReturnUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ReturnCreateWithoutItemsInput, ReturnUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ReturnCreateOrConnectWithoutItemsInput
    upsert?: ReturnUpsertWithoutItemsInput
    connect?: ReturnWhereUniqueInput
    update?: XOR<XOR<ReturnUpdateToOneWithWhereWithoutItemsInput, ReturnUpdateWithoutItemsInput>, ReturnUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutReturnItemsNestedInput = {
    create?: XOR<ProductCreateWithoutReturnItemsInput, ProductUncheckedCreateWithoutReturnItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReturnItemsInput
    upsert?: ProductUpsertWithoutReturnItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutReturnItemsInput, ProductUpdateWithoutReturnItemsInput>, ProductUncheckedUpdateWithoutReturnItemsInput>
  }

  export type SaleItemUpdateOneWithoutReturnItemsNestedInput = {
    create?: XOR<SaleItemCreateWithoutReturnItemsInput, SaleItemUncheckedCreateWithoutReturnItemsInput>
    connectOrCreate?: SaleItemCreateOrConnectWithoutReturnItemsInput
    upsert?: SaleItemUpsertWithoutReturnItemsInput
    disconnect?: SaleItemWhereInput | boolean
    delete?: SaleItemWhereInput | boolean
    connect?: SaleItemWhereUniqueInput
    update?: XOR<XOR<SaleItemUpdateToOneWithWhereWithoutReturnItemsInput, SaleItemUpdateWithoutReturnItemsInput>, SaleItemUncheckedUpdateWithoutReturnItemsInput>
  }

  export type WarehouseCreateNestedOneWithoutQualityControlsInput = {
    create?: XOR<WarehouseCreateWithoutQualityControlsInput, WarehouseUncheckedCreateWithoutQualityControlsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutQualityControlsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedOneWithoutQualityControlsInput = {
    create?: XOR<PurchaseOrderCreateWithoutQualityControlsInput, PurchaseOrderUncheckedCreateWithoutQualityControlsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutQualityControlsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type ReturnCreateNestedOneWithoutQualityControlsInput = {
    create?: XOR<ReturnCreateWithoutQualityControlsInput, ReturnUncheckedCreateWithoutQualityControlsInput>
    connectOrCreate?: ReturnCreateOrConnectWithoutQualityControlsInput
    connect?: ReturnWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInspectedQCsInput = {
    create?: XOR<UserCreateWithoutInspectedQCsInput, UserUncheckedCreateWithoutInspectedQCsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInspectedQCsInput
    connect?: UserWhereUniqueInput
  }

  export type QualityControlItemCreateNestedManyWithoutQualityControlInput = {
    create?: XOR<QualityControlItemCreateWithoutQualityControlInput, QualityControlItemUncheckedCreateWithoutQualityControlInput> | QualityControlItemCreateWithoutQualityControlInput[] | QualityControlItemUncheckedCreateWithoutQualityControlInput[]
    connectOrCreate?: QualityControlItemCreateOrConnectWithoutQualityControlInput | QualityControlItemCreateOrConnectWithoutQualityControlInput[]
    createMany?: QualityControlItemCreateManyQualityControlInputEnvelope
    connect?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
  }

  export type QualityControlItemUncheckedCreateNestedManyWithoutQualityControlInput = {
    create?: XOR<QualityControlItemCreateWithoutQualityControlInput, QualityControlItemUncheckedCreateWithoutQualityControlInput> | QualityControlItemCreateWithoutQualityControlInput[] | QualityControlItemUncheckedCreateWithoutQualityControlInput[]
    connectOrCreate?: QualityControlItemCreateOrConnectWithoutQualityControlInput | QualityControlItemCreateOrConnectWithoutQualityControlInput[]
    createMany?: QualityControlItemCreateManyQualityControlInputEnvelope
    connect?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
  }

  export type EnumQCTypeFieldUpdateOperationsInput = {
    set?: $Enums.QCType
  }

  export type EnumQCStatusFieldUpdateOperationsInput = {
    set?: $Enums.QCStatus
  }

  export type WarehouseUpdateOneRequiredWithoutQualityControlsNestedInput = {
    create?: XOR<WarehouseCreateWithoutQualityControlsInput, WarehouseUncheckedCreateWithoutQualityControlsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutQualityControlsInput
    upsert?: WarehouseUpsertWithoutQualityControlsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutQualityControlsInput, WarehouseUpdateWithoutQualityControlsInput>, WarehouseUncheckedUpdateWithoutQualityControlsInput>
  }

  export type PurchaseOrderUpdateOneWithoutQualityControlsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutQualityControlsInput, PurchaseOrderUncheckedCreateWithoutQualityControlsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutQualityControlsInput
    upsert?: PurchaseOrderUpsertWithoutQualityControlsInput
    disconnect?: PurchaseOrderWhereInput | boolean
    delete?: PurchaseOrderWhereInput | boolean
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutQualityControlsInput, PurchaseOrderUpdateWithoutQualityControlsInput>, PurchaseOrderUncheckedUpdateWithoutQualityControlsInput>
  }

  export type ReturnUpdateOneWithoutQualityControlsNestedInput = {
    create?: XOR<ReturnCreateWithoutQualityControlsInput, ReturnUncheckedCreateWithoutQualityControlsInput>
    connectOrCreate?: ReturnCreateOrConnectWithoutQualityControlsInput
    upsert?: ReturnUpsertWithoutQualityControlsInput
    disconnect?: ReturnWhereInput | boolean
    delete?: ReturnWhereInput | boolean
    connect?: ReturnWhereUniqueInput
    update?: XOR<XOR<ReturnUpdateToOneWithWhereWithoutQualityControlsInput, ReturnUpdateWithoutQualityControlsInput>, ReturnUncheckedUpdateWithoutQualityControlsInput>
  }

  export type UserUpdateOneRequiredWithoutInspectedQCsNestedInput = {
    create?: XOR<UserCreateWithoutInspectedQCsInput, UserUncheckedCreateWithoutInspectedQCsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInspectedQCsInput
    upsert?: UserUpsertWithoutInspectedQCsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInspectedQCsInput, UserUpdateWithoutInspectedQCsInput>, UserUncheckedUpdateWithoutInspectedQCsInput>
  }

  export type QualityControlItemUpdateManyWithoutQualityControlNestedInput = {
    create?: XOR<QualityControlItemCreateWithoutQualityControlInput, QualityControlItemUncheckedCreateWithoutQualityControlInput> | QualityControlItemCreateWithoutQualityControlInput[] | QualityControlItemUncheckedCreateWithoutQualityControlInput[]
    connectOrCreate?: QualityControlItemCreateOrConnectWithoutQualityControlInput | QualityControlItemCreateOrConnectWithoutQualityControlInput[]
    upsert?: QualityControlItemUpsertWithWhereUniqueWithoutQualityControlInput | QualityControlItemUpsertWithWhereUniqueWithoutQualityControlInput[]
    createMany?: QualityControlItemCreateManyQualityControlInputEnvelope
    set?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    disconnect?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    delete?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    connect?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    update?: QualityControlItemUpdateWithWhereUniqueWithoutQualityControlInput | QualityControlItemUpdateWithWhereUniqueWithoutQualityControlInput[]
    updateMany?: QualityControlItemUpdateManyWithWhereWithoutQualityControlInput | QualityControlItemUpdateManyWithWhereWithoutQualityControlInput[]
    deleteMany?: QualityControlItemScalarWhereInput | QualityControlItemScalarWhereInput[]
  }

  export type QualityControlItemUncheckedUpdateManyWithoutQualityControlNestedInput = {
    create?: XOR<QualityControlItemCreateWithoutQualityControlInput, QualityControlItemUncheckedCreateWithoutQualityControlInput> | QualityControlItemCreateWithoutQualityControlInput[] | QualityControlItemUncheckedCreateWithoutQualityControlInput[]
    connectOrCreate?: QualityControlItemCreateOrConnectWithoutQualityControlInput | QualityControlItemCreateOrConnectWithoutQualityControlInput[]
    upsert?: QualityControlItemUpsertWithWhereUniqueWithoutQualityControlInput | QualityControlItemUpsertWithWhereUniqueWithoutQualityControlInput[]
    createMany?: QualityControlItemCreateManyQualityControlInputEnvelope
    set?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    disconnect?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    delete?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    connect?: QualityControlItemWhereUniqueInput | QualityControlItemWhereUniqueInput[]
    update?: QualityControlItemUpdateWithWhereUniqueWithoutQualityControlInput | QualityControlItemUpdateWithWhereUniqueWithoutQualityControlInput[]
    updateMany?: QualityControlItemUpdateManyWithWhereWithoutQualityControlInput | QualityControlItemUpdateManyWithWhereWithoutQualityControlInput[]
    deleteMany?: QualityControlItemScalarWhereInput | QualityControlItemScalarWhereInput[]
  }

  export type QualityControlCreateNestedOneWithoutItemsInput = {
    create?: XOR<QualityControlCreateWithoutItemsInput, QualityControlUncheckedCreateWithoutItemsInput>
    connectOrCreate?: QualityControlCreateOrConnectWithoutItemsInput
    connect?: QualityControlWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutQualityControlItemsInput = {
    create?: XOR<ProductCreateWithoutQualityControlItemsInput, ProductUncheckedCreateWithoutQualityControlItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutQualityControlItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type EnumQCItemStatusFieldUpdateOperationsInput = {
    set?: $Enums.QCItemStatus
  }

  export type NullableEnumQCActionFieldUpdateOperationsInput = {
    set?: $Enums.QCAction | null
  }

  export type QualityControlUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<QualityControlCreateWithoutItemsInput, QualityControlUncheckedCreateWithoutItemsInput>
    connectOrCreate?: QualityControlCreateOrConnectWithoutItemsInput
    upsert?: QualityControlUpsertWithoutItemsInput
    connect?: QualityControlWhereUniqueInput
    update?: XOR<XOR<QualityControlUpdateToOneWithWhereWithoutItemsInput, QualityControlUpdateWithoutItemsInput>, QualityControlUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutQualityControlItemsNestedInput = {
    create?: XOR<ProductCreateWithoutQualityControlItemsInput, ProductUncheckedCreateWithoutQualityControlItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutQualityControlItemsInput
    upsert?: ProductUpsertWithoutQualityControlItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutQualityControlItemsInput, ProductUpdateWithoutQualityControlItemsInput>, ProductUncheckedUpdateWithoutQualityControlItemsInput>
  }

  export type WarehouseCreateNestedOneWithoutTransfersFromInput = {
    create?: XOR<WarehouseCreateWithoutTransfersFromInput, WarehouseUncheckedCreateWithoutTransfersFromInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutTransfersFromInput
    connect?: WarehouseWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutTransfersFromInput = {
    create?: XOR<StoreCreateWithoutTransfersFromInput, StoreUncheckedCreateWithoutTransfersFromInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTransfersFromInput
    connect?: StoreWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutTransfersToInput = {
    create?: XOR<WarehouseCreateWithoutTransfersToInput, WarehouseUncheckedCreateWithoutTransfersToInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutTransfersToInput
    connect?: WarehouseWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutTransfersToInput = {
    create?: XOR<StoreCreateWithoutTransfersToInput, StoreUncheckedCreateWithoutTransfersToInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTransfersToInput
    connect?: StoreWhereUniqueInput
  }

  export type TransferItemCreateNestedManyWithoutTransferInput = {
    create?: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput> | TransferItemCreateWithoutTransferInput[] | TransferItemUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutTransferInput | TransferItemCreateOrConnectWithoutTransferInput[]
    createMany?: TransferItemCreateManyTransferInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type TransferDocumentCreateNestedManyWithoutTransferInput = {
    create?: XOR<TransferDocumentCreateWithoutTransferInput, TransferDocumentUncheckedCreateWithoutTransferInput> | TransferDocumentCreateWithoutTransferInput[] | TransferDocumentUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferDocumentCreateOrConnectWithoutTransferInput | TransferDocumentCreateOrConnectWithoutTransferInput[]
    createMany?: TransferDocumentCreateManyTransferInputEnvelope
    connect?: TransferDocumentWhereUniqueInput | TransferDocumentWhereUniqueInput[]
  }

  export type TransferItemUncheckedCreateNestedManyWithoutTransferInput = {
    create?: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput> | TransferItemCreateWithoutTransferInput[] | TransferItemUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutTransferInput | TransferItemCreateOrConnectWithoutTransferInput[]
    createMany?: TransferItemCreateManyTransferInputEnvelope
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
  }

  export type TransferDocumentUncheckedCreateNestedManyWithoutTransferInput = {
    create?: XOR<TransferDocumentCreateWithoutTransferInput, TransferDocumentUncheckedCreateWithoutTransferInput> | TransferDocumentCreateWithoutTransferInput[] | TransferDocumentUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferDocumentCreateOrConnectWithoutTransferInput | TransferDocumentCreateOrConnectWithoutTransferInput[]
    createMany?: TransferDocumentCreateManyTransferInputEnvelope
    connect?: TransferDocumentWhereUniqueInput | TransferDocumentWhereUniqueInput[]
  }

  export type EnumTransferStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransferStatus
  }

  export type EnumTransferTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransferType
  }

  export type EnumTransferPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TransferPriority
  }

  export type WarehouseUpdateOneWithoutTransfersFromNestedInput = {
    create?: XOR<WarehouseCreateWithoutTransfersFromInput, WarehouseUncheckedCreateWithoutTransfersFromInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutTransfersFromInput
    upsert?: WarehouseUpsertWithoutTransfersFromInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutTransfersFromInput, WarehouseUpdateWithoutTransfersFromInput>, WarehouseUncheckedUpdateWithoutTransfersFromInput>
  }

  export type StoreUpdateOneWithoutTransfersFromNestedInput = {
    create?: XOR<StoreCreateWithoutTransfersFromInput, StoreUncheckedCreateWithoutTransfersFromInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTransfersFromInput
    upsert?: StoreUpsertWithoutTransfersFromInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutTransfersFromInput, StoreUpdateWithoutTransfersFromInput>, StoreUncheckedUpdateWithoutTransfersFromInput>
  }

  export type WarehouseUpdateOneWithoutTransfersToNestedInput = {
    create?: XOR<WarehouseCreateWithoutTransfersToInput, WarehouseUncheckedCreateWithoutTransfersToInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutTransfersToInput
    upsert?: WarehouseUpsertWithoutTransfersToInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutTransfersToInput, WarehouseUpdateWithoutTransfersToInput>, WarehouseUncheckedUpdateWithoutTransfersToInput>
  }

  export type StoreUpdateOneWithoutTransfersToNestedInput = {
    create?: XOR<StoreCreateWithoutTransfersToInput, StoreUncheckedCreateWithoutTransfersToInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTransfersToInput
    upsert?: StoreUpsertWithoutTransfersToInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutTransfersToInput, StoreUpdateWithoutTransfersToInput>, StoreUncheckedUpdateWithoutTransfersToInput>
  }

  export type TransferItemUpdateManyWithoutTransferNestedInput = {
    create?: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput> | TransferItemCreateWithoutTransferInput[] | TransferItemUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutTransferInput | TransferItemCreateOrConnectWithoutTransferInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutTransferInput | TransferItemUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: TransferItemCreateManyTransferInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutTransferInput | TransferItemUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutTransferInput | TransferItemUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type TransferDocumentUpdateManyWithoutTransferNestedInput = {
    create?: XOR<TransferDocumentCreateWithoutTransferInput, TransferDocumentUncheckedCreateWithoutTransferInput> | TransferDocumentCreateWithoutTransferInput[] | TransferDocumentUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferDocumentCreateOrConnectWithoutTransferInput | TransferDocumentCreateOrConnectWithoutTransferInput[]
    upsert?: TransferDocumentUpsertWithWhereUniqueWithoutTransferInput | TransferDocumentUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: TransferDocumentCreateManyTransferInputEnvelope
    set?: TransferDocumentWhereUniqueInput | TransferDocumentWhereUniqueInput[]
    disconnect?: TransferDocumentWhereUniqueInput | TransferDocumentWhereUniqueInput[]
    delete?: TransferDocumentWhereUniqueInput | TransferDocumentWhereUniqueInput[]
    connect?: TransferDocumentWhereUniqueInput | TransferDocumentWhereUniqueInput[]
    update?: TransferDocumentUpdateWithWhereUniqueWithoutTransferInput | TransferDocumentUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: TransferDocumentUpdateManyWithWhereWithoutTransferInput | TransferDocumentUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: TransferDocumentScalarWhereInput | TransferDocumentScalarWhereInput[]
  }

  export type TransferItemUncheckedUpdateManyWithoutTransferNestedInput = {
    create?: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput> | TransferItemCreateWithoutTransferInput[] | TransferItemUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferItemCreateOrConnectWithoutTransferInput | TransferItemCreateOrConnectWithoutTransferInput[]
    upsert?: TransferItemUpsertWithWhereUniqueWithoutTransferInput | TransferItemUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: TransferItemCreateManyTransferInputEnvelope
    set?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    disconnect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    delete?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    connect?: TransferItemWhereUniqueInput | TransferItemWhereUniqueInput[]
    update?: TransferItemUpdateWithWhereUniqueWithoutTransferInput | TransferItemUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: TransferItemUpdateManyWithWhereWithoutTransferInput | TransferItemUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
  }

  export type TransferDocumentUncheckedUpdateManyWithoutTransferNestedInput = {
    create?: XOR<TransferDocumentCreateWithoutTransferInput, TransferDocumentUncheckedCreateWithoutTransferInput> | TransferDocumentCreateWithoutTransferInput[] | TransferDocumentUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: TransferDocumentCreateOrConnectWithoutTransferInput | TransferDocumentCreateOrConnectWithoutTransferInput[]
    upsert?: TransferDocumentUpsertWithWhereUniqueWithoutTransferInput | TransferDocumentUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: TransferDocumentCreateManyTransferInputEnvelope
    set?: TransferDocumentWhereUniqueInput | TransferDocumentWhereUniqueInput[]
    disconnect?: TransferDocumentWhereUniqueInput | TransferDocumentWhereUniqueInput[]
    delete?: TransferDocumentWhereUniqueInput | TransferDocumentWhereUniqueInput[]
    connect?: TransferDocumentWhereUniqueInput | TransferDocumentWhereUniqueInput[]
    update?: TransferDocumentUpdateWithWhereUniqueWithoutTransferInput | TransferDocumentUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: TransferDocumentUpdateManyWithWhereWithoutTransferInput | TransferDocumentUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: TransferDocumentScalarWhereInput | TransferDocumentScalarWhereInput[]
  }

  export type TransferCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<TransferCreateWithoutDocumentsInput, TransferUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TransferCreateOrConnectWithoutDocumentsInput
    connect?: TransferWhereUniqueInput
  }

  export type TransferUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<TransferCreateWithoutDocumentsInput, TransferUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TransferCreateOrConnectWithoutDocumentsInput
    upsert?: TransferUpsertWithoutDocumentsInput
    connect?: TransferWhereUniqueInput
    update?: XOR<XOR<TransferUpdateToOneWithWhereWithoutDocumentsInput, TransferUpdateWithoutDocumentsInput>, TransferUncheckedUpdateWithoutDocumentsInput>
  }

  export type TransferCreateNestedOneWithoutItemsInput = {
    create?: XOR<TransferCreateWithoutItemsInput, TransferUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransferCreateOrConnectWithoutItemsInput
    connect?: TransferWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutTransferItemsInput = {
    create?: XOR<ProductCreateWithoutTransferItemsInput, ProductUncheckedCreateWithoutTransferItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransferItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type TransferUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TransferCreateWithoutItemsInput, TransferUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransferCreateOrConnectWithoutItemsInput
    upsert?: TransferUpsertWithoutItemsInput
    connect?: TransferWhereUniqueInput
    update?: XOR<XOR<TransferUpdateToOneWithWhereWithoutItemsInput, TransferUpdateWithoutItemsInput>, TransferUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutTransferItemsNestedInput = {
    create?: XOR<ProductCreateWithoutTransferItemsInput, ProductUncheckedCreateWithoutTransferItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTransferItemsInput
    upsert?: ProductUpsertWithoutTransferItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTransferItemsInput, ProductUpdateWithoutTransferItemsInput>, ProductUncheckedUpdateWithoutTransferItemsInput>
  }

  export type SaleCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ReturnCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ReturnCreateWithoutCustomerInput, ReturnUncheckedCreateWithoutCustomerInput> | ReturnCreateWithoutCustomerInput[] | ReturnUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutCustomerInput | ReturnCreateOrConnectWithoutCustomerInput[]
    createMany?: ReturnCreateManyCustomerInputEnvelope
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
  }

  export type AddressCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AddressCreateWithoutCustomerInput, AddressUncheckedCreateWithoutCustomerInput> | AddressCreateWithoutCustomerInput[] | AddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCustomerInput | AddressCreateOrConnectWithoutCustomerInput[]
    createMany?: AddressCreateManyCustomerInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type LoyaltyTransactionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutCustomerInput, LoyaltyTransactionUncheckedCreateWithoutCustomerInput> | LoyaltyTransactionCreateWithoutCustomerInput[] | LoyaltyTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutCustomerInput | LoyaltyTransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: LoyaltyTransactionCreateManyCustomerInputEnvelope
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ReturnUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ReturnCreateWithoutCustomerInput, ReturnUncheckedCreateWithoutCustomerInput> | ReturnCreateWithoutCustomerInput[] | ReturnUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutCustomerInput | ReturnCreateOrConnectWithoutCustomerInput[]
    createMany?: ReturnCreateManyCustomerInputEnvelope
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AddressCreateWithoutCustomerInput, AddressUncheckedCreateWithoutCustomerInput> | AddressCreateWithoutCustomerInput[] | AddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCustomerInput | AddressCreateOrConnectWithoutCustomerInput[]
    createMany?: AddressCreateManyCustomerInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type LoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutCustomerInput, LoyaltyTransactionUncheckedCreateWithoutCustomerInput> | LoyaltyTransactionCreateWithoutCustomerInput[] | LoyaltyTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutCustomerInput | LoyaltyTransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: LoyaltyTransactionCreateManyCustomerInputEnvelope
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
  }

  export type EnumLoyaltyTierFieldUpdateOperationsInput = {
    set?: $Enums.LoyaltyTier
  }

  export type SaleUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCustomerInput | SaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCustomerInput | SaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCustomerInput | SaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ReturnUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ReturnCreateWithoutCustomerInput, ReturnUncheckedCreateWithoutCustomerInput> | ReturnCreateWithoutCustomerInput[] | ReturnUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutCustomerInput | ReturnCreateOrConnectWithoutCustomerInput[]
    upsert?: ReturnUpsertWithWhereUniqueWithoutCustomerInput | ReturnUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ReturnCreateManyCustomerInputEnvelope
    set?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    disconnect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    delete?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    update?: ReturnUpdateWithWhereUniqueWithoutCustomerInput | ReturnUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ReturnUpdateManyWithWhereWithoutCustomerInput | ReturnUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ReturnScalarWhereInput | ReturnScalarWhereInput[]
  }

  export type AddressUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AddressCreateWithoutCustomerInput, AddressUncheckedCreateWithoutCustomerInput> | AddressCreateWithoutCustomerInput[] | AddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCustomerInput | AddressCreateOrConnectWithoutCustomerInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutCustomerInput | AddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AddressCreateManyCustomerInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutCustomerInput | AddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutCustomerInput | AddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type LoyaltyTransactionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutCustomerInput, LoyaltyTransactionUncheckedCreateWithoutCustomerInput> | LoyaltyTransactionCreateWithoutCustomerInput[] | LoyaltyTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutCustomerInput | LoyaltyTransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: LoyaltyTransactionUpsertWithWhereUniqueWithoutCustomerInput | LoyaltyTransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: LoyaltyTransactionCreateManyCustomerInputEnvelope
    set?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    disconnect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    delete?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    update?: LoyaltyTransactionUpdateWithWhereUniqueWithoutCustomerInput | LoyaltyTransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: LoyaltyTransactionUpdateManyWithWhereWithoutCustomerInput | LoyaltyTransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCustomerInput | SaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCustomerInput | SaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCustomerInput | SaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ReturnUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ReturnCreateWithoutCustomerInput, ReturnUncheckedCreateWithoutCustomerInput> | ReturnCreateWithoutCustomerInput[] | ReturnUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReturnCreateOrConnectWithoutCustomerInput | ReturnCreateOrConnectWithoutCustomerInput[]
    upsert?: ReturnUpsertWithWhereUniqueWithoutCustomerInput | ReturnUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ReturnCreateManyCustomerInputEnvelope
    set?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    disconnect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    delete?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    connect?: ReturnWhereUniqueInput | ReturnWhereUniqueInput[]
    update?: ReturnUpdateWithWhereUniqueWithoutCustomerInput | ReturnUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ReturnUpdateManyWithWhereWithoutCustomerInput | ReturnUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ReturnScalarWhereInput | ReturnScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AddressCreateWithoutCustomerInput, AddressUncheckedCreateWithoutCustomerInput> | AddressCreateWithoutCustomerInput[] | AddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCustomerInput | AddressCreateOrConnectWithoutCustomerInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutCustomerInput | AddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AddressCreateManyCustomerInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutCustomerInput | AddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutCustomerInput | AddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type LoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutCustomerInput, LoyaltyTransactionUncheckedCreateWithoutCustomerInput> | LoyaltyTransactionCreateWithoutCustomerInput[] | LoyaltyTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutCustomerInput | LoyaltyTransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: LoyaltyTransactionUpsertWithWhereUniqueWithoutCustomerInput | LoyaltyTransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: LoyaltyTransactionCreateManyCustomerInputEnvelope
    set?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    disconnect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    delete?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    update?: LoyaltyTransactionUpdateWithWhereUniqueWithoutCustomerInput | LoyaltyTransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: LoyaltyTransactionUpdateManyWithWhereWithoutCustomerInput | LoyaltyTransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutAddressesInput = {
    create?: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressesInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressesInput
    upsert?: CustomerUpsertWithoutAddressesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutAddressesInput, CustomerUpdateWithoutAddressesInput>, CustomerUncheckedUpdateWithoutAddressesInput>
  }

  export type LoyaltyProgramTierCreateNestedManyWithoutProgramInput = {
    create?: XOR<LoyaltyProgramTierCreateWithoutProgramInput, LoyaltyProgramTierUncheckedCreateWithoutProgramInput> | LoyaltyProgramTierCreateWithoutProgramInput[] | LoyaltyProgramTierUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyProgramTierCreateOrConnectWithoutProgramInput | LoyaltyProgramTierCreateOrConnectWithoutProgramInput[]
    createMany?: LoyaltyProgramTierCreateManyProgramInputEnvelope
    connect?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
  }

  export type LoyaltyTransactionCreateNestedManyWithoutProgramInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutProgramInput, LoyaltyTransactionUncheckedCreateWithoutProgramInput> | LoyaltyTransactionCreateWithoutProgramInput[] | LoyaltyTransactionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutProgramInput | LoyaltyTransactionCreateOrConnectWithoutProgramInput[]
    createMany?: LoyaltyTransactionCreateManyProgramInputEnvelope
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
  }

  export type LoyaltyProgramTierUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<LoyaltyProgramTierCreateWithoutProgramInput, LoyaltyProgramTierUncheckedCreateWithoutProgramInput> | LoyaltyProgramTierCreateWithoutProgramInput[] | LoyaltyProgramTierUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyProgramTierCreateOrConnectWithoutProgramInput | LoyaltyProgramTierCreateOrConnectWithoutProgramInput[]
    createMany?: LoyaltyProgramTierCreateManyProgramInputEnvelope
    connect?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
  }

  export type LoyaltyTransactionUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutProgramInput, LoyaltyTransactionUncheckedCreateWithoutProgramInput> | LoyaltyTransactionCreateWithoutProgramInput[] | LoyaltyTransactionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutProgramInput | LoyaltyTransactionCreateOrConnectWithoutProgramInput[]
    createMany?: LoyaltyTransactionCreateManyProgramInputEnvelope
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
  }

  export type LoyaltyProgramTierUpdateManyWithoutProgramNestedInput = {
    create?: XOR<LoyaltyProgramTierCreateWithoutProgramInput, LoyaltyProgramTierUncheckedCreateWithoutProgramInput> | LoyaltyProgramTierCreateWithoutProgramInput[] | LoyaltyProgramTierUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyProgramTierCreateOrConnectWithoutProgramInput | LoyaltyProgramTierCreateOrConnectWithoutProgramInput[]
    upsert?: LoyaltyProgramTierUpsertWithWhereUniqueWithoutProgramInput | LoyaltyProgramTierUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: LoyaltyProgramTierCreateManyProgramInputEnvelope
    set?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    disconnect?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    delete?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    connect?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    update?: LoyaltyProgramTierUpdateWithWhereUniqueWithoutProgramInput | LoyaltyProgramTierUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: LoyaltyProgramTierUpdateManyWithWhereWithoutProgramInput | LoyaltyProgramTierUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: LoyaltyProgramTierScalarWhereInput | LoyaltyProgramTierScalarWhereInput[]
  }

  export type LoyaltyTransactionUpdateManyWithoutProgramNestedInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutProgramInput, LoyaltyTransactionUncheckedCreateWithoutProgramInput> | LoyaltyTransactionCreateWithoutProgramInput[] | LoyaltyTransactionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutProgramInput | LoyaltyTransactionCreateOrConnectWithoutProgramInput[]
    upsert?: LoyaltyTransactionUpsertWithWhereUniqueWithoutProgramInput | LoyaltyTransactionUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: LoyaltyTransactionCreateManyProgramInputEnvelope
    set?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    disconnect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    delete?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    update?: LoyaltyTransactionUpdateWithWhereUniqueWithoutProgramInput | LoyaltyTransactionUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: LoyaltyTransactionUpdateManyWithWhereWithoutProgramInput | LoyaltyTransactionUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
  }

  export type LoyaltyProgramTierUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<LoyaltyProgramTierCreateWithoutProgramInput, LoyaltyProgramTierUncheckedCreateWithoutProgramInput> | LoyaltyProgramTierCreateWithoutProgramInput[] | LoyaltyProgramTierUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyProgramTierCreateOrConnectWithoutProgramInput | LoyaltyProgramTierCreateOrConnectWithoutProgramInput[]
    upsert?: LoyaltyProgramTierUpsertWithWhereUniqueWithoutProgramInput | LoyaltyProgramTierUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: LoyaltyProgramTierCreateManyProgramInputEnvelope
    set?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    disconnect?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    delete?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    connect?: LoyaltyProgramTierWhereUniqueInput | LoyaltyProgramTierWhereUniqueInput[]
    update?: LoyaltyProgramTierUpdateWithWhereUniqueWithoutProgramInput | LoyaltyProgramTierUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: LoyaltyProgramTierUpdateManyWithWhereWithoutProgramInput | LoyaltyProgramTierUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: LoyaltyProgramTierScalarWhereInput | LoyaltyProgramTierScalarWhereInput[]
  }

  export type LoyaltyTransactionUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<LoyaltyTransactionCreateWithoutProgramInput, LoyaltyTransactionUncheckedCreateWithoutProgramInput> | LoyaltyTransactionCreateWithoutProgramInput[] | LoyaltyTransactionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LoyaltyTransactionCreateOrConnectWithoutProgramInput | LoyaltyTransactionCreateOrConnectWithoutProgramInput[]
    upsert?: LoyaltyTransactionUpsertWithWhereUniqueWithoutProgramInput | LoyaltyTransactionUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: LoyaltyTransactionCreateManyProgramInputEnvelope
    set?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    disconnect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    delete?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    connect?: LoyaltyTransactionWhereUniqueInput | LoyaltyTransactionWhereUniqueInput[]
    update?: LoyaltyTransactionUpdateWithWhereUniqueWithoutProgramInput | LoyaltyTransactionUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: LoyaltyTransactionUpdateManyWithWhereWithoutProgramInput | LoyaltyTransactionUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
  }

  export type LoyaltyProgramCreateNestedOneWithoutTiersInput = {
    create?: XOR<LoyaltyProgramCreateWithoutTiersInput, LoyaltyProgramUncheckedCreateWithoutTiersInput>
    connectOrCreate?: LoyaltyProgramCreateOrConnectWithoutTiersInput
    connect?: LoyaltyProgramWhereUniqueInput
  }

  export type LoyaltyProgramUpdateOneRequiredWithoutTiersNestedInput = {
    create?: XOR<LoyaltyProgramCreateWithoutTiersInput, LoyaltyProgramUncheckedCreateWithoutTiersInput>
    connectOrCreate?: LoyaltyProgramCreateOrConnectWithoutTiersInput
    upsert?: LoyaltyProgramUpsertWithoutTiersInput
    connect?: LoyaltyProgramWhereUniqueInput
    update?: XOR<XOR<LoyaltyProgramUpdateToOneWithWhereWithoutTiersInput, LoyaltyProgramUpdateWithoutTiersInput>, LoyaltyProgramUncheckedUpdateWithoutTiersInput>
  }

  export type CustomerCreateNestedOneWithoutLoyaltyTransactionsInput = {
    create?: XOR<CustomerCreateWithoutLoyaltyTransactionsInput, CustomerUncheckedCreateWithoutLoyaltyTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLoyaltyTransactionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type LoyaltyProgramCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<LoyaltyProgramCreateWithoutTransactionsInput, LoyaltyProgramUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LoyaltyProgramCreateOrConnectWithoutTransactionsInput
    connect?: LoyaltyProgramWhereUniqueInput
  }

  export type EnumLoyaltyTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.LoyaltyTransactionType
  }

  export type CustomerUpdateOneRequiredWithoutLoyaltyTransactionsNestedInput = {
    create?: XOR<CustomerCreateWithoutLoyaltyTransactionsInput, CustomerUncheckedCreateWithoutLoyaltyTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLoyaltyTransactionsInput
    upsert?: CustomerUpsertWithoutLoyaltyTransactionsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutLoyaltyTransactionsInput, CustomerUpdateWithoutLoyaltyTransactionsInput>, CustomerUncheckedUpdateWithoutLoyaltyTransactionsInput>
  }

  export type LoyaltyProgramUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<LoyaltyProgramCreateWithoutTransactionsInput, LoyaltyProgramUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: LoyaltyProgramCreateOrConnectWithoutTransactionsInput
    upsert?: LoyaltyProgramUpsertWithoutTransactionsInput
    connect?: LoyaltyProgramWhereUniqueInput
    update?: XOR<XOR<LoyaltyProgramUpdateToOneWithWhereWithoutTransactionsInput, LoyaltyProgramUpdateWithoutTransactionsInput>, LoyaltyProgramUncheckedUpdateWithoutTransactionsInput>
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction
  }

  export type WarehouseCreateNestedOneWithoutAuditsInput = {
    create?: XOR<WarehouseCreateWithoutAuditsInput, WarehouseUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutAuditsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedAuditsInput = {
    create?: XOR<UserCreateWithoutCreatedAuditsInput, UserUncheckedCreateWithoutCreatedAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAuditsInput
    connect?: UserWhereUniqueInput
  }

  export type AuditItemCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditItemCreateWithoutAuditInput, AuditItemUncheckedCreateWithoutAuditInput> | AuditItemCreateWithoutAuditInput[] | AuditItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutAuditInput | AuditItemCreateOrConnectWithoutAuditInput[]
    createMany?: AuditItemCreateManyAuditInputEnvelope
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
  }

  export type AuditAssignmentCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditAssignmentCreateWithoutAuditInput, AuditAssignmentUncheckedCreateWithoutAuditInput> | AuditAssignmentCreateWithoutAuditInput[] | AuditAssignmentUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutAuditInput | AuditAssignmentCreateOrConnectWithoutAuditInput[]
    createMany?: AuditAssignmentCreateManyAuditInputEnvelope
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
  }

  export type AuditItemUncheckedCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditItemCreateWithoutAuditInput, AuditItemUncheckedCreateWithoutAuditInput> | AuditItemCreateWithoutAuditInput[] | AuditItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutAuditInput | AuditItemCreateOrConnectWithoutAuditInput[]
    createMany?: AuditItemCreateManyAuditInputEnvelope
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
  }

  export type AuditAssignmentUncheckedCreateNestedManyWithoutAuditInput = {
    create?: XOR<AuditAssignmentCreateWithoutAuditInput, AuditAssignmentUncheckedCreateWithoutAuditInput> | AuditAssignmentCreateWithoutAuditInput[] | AuditAssignmentUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutAuditInput | AuditAssignmentCreateOrConnectWithoutAuditInput[]
    createMany?: AuditAssignmentCreateManyAuditInputEnvelope
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
  }

  export type EnumAuditStatusFieldUpdateOperationsInput = {
    set?: $Enums.AuditStatus
  }

  export type WarehouseUpdateOneRequiredWithoutAuditsNestedInput = {
    create?: XOR<WarehouseCreateWithoutAuditsInput, WarehouseUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutAuditsInput
    upsert?: WarehouseUpsertWithoutAuditsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutAuditsInput, WarehouseUpdateWithoutAuditsInput>, WarehouseUncheckedUpdateWithoutAuditsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedAuditsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedAuditsInput, UserUncheckedCreateWithoutCreatedAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAuditsInput
    upsert?: UserUpsertWithoutCreatedAuditsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedAuditsInput, UserUpdateWithoutCreatedAuditsInput>, UserUncheckedUpdateWithoutCreatedAuditsInput>
  }

  export type AuditItemUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditItemCreateWithoutAuditInput, AuditItemUncheckedCreateWithoutAuditInput> | AuditItemCreateWithoutAuditInput[] | AuditItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutAuditInput | AuditItemCreateOrConnectWithoutAuditInput[]
    upsert?: AuditItemUpsertWithWhereUniqueWithoutAuditInput | AuditItemUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditItemCreateManyAuditInputEnvelope
    set?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    disconnect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    delete?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    update?: AuditItemUpdateWithWhereUniqueWithoutAuditInput | AuditItemUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditItemUpdateManyWithWhereWithoutAuditInput | AuditItemUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
  }

  export type AuditAssignmentUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditAssignmentCreateWithoutAuditInput, AuditAssignmentUncheckedCreateWithoutAuditInput> | AuditAssignmentCreateWithoutAuditInput[] | AuditAssignmentUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutAuditInput | AuditAssignmentCreateOrConnectWithoutAuditInput[]
    upsert?: AuditAssignmentUpsertWithWhereUniqueWithoutAuditInput | AuditAssignmentUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditAssignmentCreateManyAuditInputEnvelope
    set?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    disconnect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    delete?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    update?: AuditAssignmentUpdateWithWhereUniqueWithoutAuditInput | AuditAssignmentUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditAssignmentUpdateManyWithWhereWithoutAuditInput | AuditAssignmentUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditAssignmentScalarWhereInput | AuditAssignmentScalarWhereInput[]
  }

  export type AuditItemUncheckedUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditItemCreateWithoutAuditInput, AuditItemUncheckedCreateWithoutAuditInput> | AuditItemCreateWithoutAuditInput[] | AuditItemUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditItemCreateOrConnectWithoutAuditInput | AuditItemCreateOrConnectWithoutAuditInput[]
    upsert?: AuditItemUpsertWithWhereUniqueWithoutAuditInput | AuditItemUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditItemCreateManyAuditInputEnvelope
    set?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    disconnect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    delete?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    connect?: AuditItemWhereUniqueInput | AuditItemWhereUniqueInput[]
    update?: AuditItemUpdateWithWhereUniqueWithoutAuditInput | AuditItemUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditItemUpdateManyWithWhereWithoutAuditInput | AuditItemUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
  }

  export type AuditAssignmentUncheckedUpdateManyWithoutAuditNestedInput = {
    create?: XOR<AuditAssignmentCreateWithoutAuditInput, AuditAssignmentUncheckedCreateWithoutAuditInput> | AuditAssignmentCreateWithoutAuditInput[] | AuditAssignmentUncheckedCreateWithoutAuditInput[]
    connectOrCreate?: AuditAssignmentCreateOrConnectWithoutAuditInput | AuditAssignmentCreateOrConnectWithoutAuditInput[]
    upsert?: AuditAssignmentUpsertWithWhereUniqueWithoutAuditInput | AuditAssignmentUpsertWithWhereUniqueWithoutAuditInput[]
    createMany?: AuditAssignmentCreateManyAuditInputEnvelope
    set?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    disconnect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    delete?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    connect?: AuditAssignmentWhereUniqueInput | AuditAssignmentWhereUniqueInput[]
    update?: AuditAssignmentUpdateWithWhereUniqueWithoutAuditInput | AuditAssignmentUpdateWithWhereUniqueWithoutAuditInput[]
    updateMany?: AuditAssignmentUpdateManyWithWhereWithoutAuditInput | AuditAssignmentUpdateManyWithWhereWithoutAuditInput[]
    deleteMany?: AuditAssignmentScalarWhereInput | AuditAssignmentScalarWhereInput[]
  }

  export type AuditCreateNestedOneWithoutItemsInput = {
    create?: XOR<AuditCreateWithoutItemsInput, AuditUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutItemsInput
    connect?: AuditWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutAuditItemsInput = {
    create?: XOR<ProductCreateWithoutAuditItemsInput, ProductUncheckedCreateWithoutAuditItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAuditItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type InventoryItemCreateNestedOneWithoutAuditItemsInput = {
    create?: XOR<InventoryItemCreateWithoutAuditItemsInput, InventoryItemUncheckedCreateWithoutAuditItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutAuditItemsInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type EnumAuditItemStatusFieldUpdateOperationsInput = {
    set?: $Enums.AuditItemStatus
  }

  export type AuditUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<AuditCreateWithoutItemsInput, AuditUncheckedCreateWithoutItemsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutItemsInput
    upsert?: AuditUpsertWithoutItemsInput
    connect?: AuditWhereUniqueInput
    update?: XOR<XOR<AuditUpdateToOneWithWhereWithoutItemsInput, AuditUpdateWithoutItemsInput>, AuditUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutAuditItemsNestedInput = {
    create?: XOR<ProductCreateWithoutAuditItemsInput, ProductUncheckedCreateWithoutAuditItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAuditItemsInput
    upsert?: ProductUpsertWithoutAuditItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutAuditItemsInput, ProductUpdateWithoutAuditItemsInput>, ProductUncheckedUpdateWithoutAuditItemsInput>
  }

  export type InventoryItemUpdateOneRequiredWithoutAuditItemsNestedInput = {
    create?: XOR<InventoryItemCreateWithoutAuditItemsInput, InventoryItemUncheckedCreateWithoutAuditItemsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutAuditItemsInput
    upsert?: InventoryItemUpsertWithoutAuditItemsInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutAuditItemsInput, InventoryItemUpdateWithoutAuditItemsInput>, InventoryItemUncheckedUpdateWithoutAuditItemsInput>
  }

  export type AuditCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<AuditCreateWithoutAssignmentsInput, AuditUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutAssignmentsInput
    connect?: AuditWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditAssignmentsInput = {
    create?: XOR<UserCreateWithoutAuditAssignmentsInput, UserUncheckedCreateWithoutAuditAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAssignmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssignmentStatus
  }

  export type AuditUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<AuditCreateWithoutAssignmentsInput, AuditUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: AuditCreateOrConnectWithoutAssignmentsInput
    upsert?: AuditUpsertWithoutAssignmentsInput
    connect?: AuditWhereUniqueInput
    update?: XOR<XOR<AuditUpdateToOneWithWhereWithoutAssignmentsInput, AuditUpdateWithoutAssignmentsInput>, AuditUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutAuditAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutAuditAssignmentsInput, UserUncheckedCreateWithoutAuditAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditAssignmentsInput
    upsert?: UserUpsertWithoutAuditAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditAssignmentsInput, UserUpdateWithoutAuditAssignmentsInput>, UserUncheckedUpdateWithoutAuditAssignmentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumContractStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusFilter<$PrismaModel> | $Enums.ContractStatus
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumContractStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContractStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContractStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractStatusFilter<$PrismaModel>
    _max?: NestedEnumContractStatusFilter<$PrismaModel>
  }

  export type NestedEnumPerformanceMetricTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PerformanceMetricType | EnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PerformanceMetricType[] | ListEnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PerformanceMetricType[] | ListEnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPerformanceMetricTypeFilter<$PrismaModel> | $Enums.PerformanceMetricType
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumPerformanceMetricTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PerformanceMetricType | EnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PerformanceMetricType[] | ListEnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PerformanceMetricType[] | ListEnumPerformanceMetricTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPerformanceMetricTypeWithAggregatesFilter<$PrismaModel> | $Enums.PerformanceMetricType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPerformanceMetricTypeFilter<$PrismaModel>
    _max?: NestedEnumPerformanceMetricTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPurchaseOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderStatus | EnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel> | $Enums.PurchaseOrderStatus
  }

  export type NestedEnumPurchaseOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderStatus | EnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumProductConditionFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCondition | EnumProductConditionFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumProductConditionFilter<$PrismaModel> | $Enums.ProductCondition
  }

  export type NestedEnumProductConditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCondition | EnumProductConditionFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumProductConditionWithAggregatesFilter<$PrismaModel> | $Enums.ProductCondition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductConditionFilter<$PrismaModel>
    _max?: NestedEnumProductConditionFilter<$PrismaModel>
  }

  export type NestedEnumInventoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusFilter<$PrismaModel> | $Enums.InventoryStatus
  }

  export type NestedEnumInventoryMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryMethod | EnumInventoryMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.InventoryMethod[] | ListEnumInventoryMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InventoryMethod[] | ListEnumInventoryMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInventoryMethodNullableFilter<$PrismaModel> | $Enums.InventoryMethod | null
  }

  export type NestedEnumInventoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryStatus | EnumInventoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryStatus[] | ListEnumInventoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InventoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryStatusFilter<$PrismaModel>
    _max?: NestedEnumInventoryStatusFilter<$PrismaModel>
  }

  export type NestedEnumInventoryMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryMethod | EnumInventoryMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.InventoryMethod[] | ListEnumInventoryMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InventoryMethod[] | ListEnumInventoryMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInventoryMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.InventoryMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInventoryMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumInventoryMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumReturnStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnStatusFilter<$PrismaModel> | $Enums.ReturnStatus
  }

  export type NestedEnumRefundMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundMethod | EnumRefundMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRefundMethodNullableFilter<$PrismaModel> | $Enums.RefundMethod | null
  }

  export type NestedEnumRefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusFilter<$PrismaModel> | $Enums.RefundStatus
  }

  export type NestedEnumReturnStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnStatus[] | ListEnumReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReturnStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReturnStatusFilter<$PrismaModel>
    _max?: NestedEnumReturnStatusFilter<$PrismaModel>
  }

  export type NestedEnumRefundMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundMethod | EnumRefundMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RefundMethod[] | ListEnumRefundMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRefundMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.RefundMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRefundMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumRefundMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundStatusFilter<$PrismaModel>
    _max?: NestedEnumRefundStatusFilter<$PrismaModel>
  }

  export type NestedEnumReturnReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnReason | EnumReturnReasonFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnReason[] | ListEnumReturnReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnReason[] | ListEnumReturnReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnReasonFilter<$PrismaModel> | $Enums.ReturnReason
  }

  export type NestedEnumItemConditionFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemCondition | EnumItemConditionFieldRefInput<$PrismaModel>
    in?: $Enums.ItemCondition[] | ListEnumItemConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemCondition[] | ListEnumItemConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumItemConditionFilter<$PrismaModel> | $Enums.ItemCondition
  }

  export type NestedEnumReturnReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnReason | EnumReturnReasonFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnReason[] | ListEnumReturnReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReturnReason[] | ListEnumReturnReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReturnReasonWithAggregatesFilter<$PrismaModel> | $Enums.ReturnReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReturnReasonFilter<$PrismaModel>
    _max?: NestedEnumReturnReasonFilter<$PrismaModel>
  }

  export type NestedEnumItemConditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemCondition | EnumItemConditionFieldRefInput<$PrismaModel>
    in?: $Enums.ItemCondition[] | ListEnumItemConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemCondition[] | ListEnumItemConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumItemConditionWithAggregatesFilter<$PrismaModel> | $Enums.ItemCondition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemConditionFilter<$PrismaModel>
    _max?: NestedEnumItemConditionFilter<$PrismaModel>
  }

  export type NestedEnumQCTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QCType | EnumQCTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QCType[] | ListEnumQCTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCType[] | ListEnumQCTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTypeFilter<$PrismaModel> | $Enums.QCType
  }

  export type NestedEnumQCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QCStatus | EnumQCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QCStatus[] | ListEnumQCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCStatus[] | ListEnumQCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQCStatusFilter<$PrismaModel> | $Enums.QCStatus
  }

  export type NestedEnumQCTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QCType | EnumQCTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QCType[] | ListEnumQCTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCType[] | ListEnumQCTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTypeWithAggregatesFilter<$PrismaModel> | $Enums.QCType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQCTypeFilter<$PrismaModel>
    _max?: NestedEnumQCTypeFilter<$PrismaModel>
  }

  export type NestedEnumQCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QCStatus | EnumQCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QCStatus[] | ListEnumQCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCStatus[] | ListEnumQCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQCStatusWithAggregatesFilter<$PrismaModel> | $Enums.QCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQCStatusFilter<$PrismaModel>
    _max?: NestedEnumQCStatusFilter<$PrismaModel>
  }

  export type NestedEnumQCItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QCItemStatus | EnumQCItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QCItemStatus[] | ListEnumQCItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCItemStatus[] | ListEnumQCItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQCItemStatusFilter<$PrismaModel> | $Enums.QCItemStatus
  }

  export type NestedEnumQCActionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.QCAction | EnumQCActionFieldRefInput<$PrismaModel> | null
    in?: $Enums.QCAction[] | ListEnumQCActionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QCAction[] | ListEnumQCActionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQCActionNullableFilter<$PrismaModel> | $Enums.QCAction | null
  }

  export type NestedEnumQCItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QCItemStatus | EnumQCItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QCItemStatus[] | ListEnumQCItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCItemStatus[] | ListEnumQCItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQCItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.QCItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQCItemStatusFilter<$PrismaModel>
    _max?: NestedEnumQCItemStatusFilter<$PrismaModel>
  }

  export type NestedEnumQCActionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QCAction | EnumQCActionFieldRefInput<$PrismaModel> | null
    in?: $Enums.QCAction[] | ListEnumQCActionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.QCAction[] | ListEnumQCActionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumQCActionNullableWithAggregatesFilter<$PrismaModel> | $Enums.QCAction | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumQCActionNullableFilter<$PrismaModel>
    _max?: NestedEnumQCActionNullableFilter<$PrismaModel>
  }

  export type NestedEnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type NestedEnumTransferTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferType | EnumTransferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferTypeFilter<$PrismaModel> | $Enums.TransferType
  }

  export type NestedEnumTransferPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferPriority | EnumTransferPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TransferPriority[] | ListEnumTransferPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferPriority[] | ListEnumTransferPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferPriorityFilter<$PrismaModel> | $Enums.TransferPriority
  }

  export type NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransferTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferType | EnumTransferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransferType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferTypeFilter<$PrismaModel>
    _max?: NestedEnumTransferTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransferPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferPriority | EnumTransferPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TransferPriority[] | ListEnumTransferPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferPriority[] | ListEnumTransferPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TransferPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferPriorityFilter<$PrismaModel>
    _max?: NestedEnumTransferPriorityFilter<$PrismaModel>
  }

  export type NestedEnumLoyaltyTierFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTierFilter<$PrismaModel> | $Enums.LoyaltyTier
  }

  export type NestedEnumLoyaltyTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTierWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyTierFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyTierFilter<$PrismaModel>
  }

  export type NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
  }

  export type NestedEnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type NestedEnumAuditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusFilter<$PrismaModel> | $Enums.AuditStatus
  }

  export type NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditStatus | EnumAuditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditStatus[] | ListEnumAuditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditStatusFilter<$PrismaModel>
  }

  export type NestedEnumAuditItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditItemStatus | EnumAuditItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditItemStatusFilter<$PrismaModel> | $Enums.AuditItemStatus
  }

  export type NestedEnumAuditItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditItemStatus | EnumAuditItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditItemStatus[] | ListEnumAuditItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuditItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditItemStatusFilter<$PrismaModel>
    _max?: NestedEnumAuditItemStatusFilter<$PrismaModel>
  }

  export type NestedEnumAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusFilter<$PrismaModel> | $Enums.AssignmentStatus
  }

  export type NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssignmentStatusFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SaleCreateWithoutCreatedByInput = {
    id?: string
    receiptNumber: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
    payments?: PaymentCreateNestedManyWithoutSaleInput
    returns?: ReturnCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutCreatedByInput = {
    id?: string
    receiptNumber: string
    storeId: string
    customerId?: string | null
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: PaymentUncheckedCreateNestedManyWithoutSaleInput
    returns?: ReturnUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutCreatedByInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput>
  }

  export type SaleCreateManyCreatedByInputEnvelope = {
    data: SaleCreateManyCreatedByInput | SaleCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ReturnCreateWithoutProcessedByInput = {
    id?: string
    returnNumber: string
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sale?: SaleCreateNestedOneWithoutReturnsInput
    store: StoreCreateNestedOneWithoutReturnsInput
    customer?: CustomerCreateNestedOneWithoutReturnsInput
    items?: ReturnItemCreateNestedManyWithoutReturnInput
    qualityControls?: QualityControlCreateNestedManyWithoutReturnInput
  }

  export type ReturnUncheckedCreateWithoutProcessedByInput = {
    id?: string
    returnNumber: string
    saleId?: string | null
    storeId: string
    customerId?: string | null
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ReturnItemUncheckedCreateNestedManyWithoutReturnInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutReturnInput
  }

  export type ReturnCreateOrConnectWithoutProcessedByInput = {
    where: ReturnWhereUniqueInput
    create: XOR<ReturnCreateWithoutProcessedByInput, ReturnUncheckedCreateWithoutProcessedByInput>
  }

  export type ReturnCreateManyProcessedByInputEnvelope = {
    data: ReturnCreateManyProcessedByInput | ReturnCreateManyProcessedByInput[]
    skipDuplicates?: boolean
  }

  export type QualityControlCreateWithoutInspectedByInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutQualityControlsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutQualityControlsInput
    return?: ReturnCreateNestedOneWithoutQualityControlsInput
    items?: QualityControlItemCreateNestedManyWithoutQualityControlInput
  }

  export type QualityControlUncheckedCreateWithoutInspectedByInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    warehouseId: string
    purchaseOrderId?: string | null
    returnId?: string | null
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QualityControlItemUncheckedCreateNestedManyWithoutQualityControlInput
  }

  export type QualityControlCreateOrConnectWithoutInspectedByInput = {
    where: QualityControlWhereUniqueInput
    create: XOR<QualityControlCreateWithoutInspectedByInput, QualityControlUncheckedCreateWithoutInspectedByInput>
  }

  export type QualityControlCreateManyInspectedByInputEnvelope = {
    data: QualityControlCreateManyInspectedByInput | QualityControlCreateManyInspectedByInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseStaffCreateWithoutUserInput = {
    id?: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutStaffInput
  }

  export type WarehouseStaffUncheckedCreateWithoutUserInput = {
    id?: string
    warehouseId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseStaffCreateOrConnectWithoutUserInput = {
    where: WarehouseStaffWhereUniqueInput
    create: XOR<WarehouseStaffCreateWithoutUserInput, WarehouseStaffUncheckedCreateWithoutUserInput>
  }

  export type StoreStaffCreateWithoutUserInput = {
    id?: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutStaffInput
  }

  export type StoreStaffUncheckedCreateWithoutUserInput = {
    id?: string
    storeId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStaffCreateOrConnectWithoutUserInput = {
    where: StoreStaffWhereUniqueInput
    create: XOR<StoreStaffCreateWithoutUserInput, StoreStaffUncheckedCreateWithoutUserInput>
  }

  export type AuditCreateWithoutCreatedByInput = {
    id?: string
    referenceNumber: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutAuditsInput
    items?: AuditItemCreateNestedManyWithoutAuditInput
    assignments?: AuditAssignmentCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutCreatedByInput = {
    id?: string
    referenceNumber: string
    warehouseId: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: AuditItemUncheckedCreateNestedManyWithoutAuditInput
    assignments?: AuditAssignmentUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutCreatedByInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput>
  }

  export type AuditCreateManyCreatedByInputEnvelope = {
    data: AuditCreateManyCreatedByInput | AuditCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditAssignmentCreateWithoutUserInput = {
    id?: string
    assignedZones?: string | null
    status?: $Enums.AssignmentStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutAssignmentsInput
  }

  export type AuditAssignmentUncheckedCreateWithoutUserInput = {
    id?: string
    auditId: string
    assignedZones?: string | null
    status?: $Enums.AssignmentStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditAssignmentCreateOrConnectWithoutUserInput = {
    where: AuditAssignmentWhereUniqueInput
    create: XOR<AuditAssignmentCreateWithoutUserInput, AuditAssignmentUncheckedCreateWithoutUserInput>
  }

  export type AuditAssignmentCreateManyUserInputEnvelope = {
    data: AuditAssignmentCreateManyUserInput | AuditAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type SaleUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutCreatedByInput, SaleUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SaleCreateWithoutCreatedByInput, SaleUncheckedCreateWithoutCreatedByInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutCreatedByInput, SaleUncheckedUpdateWithoutCreatedByInput>
  }

  export type SaleUpdateManyWithWhereWithoutCreatedByInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SaleScalarWhereInput = {
    AND?: SaleScalarWhereInput | SaleScalarWhereInput[]
    OR?: SaleScalarWhereInput[]
    NOT?: SaleScalarWhereInput | SaleScalarWhereInput[]
    id?: StringFilter<"Sale"> | string
    receiptNumber?: StringFilter<"Sale"> | string
    storeId?: StringFilter<"Sale"> | string
    customerId?: StringNullableFilter<"Sale"> | string | null
    createdById?: StringFilter<"Sale"> | string
    saleDate?: DateTimeFilter<"Sale"> | Date | string
    subtotal?: FloatFilter<"Sale"> | number
    taxAmount?: FloatFilter<"Sale"> | number
    discountAmount?: FloatFilter<"Sale"> | number
    totalAmount?: FloatFilter<"Sale"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Sale"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFilter<"Sale"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"Sale"> | string | null
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
  }

  export type ReturnUpsertWithWhereUniqueWithoutProcessedByInput = {
    where: ReturnWhereUniqueInput
    update: XOR<ReturnUpdateWithoutProcessedByInput, ReturnUncheckedUpdateWithoutProcessedByInput>
    create: XOR<ReturnCreateWithoutProcessedByInput, ReturnUncheckedCreateWithoutProcessedByInput>
  }

  export type ReturnUpdateWithWhereUniqueWithoutProcessedByInput = {
    where: ReturnWhereUniqueInput
    data: XOR<ReturnUpdateWithoutProcessedByInput, ReturnUncheckedUpdateWithoutProcessedByInput>
  }

  export type ReturnUpdateManyWithWhereWithoutProcessedByInput = {
    where: ReturnScalarWhereInput
    data: XOR<ReturnUpdateManyMutationInput, ReturnUncheckedUpdateManyWithoutProcessedByInput>
  }

  export type ReturnScalarWhereInput = {
    AND?: ReturnScalarWhereInput | ReturnScalarWhereInput[]
    OR?: ReturnScalarWhereInput[]
    NOT?: ReturnScalarWhereInput | ReturnScalarWhereInput[]
    id?: StringFilter<"Return"> | string
    returnNumber?: StringFilter<"Return"> | string
    saleId?: StringNullableFilter<"Return"> | string | null
    storeId?: StringFilter<"Return"> | string
    customerId?: StringNullableFilter<"Return"> | string | null
    returnDate?: DateTimeFilter<"Return"> | Date | string
    status?: EnumReturnStatusFilter<"Return"> | $Enums.ReturnStatus
    subtotal?: FloatFilter<"Return"> | number
    taxAmount?: FloatFilter<"Return"> | number
    totalAmount?: FloatFilter<"Return"> | number
    refundMethod?: EnumRefundMethodNullableFilter<"Return"> | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFilter<"Return"> | $Enums.RefundStatus
    reason?: StringNullableFilter<"Return"> | string | null
    notes?: StringNullableFilter<"Return"> | string | null
    processedById?: StringFilter<"Return"> | string
    createdAt?: DateTimeFilter<"Return"> | Date | string
    updatedAt?: DateTimeFilter<"Return"> | Date | string
  }

  export type QualityControlUpsertWithWhereUniqueWithoutInspectedByInput = {
    where: QualityControlWhereUniqueInput
    update: XOR<QualityControlUpdateWithoutInspectedByInput, QualityControlUncheckedUpdateWithoutInspectedByInput>
    create: XOR<QualityControlCreateWithoutInspectedByInput, QualityControlUncheckedCreateWithoutInspectedByInput>
  }

  export type QualityControlUpdateWithWhereUniqueWithoutInspectedByInput = {
    where: QualityControlWhereUniqueInput
    data: XOR<QualityControlUpdateWithoutInspectedByInput, QualityControlUncheckedUpdateWithoutInspectedByInput>
  }

  export type QualityControlUpdateManyWithWhereWithoutInspectedByInput = {
    where: QualityControlScalarWhereInput
    data: XOR<QualityControlUpdateManyMutationInput, QualityControlUncheckedUpdateManyWithoutInspectedByInput>
  }

  export type QualityControlScalarWhereInput = {
    AND?: QualityControlScalarWhereInput | QualityControlScalarWhereInput[]
    OR?: QualityControlScalarWhereInput[]
    NOT?: QualityControlScalarWhereInput | QualityControlScalarWhereInput[]
    id?: StringFilter<"QualityControl"> | string
    referenceNumber?: StringFilter<"QualityControl"> | string
    type?: EnumQCTypeFilter<"QualityControl"> | $Enums.QCType
    status?: EnumQCStatusFilter<"QualityControl"> | $Enums.QCStatus
    warehouseId?: StringFilter<"QualityControl"> | string
    purchaseOrderId?: StringNullableFilter<"QualityControl"> | string | null
    returnId?: StringNullableFilter<"QualityControl"> | string | null
    inspectionDate?: DateTimeFilter<"QualityControl"> | Date | string
    completedDate?: DateTimeNullableFilter<"QualityControl"> | Date | string | null
    inspectedById?: StringFilter<"QualityControl"> | string
    notes?: StringNullableFilter<"QualityControl"> | string | null
    createdAt?: DateTimeFilter<"QualityControl"> | Date | string
    updatedAt?: DateTimeFilter<"QualityControl"> | Date | string
  }

  export type WarehouseStaffUpsertWithoutUserInput = {
    update: XOR<WarehouseStaffUpdateWithoutUserInput, WarehouseStaffUncheckedUpdateWithoutUserInput>
    create: XOR<WarehouseStaffCreateWithoutUserInput, WarehouseStaffUncheckedCreateWithoutUserInput>
    where?: WarehouseStaffWhereInput
  }

  export type WarehouseStaffUpdateToOneWithWhereWithoutUserInput = {
    where?: WarehouseStaffWhereInput
    data: XOR<WarehouseStaffUpdateWithoutUserInput, WarehouseStaffUncheckedUpdateWithoutUserInput>
  }

  export type WarehouseStaffUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutStaffNestedInput
  }

  export type WarehouseStaffUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStaffUpsertWithoutUserInput = {
    update: XOR<StoreStaffUpdateWithoutUserInput, StoreStaffUncheckedUpdateWithoutUserInput>
    create: XOR<StoreStaffCreateWithoutUserInput, StoreStaffUncheckedCreateWithoutUserInput>
    where?: StoreStaffWhereInput
  }

  export type StoreStaffUpdateToOneWithWhereWithoutUserInput = {
    where?: StoreStaffWhereInput
    data: XOR<StoreStaffUpdateWithoutUserInput, StoreStaffUncheckedUpdateWithoutUserInput>
  }

  export type StoreStaffUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutStaffNestedInput
  }

  export type StoreStaffUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AuditWhereUniqueInput
    update: XOR<AuditUpdateWithoutCreatedByInput, AuditUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AuditCreateWithoutCreatedByInput, AuditUncheckedCreateWithoutCreatedByInput>
  }

  export type AuditUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AuditWhereUniqueInput
    data: XOR<AuditUpdateWithoutCreatedByInput, AuditUncheckedUpdateWithoutCreatedByInput>
  }

  export type AuditUpdateManyWithWhereWithoutCreatedByInput = {
    where: AuditScalarWhereInput
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AuditScalarWhereInput = {
    AND?: AuditScalarWhereInput | AuditScalarWhereInput[]
    OR?: AuditScalarWhereInput[]
    NOT?: AuditScalarWhereInput | AuditScalarWhereInput[]
    id?: StringFilter<"Audit"> | string
    referenceNumber?: StringFilter<"Audit"> | string
    warehouseId?: StringFilter<"Audit"> | string
    status?: EnumAuditStatusFilter<"Audit"> | $Enums.AuditStatus
    startDate?: DateTimeFilter<"Audit"> | Date | string
    endDate?: DateTimeNullableFilter<"Audit"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Audit"> | Date | string | null
    notes?: StringNullableFilter<"Audit"> | string | null
    createdById?: StringFilter<"Audit"> | string
    createdAt?: DateTimeFilter<"Audit"> | Date | string
    updatedAt?: DateTimeFilter<"Audit"> | Date | string
  }

  export type AuditAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditAssignmentWhereUniqueInput
    update: XOR<AuditAssignmentUpdateWithoutUserInput, AuditAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<AuditAssignmentCreateWithoutUserInput, AuditAssignmentUncheckedCreateWithoutUserInput>
  }

  export type AuditAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditAssignmentWhereUniqueInput
    data: XOR<AuditAssignmentUpdateWithoutUserInput, AuditAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type AuditAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: AuditAssignmentScalarWhereInput
    data: XOR<AuditAssignmentUpdateManyMutationInput, AuditAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditAssignmentScalarWhereInput = {
    AND?: AuditAssignmentScalarWhereInput | AuditAssignmentScalarWhereInput[]
    OR?: AuditAssignmentScalarWhereInput[]
    NOT?: AuditAssignmentScalarWhereInput | AuditAssignmentScalarWhereInput[]
    id?: StringFilter<"AuditAssignment"> | string
    auditId?: StringFilter<"AuditAssignment"> | string
    userId?: StringFilter<"AuditAssignment"> | string
    assignedZones?: StringNullableFilter<"AuditAssignment"> | string | null
    status?: EnumAssignmentStatusFilter<"AuditAssignment"> | $Enums.AssignmentStatus
    startedAt?: DateTimeNullableFilter<"AuditAssignment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AuditAssignment"> | Date | string | null
    createdAt?: DateTimeFilter<"AuditAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"AuditAssignment"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnUncheckedCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlUncheckedCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUncheckedUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUncheckedUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnUncheckedCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlUncheckedCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUncheckedUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUncheckedUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WarehouseZoneCreateWithoutWarehouseInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aisles?: WarehouseAisleCreateNestedManyWithoutZoneInput
  }

  export type WarehouseZoneUncheckedCreateWithoutWarehouseInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aisles?: WarehouseAisleUncheckedCreateNestedManyWithoutZoneInput
  }

  export type WarehouseZoneCreateOrConnectWithoutWarehouseInput = {
    where: WarehouseZoneWhereUniqueInput
    create: XOR<WarehouseZoneCreateWithoutWarehouseInput, WarehouseZoneUncheckedCreateWithoutWarehouseInput>
  }

  export type WarehouseZoneCreateManyWarehouseInputEnvelope = {
    data: WarehouseZoneCreateManyWarehouseInput | WarehouseZoneCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemCreateWithoutWarehouseInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    store?: StoreCreateNestedOneWithoutInventoryItemsInput
    bin?: WarehouseBinCreateNestedOneWithoutInventoryItemsInput
    saleItems?: SaleItemCreateNestedManyWithoutInventoryItemInput
    auditItems?: AuditItemCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutWarehouseInput = {
    id?: string
    productId: string
    storeId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutWarehouseInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryItemCreateManyWarehouseInputEnvelope = {
    data: InventoryItemCreateManyWarehouseInput | InventoryItemCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseStaffCreateWithoutWarehouseInput = {
    id?: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWarehouseStaffInput
  }

  export type WarehouseStaffUncheckedCreateWithoutWarehouseInput = {
    id?: string
    userId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseStaffCreateOrConnectWithoutWarehouseInput = {
    where: WarehouseStaffWhereUniqueInput
    create: XOR<WarehouseStaffCreateWithoutWarehouseInput, WarehouseStaffUncheckedCreateWithoutWarehouseInput>
  }

  export type WarehouseStaffCreateManyWarehouseInputEnvelope = {
    data: WarehouseStaffCreateManyWarehouseInput | WarehouseStaffCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutFromWarehouseInput = {
    id?: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromStore?: StoreCreateNestedOneWithoutTransfersFromInput
    toWarehouse?: WarehouseCreateNestedOneWithoutTransfersToInput
    toStore?: StoreCreateNestedOneWithoutTransfersToInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
    documents?: TransferDocumentCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutFromWarehouseInput = {
    id?: string
    transferNumber: string
    fromStoreId?: string | null
    toWarehouseId?: string | null
    toStoreId?: string | null
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
    documents?: TransferDocumentUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutFromWarehouseInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutFromWarehouseInput, TransferUncheckedCreateWithoutFromWarehouseInput>
  }

  export type TransferCreateManyFromWarehouseInputEnvelope = {
    data: TransferCreateManyFromWarehouseInput | TransferCreateManyFromWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutToWarehouseInput = {
    id?: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromWarehouse?: WarehouseCreateNestedOneWithoutTransfersFromInput
    fromStore?: StoreCreateNestedOneWithoutTransfersFromInput
    toStore?: StoreCreateNestedOneWithoutTransfersToInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
    documents?: TransferDocumentCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutToWarehouseInput = {
    id?: string
    transferNumber: string
    fromWarehouseId?: string | null
    fromStoreId?: string | null
    toStoreId?: string | null
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
    documents?: TransferDocumentUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutToWarehouseInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutToWarehouseInput, TransferUncheckedCreateWithoutToWarehouseInput>
  }

  export type TransferCreateManyToWarehouseInputEnvelope = {
    data: TransferCreateManyToWarehouseInput | TransferCreateManyToWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutWarehouseInput = {
    id?: string
    orderNumber: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    status?: $Enums.PurchaseOrderStatus
    subtotal?: number
    taxAmount?: number
    totalAmount?: number
    notes?: string | null
    createdById?: string | null
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    qualityControls?: QualityControlCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutWarehouseInput = {
    id?: string
    orderNumber: string
    supplierId: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    status?: $Enums.PurchaseOrderStatus
    subtotal?: number
    taxAmount?: number
    totalAmount?: number
    notes?: string | null
    createdById?: string | null
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutWarehouseInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput>
  }

  export type PurchaseOrderCreateManyWarehouseInputEnvelope = {
    data: PurchaseOrderCreateManyWarehouseInput | PurchaseOrderCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type QualityControlCreateWithoutWarehouseInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutQualityControlsInput
    return?: ReturnCreateNestedOneWithoutQualityControlsInput
    inspectedBy: UserCreateNestedOneWithoutInspectedQCsInput
    items?: QualityControlItemCreateNestedManyWithoutQualityControlInput
  }

  export type QualityControlUncheckedCreateWithoutWarehouseInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    purchaseOrderId?: string | null
    returnId?: string | null
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    inspectedById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QualityControlItemUncheckedCreateNestedManyWithoutQualityControlInput
  }

  export type QualityControlCreateOrConnectWithoutWarehouseInput = {
    where: QualityControlWhereUniqueInput
    create: XOR<QualityControlCreateWithoutWarehouseInput, QualityControlUncheckedCreateWithoutWarehouseInput>
  }

  export type QualityControlCreateManyWarehouseInputEnvelope = {
    data: QualityControlCreateManyWarehouseInput | QualityControlCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type AuditCreateWithoutWarehouseInput = {
    id?: string
    referenceNumber: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    items?: AuditItemCreateNestedManyWithoutAuditInput
    assignments?: AuditAssignmentCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutWarehouseInput = {
    id?: string
    referenceNumber: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    completedDate?: Date | string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: AuditItemUncheckedCreateNestedManyWithoutAuditInput
    assignments?: AuditAssignmentUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutWarehouseInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutWarehouseInput, AuditUncheckedCreateWithoutWarehouseInput>
  }

  export type AuditCreateManyWarehouseInputEnvelope = {
    data: AuditCreateManyWarehouseInput | AuditCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseZoneUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: WarehouseZoneWhereUniqueInput
    update: XOR<WarehouseZoneUpdateWithoutWarehouseInput, WarehouseZoneUncheckedUpdateWithoutWarehouseInput>
    create: XOR<WarehouseZoneCreateWithoutWarehouseInput, WarehouseZoneUncheckedCreateWithoutWarehouseInput>
  }

  export type WarehouseZoneUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: WarehouseZoneWhereUniqueInput
    data: XOR<WarehouseZoneUpdateWithoutWarehouseInput, WarehouseZoneUncheckedUpdateWithoutWarehouseInput>
  }

  export type WarehouseZoneUpdateManyWithWhereWithoutWarehouseInput = {
    where: WarehouseZoneScalarWhereInput
    data: XOR<WarehouseZoneUpdateManyMutationInput, WarehouseZoneUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type WarehouseZoneScalarWhereInput = {
    AND?: WarehouseZoneScalarWhereInput | WarehouseZoneScalarWhereInput[]
    OR?: WarehouseZoneScalarWhereInput[]
    NOT?: WarehouseZoneScalarWhereInput | WarehouseZoneScalarWhereInput[]
    id?: StringFilter<"WarehouseZone"> | string
    name?: StringFilter<"WarehouseZone"> | string
    code?: StringFilter<"WarehouseZone"> | string
    warehouseId?: StringFilter<"WarehouseZone"> | string
    description?: StringNullableFilter<"WarehouseZone"> | string | null
    createdAt?: DateTimeFilter<"WarehouseZone"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseZone"> | Date | string
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutWarehouseInput, InventoryItemUncheckedUpdateWithoutWarehouseInput>
    create: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutWarehouseInput, InventoryItemUncheckedUpdateWithoutWarehouseInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutWarehouseInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type InventoryItemScalarWhereInput = {
    AND?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    OR?: InventoryItemScalarWhereInput[]
    NOT?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    productId?: StringFilter<"InventoryItem"> | string
    storeId?: StringNullableFilter<"InventoryItem"> | string | null
    warehouseId?: StringNullableFilter<"InventoryItem"> | string | null
    binId?: StringNullableFilter<"InventoryItem"> | string | null
    batchNumber?: StringNullableFilter<"InventoryItem"> | string | null
    lotNumber?: StringNullableFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableFilter<"InventoryItem"> | string | null
    expiryDate?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    manufacturingDate?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    quantity?: IntFilter<"InventoryItem"> | number
    reservedQuantity?: IntFilter<"InventoryItem"> | number
    costPrice?: FloatFilter<"InventoryItem"> | number
    retailPrice?: FloatFilter<"InventoryItem"> | number
    status?: EnumInventoryStatusFilter<"InventoryItem"> | $Enums.InventoryStatus
    condition?: EnumProductConditionFilter<"InventoryItem"> | $Enums.ProductCondition
    inventoryMethod?: EnumInventoryMethodNullableFilter<"InventoryItem"> | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFilter<"InventoryItem"> | Date | string
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
  }

  export type WarehouseStaffUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: WarehouseStaffWhereUniqueInput
    update: XOR<WarehouseStaffUpdateWithoutWarehouseInput, WarehouseStaffUncheckedUpdateWithoutWarehouseInput>
    create: XOR<WarehouseStaffCreateWithoutWarehouseInput, WarehouseStaffUncheckedCreateWithoutWarehouseInput>
  }

  export type WarehouseStaffUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: WarehouseStaffWhereUniqueInput
    data: XOR<WarehouseStaffUpdateWithoutWarehouseInput, WarehouseStaffUncheckedUpdateWithoutWarehouseInput>
  }

  export type WarehouseStaffUpdateManyWithWhereWithoutWarehouseInput = {
    where: WarehouseStaffScalarWhereInput
    data: XOR<WarehouseStaffUpdateManyMutationInput, WarehouseStaffUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type WarehouseStaffScalarWhereInput = {
    AND?: WarehouseStaffScalarWhereInput | WarehouseStaffScalarWhereInput[]
    OR?: WarehouseStaffScalarWhereInput[]
    NOT?: WarehouseStaffScalarWhereInput | WarehouseStaffScalarWhereInput[]
    id?: StringFilter<"WarehouseStaff"> | string
    userId?: StringFilter<"WarehouseStaff"> | string
    warehouseId?: StringFilter<"WarehouseStaff"> | string
    position?: StringNullableFilter<"WarehouseStaff"> | string | null
    isManager?: BoolFilter<"WarehouseStaff"> | boolean
    createdAt?: DateTimeFilter<"WarehouseStaff"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseStaff"> | Date | string
  }

  export type TransferUpsertWithWhereUniqueWithoutFromWarehouseInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutFromWarehouseInput, TransferUncheckedUpdateWithoutFromWarehouseInput>
    create: XOR<TransferCreateWithoutFromWarehouseInput, TransferUncheckedCreateWithoutFromWarehouseInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutFromWarehouseInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutFromWarehouseInput, TransferUncheckedUpdateWithoutFromWarehouseInput>
  }

  export type TransferUpdateManyWithWhereWithoutFromWarehouseInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutFromWarehouseInput>
  }

  export type TransferScalarWhereInput = {
    AND?: TransferScalarWhereInput | TransferScalarWhereInput[]
    OR?: TransferScalarWhereInput[]
    NOT?: TransferScalarWhereInput | TransferScalarWhereInput[]
    id?: StringFilter<"Transfer"> | string
    transferNumber?: StringFilter<"Transfer"> | string
    fromWarehouseId?: StringNullableFilter<"Transfer"> | string | null
    fromStoreId?: StringNullableFilter<"Transfer"> | string | null
    toWarehouseId?: StringNullableFilter<"Transfer"> | string | null
    toStoreId?: StringNullableFilter<"Transfer"> | string | null
    status?: EnumTransferStatusFilter<"Transfer"> | $Enums.TransferStatus
    transferType?: EnumTransferTypeFilter<"Transfer"> | $Enums.TransferType
    priority?: EnumTransferPriorityFilter<"Transfer"> | $Enums.TransferPriority
    requestedById?: StringNullableFilter<"Transfer"> | string | null
    approvedById?: StringNullableFilter<"Transfer"> | string | null
    rejectedById?: StringNullableFilter<"Transfer"> | string | null
    completedById?: StringNullableFilter<"Transfer"> | string | null
    requestedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    approvedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    rejectedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    expectedDeliveryDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    actualDeliveryDate?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    shippingMethod?: StringNullableFilter<"Transfer"> | string | null
    trackingNumber?: StringNullableFilter<"Transfer"> | string | null
    totalItems?: IntFilter<"Transfer"> | number
    totalCost?: FloatFilter<"Transfer"> | number
    totalRetail?: FloatFilter<"Transfer"> | number
    rejectionReason?: StringNullableFilter<"Transfer"> | string | null
    notes?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
  }

  export type TransferUpsertWithWhereUniqueWithoutToWarehouseInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutToWarehouseInput, TransferUncheckedUpdateWithoutToWarehouseInput>
    create: XOR<TransferCreateWithoutToWarehouseInput, TransferUncheckedCreateWithoutToWarehouseInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutToWarehouseInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutToWarehouseInput, TransferUncheckedUpdateWithoutToWarehouseInput>
  }

  export type TransferUpdateManyWithWhereWithoutToWarehouseInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutToWarehouseInput>
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutWarehouseInput, PurchaseOrderUncheckedUpdateWithoutWarehouseInput>
    create: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutWarehouseInput, PurchaseOrderUncheckedUpdateWithoutWarehouseInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutWarehouseInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    orderNumber?: StringFilter<"PurchaseOrder"> | string
    supplierId?: StringFilter<"PurchaseOrder"> | string
    warehouseId?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expectedDeliveryDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    status?: EnumPurchaseOrderStatusFilter<"PurchaseOrder"> | $Enums.PurchaseOrderStatus
    subtotal?: FloatFilter<"PurchaseOrder"> | number
    taxAmount?: FloatFilter<"PurchaseOrder"> | number
    totalAmount?: FloatFilter<"PurchaseOrder"> | number
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdById?: StringNullableFilter<"PurchaseOrder"> | string | null
    approvedById?: StringNullableFilter<"PurchaseOrder"> | string | null
    receivedById?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
  }

  export type QualityControlUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: QualityControlWhereUniqueInput
    update: XOR<QualityControlUpdateWithoutWarehouseInput, QualityControlUncheckedUpdateWithoutWarehouseInput>
    create: XOR<QualityControlCreateWithoutWarehouseInput, QualityControlUncheckedCreateWithoutWarehouseInput>
  }

  export type QualityControlUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: QualityControlWhereUniqueInput
    data: XOR<QualityControlUpdateWithoutWarehouseInput, QualityControlUncheckedUpdateWithoutWarehouseInput>
  }

  export type QualityControlUpdateManyWithWhereWithoutWarehouseInput = {
    where: QualityControlScalarWhereInput
    data: XOR<QualityControlUpdateManyMutationInput, QualityControlUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type AuditUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: AuditWhereUniqueInput
    update: XOR<AuditUpdateWithoutWarehouseInput, AuditUncheckedUpdateWithoutWarehouseInput>
    create: XOR<AuditCreateWithoutWarehouseInput, AuditUncheckedCreateWithoutWarehouseInput>
  }

  export type AuditUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: AuditWhereUniqueInput
    data: XOR<AuditUpdateWithoutWarehouseInput, AuditUncheckedUpdateWithoutWarehouseInput>
  }

  export type AuditUpdateManyWithWhereWithoutWarehouseInput = {
    where: AuditScalarWhereInput
    data: XOR<AuditUpdateManyMutationInput, AuditUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type WarehouseCreateWithoutZonesInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
    qualityControls?: QualityControlCreateNestedManyWithoutWarehouseInput
    audits?: AuditCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutZonesInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutWarehouseInput
    audits?: AuditUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutZonesInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutZonesInput, WarehouseUncheckedCreateWithoutZonesInput>
  }

  export type WarehouseAisleCreateWithoutZoneInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    shelves?: WarehouseShelfCreateNestedManyWithoutAisleInput
  }

  export type WarehouseAisleUncheckedCreateWithoutZoneInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    shelves?: WarehouseShelfUncheckedCreateNestedManyWithoutAisleInput
  }

  export type WarehouseAisleCreateOrConnectWithoutZoneInput = {
    where: WarehouseAisleWhereUniqueInput
    create: XOR<WarehouseAisleCreateWithoutZoneInput, WarehouseAisleUncheckedCreateWithoutZoneInput>
  }

  export type WarehouseAisleCreateManyZoneInputEnvelope = {
    data: WarehouseAisleCreateManyZoneInput | WarehouseAisleCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseUpsertWithoutZonesInput = {
    update: XOR<WarehouseUpdateWithoutZonesInput, WarehouseUncheckedUpdateWithoutZonesInput>
    create: XOR<WarehouseCreateWithoutZonesInput, WarehouseUncheckedCreateWithoutZonesInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutZonesInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutZonesInput, WarehouseUncheckedUpdateWithoutZonesInput>
  }

  export type WarehouseUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
    qualityControls?: QualityControlUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseAisleUpsertWithWhereUniqueWithoutZoneInput = {
    where: WarehouseAisleWhereUniqueInput
    update: XOR<WarehouseAisleUpdateWithoutZoneInput, WarehouseAisleUncheckedUpdateWithoutZoneInput>
    create: XOR<WarehouseAisleCreateWithoutZoneInput, WarehouseAisleUncheckedCreateWithoutZoneInput>
  }

  export type WarehouseAisleUpdateWithWhereUniqueWithoutZoneInput = {
    where: WarehouseAisleWhereUniqueInput
    data: XOR<WarehouseAisleUpdateWithoutZoneInput, WarehouseAisleUncheckedUpdateWithoutZoneInput>
  }

  export type WarehouseAisleUpdateManyWithWhereWithoutZoneInput = {
    where: WarehouseAisleScalarWhereInput
    data: XOR<WarehouseAisleUpdateManyMutationInput, WarehouseAisleUncheckedUpdateManyWithoutZoneInput>
  }

  export type WarehouseAisleScalarWhereInput = {
    AND?: WarehouseAisleScalarWhereInput | WarehouseAisleScalarWhereInput[]
    OR?: WarehouseAisleScalarWhereInput[]
    NOT?: WarehouseAisleScalarWhereInput | WarehouseAisleScalarWhereInput[]
    id?: StringFilter<"WarehouseAisle"> | string
    name?: StringFilter<"WarehouseAisle"> | string
    code?: StringFilter<"WarehouseAisle"> | string
    zoneId?: StringFilter<"WarehouseAisle"> | string
    createdAt?: DateTimeFilter<"WarehouseAisle"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseAisle"> | Date | string
  }

  export type WarehouseZoneCreateWithoutAislesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutZonesInput
  }

  export type WarehouseZoneUncheckedCreateWithoutAislesInput = {
    id?: string
    name: string
    code: string
    warehouseId: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseZoneCreateOrConnectWithoutAislesInput = {
    where: WarehouseZoneWhereUniqueInput
    create: XOR<WarehouseZoneCreateWithoutAislesInput, WarehouseZoneUncheckedCreateWithoutAislesInput>
  }

  export type WarehouseShelfCreateWithoutAisleInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bins?: WarehouseBinCreateNestedManyWithoutShelfInput
  }

  export type WarehouseShelfUncheckedCreateWithoutAisleInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bins?: WarehouseBinUncheckedCreateNestedManyWithoutShelfInput
  }

  export type WarehouseShelfCreateOrConnectWithoutAisleInput = {
    where: WarehouseShelfWhereUniqueInput
    create: XOR<WarehouseShelfCreateWithoutAisleInput, WarehouseShelfUncheckedCreateWithoutAisleInput>
  }

  export type WarehouseShelfCreateManyAisleInputEnvelope = {
    data: WarehouseShelfCreateManyAisleInput | WarehouseShelfCreateManyAisleInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseZoneUpsertWithoutAislesInput = {
    update: XOR<WarehouseZoneUpdateWithoutAislesInput, WarehouseZoneUncheckedUpdateWithoutAislesInput>
    create: XOR<WarehouseZoneCreateWithoutAislesInput, WarehouseZoneUncheckedCreateWithoutAislesInput>
    where?: WarehouseZoneWhereInput
  }

  export type WarehouseZoneUpdateToOneWithWhereWithoutAislesInput = {
    where?: WarehouseZoneWhereInput
    data: XOR<WarehouseZoneUpdateWithoutAislesInput, WarehouseZoneUncheckedUpdateWithoutAislesInput>
  }

  export type WarehouseZoneUpdateWithoutAislesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutZonesNestedInput
  }

  export type WarehouseZoneUncheckedUpdateWithoutAislesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseShelfUpsertWithWhereUniqueWithoutAisleInput = {
    where: WarehouseShelfWhereUniqueInput
    update: XOR<WarehouseShelfUpdateWithoutAisleInput, WarehouseShelfUncheckedUpdateWithoutAisleInput>
    create: XOR<WarehouseShelfCreateWithoutAisleInput, WarehouseShelfUncheckedCreateWithoutAisleInput>
  }

  export type WarehouseShelfUpdateWithWhereUniqueWithoutAisleInput = {
    where: WarehouseShelfWhereUniqueInput
    data: XOR<WarehouseShelfUpdateWithoutAisleInput, WarehouseShelfUncheckedUpdateWithoutAisleInput>
  }

  export type WarehouseShelfUpdateManyWithWhereWithoutAisleInput = {
    where: WarehouseShelfScalarWhereInput
    data: XOR<WarehouseShelfUpdateManyMutationInput, WarehouseShelfUncheckedUpdateManyWithoutAisleInput>
  }

  export type WarehouseShelfScalarWhereInput = {
    AND?: WarehouseShelfScalarWhereInput | WarehouseShelfScalarWhereInput[]
    OR?: WarehouseShelfScalarWhereInput[]
    NOT?: WarehouseShelfScalarWhereInput | WarehouseShelfScalarWhereInput[]
    id?: StringFilter<"WarehouseShelf"> | string
    name?: StringFilter<"WarehouseShelf"> | string
    code?: StringFilter<"WarehouseShelf"> | string
    aisleId?: StringFilter<"WarehouseShelf"> | string
    createdAt?: DateTimeFilter<"WarehouseShelf"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseShelf"> | Date | string
  }

  export type WarehouseAisleCreateWithoutShelvesInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    zone: WarehouseZoneCreateNestedOneWithoutAislesInput
  }

  export type WarehouseAisleUncheckedCreateWithoutShelvesInput = {
    id?: string
    name: string
    code: string
    zoneId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseAisleCreateOrConnectWithoutShelvesInput = {
    where: WarehouseAisleWhereUniqueInput
    create: XOR<WarehouseAisleCreateWithoutShelvesInput, WarehouseAisleUncheckedCreateWithoutShelvesInput>
  }

  export type WarehouseBinCreateWithoutShelfInput = {
    id?: string
    name: string
    code: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutBinInput
  }

  export type WarehouseBinUncheckedCreateWithoutShelfInput = {
    id?: string
    name: string
    code: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutBinInput
  }

  export type WarehouseBinCreateOrConnectWithoutShelfInput = {
    where: WarehouseBinWhereUniqueInput
    create: XOR<WarehouseBinCreateWithoutShelfInput, WarehouseBinUncheckedCreateWithoutShelfInput>
  }

  export type WarehouseBinCreateManyShelfInputEnvelope = {
    data: WarehouseBinCreateManyShelfInput | WarehouseBinCreateManyShelfInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseAisleUpsertWithoutShelvesInput = {
    update: XOR<WarehouseAisleUpdateWithoutShelvesInput, WarehouseAisleUncheckedUpdateWithoutShelvesInput>
    create: XOR<WarehouseAisleCreateWithoutShelvesInput, WarehouseAisleUncheckedCreateWithoutShelvesInput>
    where?: WarehouseAisleWhereInput
  }

  export type WarehouseAisleUpdateToOneWithWhereWithoutShelvesInput = {
    where?: WarehouseAisleWhereInput
    data: XOR<WarehouseAisleUpdateWithoutShelvesInput, WarehouseAisleUncheckedUpdateWithoutShelvesInput>
  }

  export type WarehouseAisleUpdateWithoutShelvesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: WarehouseZoneUpdateOneRequiredWithoutAislesNestedInput
  }

  export type WarehouseAisleUncheckedUpdateWithoutShelvesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseBinUpsertWithWhereUniqueWithoutShelfInput = {
    where: WarehouseBinWhereUniqueInput
    update: XOR<WarehouseBinUpdateWithoutShelfInput, WarehouseBinUncheckedUpdateWithoutShelfInput>
    create: XOR<WarehouseBinCreateWithoutShelfInput, WarehouseBinUncheckedCreateWithoutShelfInput>
  }

  export type WarehouseBinUpdateWithWhereUniqueWithoutShelfInput = {
    where: WarehouseBinWhereUniqueInput
    data: XOR<WarehouseBinUpdateWithoutShelfInput, WarehouseBinUncheckedUpdateWithoutShelfInput>
  }

  export type WarehouseBinUpdateManyWithWhereWithoutShelfInput = {
    where: WarehouseBinScalarWhereInput
    data: XOR<WarehouseBinUpdateManyMutationInput, WarehouseBinUncheckedUpdateManyWithoutShelfInput>
  }

  export type WarehouseBinScalarWhereInput = {
    AND?: WarehouseBinScalarWhereInput | WarehouseBinScalarWhereInput[]
    OR?: WarehouseBinScalarWhereInput[]
    NOT?: WarehouseBinScalarWhereInput | WarehouseBinScalarWhereInput[]
    id?: StringFilter<"WarehouseBin"> | string
    name?: StringFilter<"WarehouseBin"> | string
    code?: StringFilter<"WarehouseBin"> | string
    shelfId?: StringFilter<"WarehouseBin"> | string
    capacity?: IntNullableFilter<"WarehouseBin"> | number | null
    createdAt?: DateTimeFilter<"WarehouseBin"> | Date | string
    updatedAt?: DateTimeFilter<"WarehouseBin"> | Date | string
  }

  export type WarehouseShelfCreateWithoutBinsInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aisle: WarehouseAisleCreateNestedOneWithoutShelvesInput
  }

  export type WarehouseShelfUncheckedCreateWithoutBinsInput = {
    id?: string
    name: string
    code: string
    aisleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseShelfCreateOrConnectWithoutBinsInput = {
    where: WarehouseShelfWhereUniqueInput
    create: XOR<WarehouseShelfCreateWithoutBinsInput, WarehouseShelfUncheckedCreateWithoutBinsInput>
  }

  export type InventoryItemCreateWithoutBinInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    store?: StoreCreateNestedOneWithoutInventoryItemsInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryItemsInput
    saleItems?: SaleItemCreateNestedManyWithoutInventoryItemInput
    auditItems?: AuditItemCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutBinInput = {
    id?: string
    productId: string
    storeId?: string | null
    warehouseId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutBinInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutBinInput, InventoryItemUncheckedCreateWithoutBinInput>
  }

  export type InventoryItemCreateManyBinInputEnvelope = {
    data: InventoryItemCreateManyBinInput | InventoryItemCreateManyBinInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseShelfUpsertWithoutBinsInput = {
    update: XOR<WarehouseShelfUpdateWithoutBinsInput, WarehouseShelfUncheckedUpdateWithoutBinsInput>
    create: XOR<WarehouseShelfCreateWithoutBinsInput, WarehouseShelfUncheckedCreateWithoutBinsInput>
    where?: WarehouseShelfWhereInput
  }

  export type WarehouseShelfUpdateToOneWithWhereWithoutBinsInput = {
    where?: WarehouseShelfWhereInput
    data: XOR<WarehouseShelfUpdateWithoutBinsInput, WarehouseShelfUncheckedUpdateWithoutBinsInput>
  }

  export type WarehouseShelfUpdateWithoutBinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aisle?: WarehouseAisleUpdateOneRequiredWithoutShelvesNestedInput
  }

  export type WarehouseShelfUncheckedUpdateWithoutBinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    aisleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutBinInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutBinInput, InventoryItemUncheckedUpdateWithoutBinInput>
    create: XOR<InventoryItemCreateWithoutBinInput, InventoryItemUncheckedCreateWithoutBinInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutBinInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutBinInput, InventoryItemUncheckedUpdateWithoutBinInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutBinInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutBinInput>
  }

  export type UserCreateWithoutWarehouseStaffInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlCreateNestedManyWithoutInspectedByInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWarehouseStaffInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnUncheckedCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlUncheckedCreateNestedManyWithoutInspectedByInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWarehouseStaffInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWarehouseStaffInput, UserUncheckedCreateWithoutWarehouseStaffInput>
  }

  export type WarehouseCreateWithoutStaffInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
    qualityControls?: QualityControlCreateNestedManyWithoutWarehouseInput
    audits?: AuditCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutStaffInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutWarehouseInput
    audits?: AuditUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutStaffInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutStaffInput, WarehouseUncheckedCreateWithoutStaffInput>
  }

  export type UserUpsertWithoutWarehouseStaffInput = {
    update: XOR<UserUpdateWithoutWarehouseStaffInput, UserUncheckedUpdateWithoutWarehouseStaffInput>
    create: XOR<UserCreateWithoutWarehouseStaffInput, UserUncheckedCreateWithoutWarehouseStaffInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWarehouseStaffInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWarehouseStaffInput, UserUncheckedUpdateWithoutWarehouseStaffInput>
  }

  export type UserUpdateWithoutWarehouseStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUpdateManyWithoutInspectedByNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWarehouseStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUncheckedUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUncheckedUpdateManyWithoutInspectedByNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WarehouseUpsertWithoutStaffInput = {
    update: XOR<WarehouseUpdateWithoutStaffInput, WarehouseUncheckedUpdateWithoutStaffInput>
    create: XOR<WarehouseCreateWithoutStaffInput, WarehouseUncheckedCreateWithoutStaffInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutStaffInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutStaffInput, WarehouseUncheckedUpdateWithoutStaffInput>
  }

  export type WarehouseUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
    qualityControls?: QualityControlUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type InventoryItemCreateWithoutStoreInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryItemsInput
    bin?: WarehouseBinCreateNestedOneWithoutInventoryItemsInput
    saleItems?: SaleItemCreateNestedManyWithoutInventoryItemInput
    auditItems?: AuditItemCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutStoreInput = {
    id?: string
    productId: string
    warehouseId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutStoreInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutStoreInput, InventoryItemUncheckedCreateWithoutStoreInput>
  }

  export type InventoryItemCreateManyStoreInputEnvelope = {
    data: InventoryItemCreateManyStoreInput | InventoryItemCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type SaleCreateWithoutStoreInput = {
    id?: string
    receiptNumber: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutSalesInput
    createdBy: UserCreateNestedOneWithoutCreatedSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
    payments?: PaymentCreateNestedManyWithoutSaleInput
    returns?: ReturnCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutStoreInput = {
    id?: string
    receiptNumber: string
    customerId?: string | null
    createdById: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: PaymentUncheckedCreateNestedManyWithoutSaleInput
    returns?: ReturnUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutStoreInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput>
  }

  export type SaleCreateManyStoreInputEnvelope = {
    data: SaleCreateManyStoreInput | SaleCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type ReturnCreateWithoutStoreInput = {
    id?: string
    returnNumber: string
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sale?: SaleCreateNestedOneWithoutReturnsInput
    customer?: CustomerCreateNestedOneWithoutReturnsInput
    processedBy: UserCreateNestedOneWithoutProcessedReturnsInput
    items?: ReturnItemCreateNestedManyWithoutReturnInput
    qualityControls?: QualityControlCreateNestedManyWithoutReturnInput
  }

  export type ReturnUncheckedCreateWithoutStoreInput = {
    id?: string
    returnNumber: string
    saleId?: string | null
    customerId?: string | null
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    processedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ReturnItemUncheckedCreateNestedManyWithoutReturnInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutReturnInput
  }

  export type ReturnCreateOrConnectWithoutStoreInput = {
    where: ReturnWhereUniqueInput
    create: XOR<ReturnCreateWithoutStoreInput, ReturnUncheckedCreateWithoutStoreInput>
  }

  export type ReturnCreateManyStoreInputEnvelope = {
    data: ReturnCreateManyStoreInput | ReturnCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StoreStaffCreateWithoutStoreInput = {
    id?: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStoreStaffInput
  }

  export type StoreStaffUncheckedCreateWithoutStoreInput = {
    id?: string
    userId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStaffCreateOrConnectWithoutStoreInput = {
    where: StoreStaffWhereUniqueInput
    create: XOR<StoreStaffCreateWithoutStoreInput, StoreStaffUncheckedCreateWithoutStoreInput>
  }

  export type StoreStaffCreateManyStoreInputEnvelope = {
    data: StoreStaffCreateManyStoreInput | StoreStaffCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutFromStoreInput = {
    id?: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromWarehouse?: WarehouseCreateNestedOneWithoutTransfersFromInput
    toWarehouse?: WarehouseCreateNestedOneWithoutTransfersToInput
    toStore?: StoreCreateNestedOneWithoutTransfersToInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
    documents?: TransferDocumentCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutFromStoreInput = {
    id?: string
    transferNumber: string
    fromWarehouseId?: string | null
    toWarehouseId?: string | null
    toStoreId?: string | null
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
    documents?: TransferDocumentUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutFromStoreInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutFromStoreInput, TransferUncheckedCreateWithoutFromStoreInput>
  }

  export type TransferCreateManyFromStoreInputEnvelope = {
    data: TransferCreateManyFromStoreInput | TransferCreateManyFromStoreInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutToStoreInput = {
    id?: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromWarehouse?: WarehouseCreateNestedOneWithoutTransfersFromInput
    fromStore?: StoreCreateNestedOneWithoutTransfersFromInput
    toWarehouse?: WarehouseCreateNestedOneWithoutTransfersToInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
    documents?: TransferDocumentCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutToStoreInput = {
    id?: string
    transferNumber: string
    fromWarehouseId?: string | null
    fromStoreId?: string | null
    toWarehouseId?: string | null
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
    documents?: TransferDocumentUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutToStoreInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutToStoreInput, TransferUncheckedCreateWithoutToStoreInput>
  }

  export type TransferCreateManyToStoreInputEnvelope = {
    data: TransferCreateManyToStoreInput | TransferCreateManyToStoreInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutStoreInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutStoreInput, InventoryItemUncheckedUpdateWithoutStoreInput>
    create: XOR<InventoryItemCreateWithoutStoreInput, InventoryItemUncheckedCreateWithoutStoreInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutStoreInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutStoreInput, InventoryItemUncheckedUpdateWithoutStoreInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutStoreInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutStoreInput>
  }

  export type SaleUpsertWithWhereUniqueWithoutStoreInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutStoreInput, SaleUncheckedUpdateWithoutStoreInput>
    create: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutStoreInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutStoreInput, SaleUncheckedUpdateWithoutStoreInput>
  }

  export type SaleUpdateManyWithWhereWithoutStoreInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutStoreInput>
  }

  export type ReturnUpsertWithWhereUniqueWithoutStoreInput = {
    where: ReturnWhereUniqueInput
    update: XOR<ReturnUpdateWithoutStoreInput, ReturnUncheckedUpdateWithoutStoreInput>
    create: XOR<ReturnCreateWithoutStoreInput, ReturnUncheckedCreateWithoutStoreInput>
  }

  export type ReturnUpdateWithWhereUniqueWithoutStoreInput = {
    where: ReturnWhereUniqueInput
    data: XOR<ReturnUpdateWithoutStoreInput, ReturnUncheckedUpdateWithoutStoreInput>
  }

  export type ReturnUpdateManyWithWhereWithoutStoreInput = {
    where: ReturnScalarWhereInput
    data: XOR<ReturnUpdateManyMutationInput, ReturnUncheckedUpdateManyWithoutStoreInput>
  }

  export type StoreStaffUpsertWithWhereUniqueWithoutStoreInput = {
    where: StoreStaffWhereUniqueInput
    update: XOR<StoreStaffUpdateWithoutStoreInput, StoreStaffUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreStaffCreateWithoutStoreInput, StoreStaffUncheckedCreateWithoutStoreInput>
  }

  export type StoreStaffUpdateWithWhereUniqueWithoutStoreInput = {
    where: StoreStaffWhereUniqueInput
    data: XOR<StoreStaffUpdateWithoutStoreInput, StoreStaffUncheckedUpdateWithoutStoreInput>
  }

  export type StoreStaffUpdateManyWithWhereWithoutStoreInput = {
    where: StoreStaffScalarWhereInput
    data: XOR<StoreStaffUpdateManyMutationInput, StoreStaffUncheckedUpdateManyWithoutStoreInput>
  }

  export type StoreStaffScalarWhereInput = {
    AND?: StoreStaffScalarWhereInput | StoreStaffScalarWhereInput[]
    OR?: StoreStaffScalarWhereInput[]
    NOT?: StoreStaffScalarWhereInput | StoreStaffScalarWhereInput[]
    id?: StringFilter<"StoreStaff"> | string
    userId?: StringFilter<"StoreStaff"> | string
    storeId?: StringFilter<"StoreStaff"> | string
    position?: StringNullableFilter<"StoreStaff"> | string | null
    isManager?: BoolFilter<"StoreStaff"> | boolean
    createdAt?: DateTimeFilter<"StoreStaff"> | Date | string
    updatedAt?: DateTimeFilter<"StoreStaff"> | Date | string
  }

  export type TransferUpsertWithWhereUniqueWithoutFromStoreInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutFromStoreInput, TransferUncheckedUpdateWithoutFromStoreInput>
    create: XOR<TransferCreateWithoutFromStoreInput, TransferUncheckedCreateWithoutFromStoreInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutFromStoreInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutFromStoreInput, TransferUncheckedUpdateWithoutFromStoreInput>
  }

  export type TransferUpdateManyWithWhereWithoutFromStoreInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutFromStoreInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutToStoreInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutToStoreInput, TransferUncheckedUpdateWithoutToStoreInput>
    create: XOR<TransferCreateWithoutToStoreInput, TransferUncheckedCreateWithoutToStoreInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutToStoreInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutToStoreInput, TransferUncheckedUpdateWithoutToStoreInput>
  }

  export type TransferUpdateManyWithWhereWithoutToStoreInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutToStoreInput>
  }

  export type UserCreateWithoutStoreStaffInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStoreStaffInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnUncheckedCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlUncheckedCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStoreStaffInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoreStaffInput, UserUncheckedCreateWithoutStoreStaffInput>
  }

  export type StoreCreateWithoutStaffInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    returns?: ReturnCreateNestedManyWithoutStoreInput
    transfersFrom?: TransferCreateNestedManyWithoutFromStoreInput
    transfersTo?: TransferCreateNestedManyWithoutToStoreInput
  }

  export type StoreUncheckedCreateWithoutStaffInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    returns?: ReturnUncheckedCreateNestedManyWithoutStoreInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromStoreInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToStoreInput
  }

  export type StoreCreateOrConnectWithoutStaffInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStaffInput, StoreUncheckedCreateWithoutStaffInput>
  }

  export type UserUpsertWithoutStoreStaffInput = {
    update: XOR<UserUpdateWithoutStoreStaffInput, UserUncheckedUpdateWithoutStoreStaffInput>
    create: XOR<UserCreateWithoutStoreStaffInput, UserUncheckedCreateWithoutStoreStaffInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoreStaffInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoreStaffInput, UserUncheckedUpdateWithoutStoreStaffInput>
  }

  export type UserUpdateWithoutStoreStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStoreStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUncheckedUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUncheckedUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StoreUpsertWithoutStaffInput = {
    update: XOR<StoreUpdateWithoutStaffInput, StoreUncheckedUpdateWithoutStaffInput>
    create: XOR<StoreCreateWithoutStaffInput, StoreUncheckedCreateWithoutStaffInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutStaffInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutStaffInput, StoreUncheckedUpdateWithoutStaffInput>
  }

  export type StoreUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    returns?: ReturnUpdateManyWithoutStoreNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromStoreNestedInput
    transfersTo?: TransferUpdateManyWithoutToStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    returns?: ReturnUncheckedUpdateManyWithoutStoreNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromStoreNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToStoreNestedInput
  }

  export type ProductCreateWithoutSupplierInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSupplierInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    categoryId?: string | null
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemUncheckedCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSupplierInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput>
  }

  export type ProductCreateManySupplierInputEnvelope = {
    data: ProductCreateManySupplierInput | ProductCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type SupplierContractCreateWithoutSupplierInput = {
    id?: string
    contractNumber: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    renewalDate?: Date | string | null
    value?: number | null
    terms?: string | null
    paymentTerms?: string | null
    status?: $Enums.ContractStatus
    documentUrl?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierContractUncheckedCreateWithoutSupplierInput = {
    id?: string
    contractNumber: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    renewalDate?: Date | string | null
    value?: number | null
    terms?: string | null
    paymentTerms?: string | null
    status?: $Enums.ContractStatus
    documentUrl?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierContractCreateOrConnectWithoutSupplierInput = {
    where: SupplierContractWhereUniqueInput
    create: XOR<SupplierContractCreateWithoutSupplierInput, SupplierContractUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierContractCreateManySupplierInputEnvelope = {
    data: SupplierContractCreateManySupplierInput | SupplierContractCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutSupplierInput = {
    id?: string
    orderNumber: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    status?: $Enums.PurchaseOrderStatus
    subtotal?: number
    taxAmount?: number
    totalAmount?: number
    notes?: string | null
    createdById?: string | null
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    qualityControls?: QualityControlCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutSupplierInput = {
    id?: string
    orderNumber: string
    warehouseId: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    status?: $Enums.PurchaseOrderStatus
    subtotal?: number
    taxAmount?: number
    totalAmount?: number
    notes?: string | null
    createdById?: string | null
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderCreateManySupplierInputEnvelope = {
    data: PurchaseOrderCreateManySupplierInput | PurchaseOrderCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type SupplierPerformanceMetricCreateWithoutSupplierInput = {
    id?: string
    metricType: $Enums.PerformanceMetricType
    date: Date | string
    value: number
    notes?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierPerformanceMetricUncheckedCreateWithoutSupplierInput = {
    id?: string
    metricType: $Enums.PerformanceMetricType
    date: Date | string
    value: number
    notes?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierPerformanceMetricCreateOrConnectWithoutSupplierInput = {
    where: SupplierPerformanceMetricWhereUniqueInput
    create: XOR<SupplierPerformanceMetricCreateWithoutSupplierInput, SupplierPerformanceMetricUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierPerformanceMetricCreateManySupplierInputEnvelope = {
    data: SupplierPerformanceMetricCreateManySupplierInput | SupplierPerformanceMetricCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSupplierInput, ProductUncheckedUpdateWithoutSupplierInput>
    create: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSupplierInput, ProductUncheckedUpdateWithoutSupplierInput>
  }

  export type ProductUpdateManyWithWhereWithoutSupplierInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutSupplierInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    sku?: StringFilter<"Product"> | string
    barcode?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    unit?: StringFilter<"Product"> | string
    categoryId?: StringNullableFilter<"Product"> | string | null
    supplierId?: StringNullableFilter<"Product"> | string | null
    costPrice?: FloatFilter<"Product"> | number
    wholesalePrice?: FloatFilter<"Product"> | number
    retailPrice?: FloatFilter<"Product"> | number
    minStockLevel?: IntFilter<"Product"> | number
    reorderPoint?: IntFilter<"Product"> | number
    leadTime?: IntNullableFilter<"Product"> | number | null
    condition?: EnumProductConditionFilter<"Product"> | $Enums.ProductCondition
    createdById?: StringNullableFilter<"Product"> | string | null
    updatedById?: StringNullableFilter<"Product"> | string | null
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type SupplierContractUpsertWithWhereUniqueWithoutSupplierInput = {
    where: SupplierContractWhereUniqueInput
    update: XOR<SupplierContractUpdateWithoutSupplierInput, SupplierContractUncheckedUpdateWithoutSupplierInput>
    create: XOR<SupplierContractCreateWithoutSupplierInput, SupplierContractUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierContractUpdateWithWhereUniqueWithoutSupplierInput = {
    where: SupplierContractWhereUniqueInput
    data: XOR<SupplierContractUpdateWithoutSupplierInput, SupplierContractUncheckedUpdateWithoutSupplierInput>
  }

  export type SupplierContractUpdateManyWithWhereWithoutSupplierInput = {
    where: SupplierContractScalarWhereInput
    data: XOR<SupplierContractUpdateManyMutationInput, SupplierContractUncheckedUpdateManyWithoutSupplierInput>
  }

  export type SupplierContractScalarWhereInput = {
    AND?: SupplierContractScalarWhereInput | SupplierContractScalarWhereInput[]
    OR?: SupplierContractScalarWhereInput[]
    NOT?: SupplierContractScalarWhereInput | SupplierContractScalarWhereInput[]
    id?: StringFilter<"SupplierContract"> | string
    supplierId?: StringFilter<"SupplierContract"> | string
    contractNumber?: StringFilter<"SupplierContract"> | string
    title?: StringFilter<"SupplierContract"> | string
    description?: StringNullableFilter<"SupplierContract"> | string | null
    startDate?: DateTimeFilter<"SupplierContract"> | Date | string
    endDate?: DateTimeNullableFilter<"SupplierContract"> | Date | string | null
    renewalDate?: DateTimeNullableFilter<"SupplierContract"> | Date | string | null
    value?: FloatNullableFilter<"SupplierContract"> | number | null
    terms?: StringNullableFilter<"SupplierContract"> | string | null
    paymentTerms?: StringNullableFilter<"SupplierContract"> | string | null
    status?: EnumContractStatusFilter<"SupplierContract"> | $Enums.ContractStatus
    documentUrl?: StringNullableFilter<"SupplierContract"> | string | null
    createdById?: StringNullableFilter<"SupplierContract"> | string | null
    updatedById?: StringNullableFilter<"SupplierContract"> | string | null
    createdAt?: DateTimeFilter<"SupplierContract"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierContract"> | Date | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutSupplierInput>
  }

  export type SupplierPerformanceMetricUpsertWithWhereUniqueWithoutSupplierInput = {
    where: SupplierPerformanceMetricWhereUniqueInput
    update: XOR<SupplierPerformanceMetricUpdateWithoutSupplierInput, SupplierPerformanceMetricUncheckedUpdateWithoutSupplierInput>
    create: XOR<SupplierPerformanceMetricCreateWithoutSupplierInput, SupplierPerformanceMetricUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierPerformanceMetricUpdateWithWhereUniqueWithoutSupplierInput = {
    where: SupplierPerformanceMetricWhereUniqueInput
    data: XOR<SupplierPerformanceMetricUpdateWithoutSupplierInput, SupplierPerformanceMetricUncheckedUpdateWithoutSupplierInput>
  }

  export type SupplierPerformanceMetricUpdateManyWithWhereWithoutSupplierInput = {
    where: SupplierPerformanceMetricScalarWhereInput
    data: XOR<SupplierPerformanceMetricUpdateManyMutationInput, SupplierPerformanceMetricUncheckedUpdateManyWithoutSupplierInput>
  }

  export type SupplierPerformanceMetricScalarWhereInput = {
    AND?: SupplierPerformanceMetricScalarWhereInput | SupplierPerformanceMetricScalarWhereInput[]
    OR?: SupplierPerformanceMetricScalarWhereInput[]
    NOT?: SupplierPerformanceMetricScalarWhereInput | SupplierPerformanceMetricScalarWhereInput[]
    id?: StringFilter<"SupplierPerformanceMetric"> | string
    supplierId?: StringFilter<"SupplierPerformanceMetric"> | string
    metricType?: EnumPerformanceMetricTypeFilter<"SupplierPerformanceMetric"> | $Enums.PerformanceMetricType
    date?: DateTimeFilter<"SupplierPerformanceMetric"> | Date | string
    value?: FloatFilter<"SupplierPerformanceMetric"> | number
    notes?: StringNullableFilter<"SupplierPerformanceMetric"> | string | null
    createdById?: StringNullableFilter<"SupplierPerformanceMetric"> | string | null
    createdAt?: DateTimeFilter<"SupplierPerformanceMetric"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierPerformanceMetric"> | Date | string
  }

  export type SupplierCreateWithoutContractsInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    rating?: number | null
    isActive?: boolean
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    performanceMetrics?: SupplierPerformanceMetricCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutContractsInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    rating?: number | null
    isActive?: boolean
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    performanceMetrics?: SupplierPerformanceMetricUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutContractsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutContractsInput, SupplierUncheckedCreateWithoutContractsInput>
  }

  export type SupplierUpsertWithoutContractsInput = {
    update: XOR<SupplierUpdateWithoutContractsInput, SupplierUncheckedUpdateWithoutContractsInput>
    create: XOR<SupplierCreateWithoutContractsInput, SupplierUncheckedCreateWithoutContractsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutContractsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutContractsInput, SupplierUncheckedUpdateWithoutContractsInput>
  }

  export type SupplierUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    performanceMetrics?: SupplierPerformanceMetricUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    performanceMetrics?: SupplierPerformanceMetricUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateWithoutPerformanceMetricsInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    rating?: number | null
    isActive?: boolean
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutSupplierInput
    contracts?: SupplierContractCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutPerformanceMetricsInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    rating?: number | null
    isActive?: boolean
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    contracts?: SupplierContractUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutPerformanceMetricsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPerformanceMetricsInput, SupplierUncheckedCreateWithoutPerformanceMetricsInput>
  }

  export type SupplierUpsertWithoutPerformanceMetricsInput = {
    update: XOR<SupplierUpdateWithoutPerformanceMetricsInput, SupplierUncheckedUpdateWithoutPerformanceMetricsInput>
    create: XOR<SupplierCreateWithoutPerformanceMetricsInput, SupplierUncheckedCreateWithoutPerformanceMetricsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPerformanceMetricsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPerformanceMetricsInput, SupplierUncheckedUpdateWithoutPerformanceMetricsInput>
  }

  export type SupplierUpdateWithoutPerformanceMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutSupplierNestedInput
    contracts?: SupplierContractUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPerformanceMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    contracts?: SupplierContractUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    rating?: number | null
    isActive?: boolean
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutSupplierInput
    contracts?: SupplierContractCreateNestedManyWithoutSupplierInput
    performanceMetrics?: SupplierPerformanceMetricCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    rating?: number | null
    isActive?: boolean
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    contracts?: SupplierContractUncheckedCreateNestedManyWithoutSupplierInput
    performanceMetrics?: SupplierPerformanceMetricUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutPurchaseOrdersInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type WarehouseCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    qualityControls?: QualityControlCreateNestedManyWithoutWarehouseInput
    audits?: AuditCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutWarehouseInput
    audits?: AuditUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutPurchaseOrdersInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutPurchaseOrdersInput, WarehouseUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type PurchaseOrderItemCreateWithoutPurchaseOrderInput = {
    id?: string
    quantity: number
    unitPrice: number
    totalPrice: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutPurchaseOrderItemsInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    productId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope = {
    data: PurchaseOrderItemCreateManyPurchaseOrderInput | PurchaseOrderItemCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type QualityControlCreateWithoutPurchaseOrderInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutQualityControlsInput
    return?: ReturnCreateNestedOneWithoutQualityControlsInput
    inspectedBy: UserCreateNestedOneWithoutInspectedQCsInput
    items?: QualityControlItemCreateNestedManyWithoutQualityControlInput
  }

  export type QualityControlUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    warehouseId: string
    returnId?: string | null
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    inspectedById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QualityControlItemUncheckedCreateNestedManyWithoutQualityControlInput
  }

  export type QualityControlCreateOrConnectWithoutPurchaseOrderInput = {
    where: QualityControlWhereUniqueInput
    create: XOR<QualityControlCreateWithoutPurchaseOrderInput, QualityControlUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type QualityControlCreateManyPurchaseOrderInputEnvelope = {
    data: QualityControlCreateManyPurchaseOrderInput | QualityControlCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type SupplierUpsertWithoutPurchaseOrdersInput = {
    update: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type SupplierUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutSupplierNestedInput
    contracts?: SupplierContractUpdateManyWithoutSupplierNestedInput
    performanceMetrics?: SupplierPerformanceMetricUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    contracts?: SupplierContractUncheckedUpdateManyWithoutSupplierNestedInput
    performanceMetrics?: SupplierPerformanceMetricUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type WarehouseUpsertWithoutPurchaseOrdersInput = {
    update: XOR<WarehouseUpdateWithoutPurchaseOrdersInput, WarehouseUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<WarehouseCreateWithoutPurchaseOrdersInput, WarehouseUncheckedCreateWithoutPurchaseOrdersInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutPurchaseOrdersInput, WarehouseUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type WarehouseUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    qualityControls?: QualityControlUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemScalarWhereInput = {
    AND?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    OR?: PurchaseOrderItemScalarWhereInput[]
    NOT?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    id?: StringFilter<"PurchaseOrderItem"> | string
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    productId?: StringFilter<"PurchaseOrderItem"> | string
    quantity?: IntFilter<"PurchaseOrderItem"> | number
    unitPrice?: FloatFilter<"PurchaseOrderItem"> | number
    totalPrice?: FloatFilter<"PurchaseOrderItem"> | number
    receivedQuantity?: IntFilter<"PurchaseOrderItem"> | number
    notes?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
  }

  export type QualityControlUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: QualityControlWhereUniqueInput
    update: XOR<QualityControlUpdateWithoutPurchaseOrderInput, QualityControlUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<QualityControlCreateWithoutPurchaseOrderInput, QualityControlUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type QualityControlUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: QualityControlWhereUniqueInput
    data: XOR<QualityControlUpdateWithoutPurchaseOrderInput, QualityControlUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type QualityControlUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: QualityControlScalarWhereInput
    data: XOR<QualityControlUpdateManyMutationInput, QualityControlUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    status?: $Enums.PurchaseOrderStatus
    subtotal?: number
    taxAmount?: number
    totalAmount?: number
    notes?: string | null
    createdById?: string | null
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    warehouse: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
    qualityControls?: QualityControlCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    supplierId: string
    warehouseId: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    status?: $Enums.PurchaseOrderStatus
    subtotal?: number
    taxAmount?: number
    totalAmount?: number
    notes?: string | null
    createdById?: string | null
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutItemsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    qualityControlItems?: QualityControlItemCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    qualityControlItems?: QualityControlItemUncheckedCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchaseOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
  }

  export type PurchaseOrderUpsertWithoutItemsInput = {
    update: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseOrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    qualityControls?: QualityControlUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qualityControls?: QualityControlUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type ProductUpsertWithoutPurchaseOrderItemsInput = {
    update: XOR<ProductUpdateWithoutPurchaseOrderItemsInput, ProductUncheckedUpdateWithoutPurchaseOrderItemsInput>
    create: XOR<ProductCreateWithoutPurchaseOrderItemsInput, ProductUncheckedCreateWithoutPurchaseOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchaseOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchaseOrderItemsInput, ProductUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type ProductUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutProductsNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    qualityControlItems?: QualityControlItemUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qualityControlItems?: QualityControlItemUncheckedUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    priceRules?: CategoryPriceRuleCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    priceRules?: CategoryPriceRuleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type SupplierCreateWithoutProductsInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    rating?: number | null
    isActive?: boolean
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: SupplierContractCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    performanceMetrics?: SupplierPerformanceMetricCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    taxId?: string | null
    paymentTerms?: string | null
    notes?: string | null
    rating?: number | null
    isActive?: boolean
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: SupplierContractUncheckedCreateNestedManyWithoutSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    performanceMetrics?: SupplierPerformanceMetricUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutProductsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
  }

  export type PurchaseOrderItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    unitPrice: number
    totalPrice: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    purchaseOrderId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemCreateOrConnectWithoutProductInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseOrderItemCreateManyProductInputEnvelope = {
    data: PurchaseOrderItemCreateManyProductInput | PurchaseOrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type QualityControlItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    passedQuantity?: number
    failedQuantity?: number
    pendingQuantity?: number
    status?: $Enums.QCItemStatus
    reason?: string | null
    action?: $Enums.QCAction | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    qualityControl: QualityControlCreateNestedOneWithoutItemsInput
  }

  export type QualityControlItemUncheckedCreateWithoutProductInput = {
    id?: string
    qualityControlId: string
    quantity: number
    passedQuantity?: number
    failedQuantity?: number
    pendingQuantity?: number
    status?: $Enums.QCItemStatus
    reason?: string | null
    action?: $Enums.QCAction | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualityControlItemCreateOrConnectWithoutProductInput = {
    where: QualityControlItemWhereUniqueInput
    create: XOR<QualityControlItemCreateWithoutProductInput, QualityControlItemUncheckedCreateWithoutProductInput>
  }

  export type QualityControlItemCreateManyProductInputEnvelope = {
    data: QualityControlItemCreateManyProductInput | QualityControlItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ReturnItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    unitPrice: number
    totalPrice: number
    reason: $Enums.ReturnReason
    condition?: $Enums.ItemCondition
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    return: ReturnCreateNestedOneWithoutItemsInput
    saleItem?: SaleItemCreateNestedOneWithoutReturnItemsInput
  }

  export type ReturnItemUncheckedCreateWithoutProductInput = {
    id?: string
    returnId: string
    saleItemId?: string | null
    quantity: number
    unitPrice: number
    totalPrice: number
    reason: $Enums.ReturnReason
    condition?: $Enums.ItemCondition
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnItemCreateOrConnectWithoutProductInput = {
    where: ReturnItemWhereUniqueInput
    create: XOR<ReturnItemCreateWithoutProductInput, ReturnItemUncheckedCreateWithoutProductInput>
  }

  export type ReturnItemCreateManyProductInputEnvelope = {
    data: ReturnItemCreateManyProductInput | ReturnItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemCreateWithoutProductInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: StoreCreateNestedOneWithoutInventoryItemsInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryItemsInput
    bin?: WarehouseBinCreateNestedOneWithoutInventoryItemsInput
    saleItems?: SaleItemCreateNestedManyWithoutInventoryItemInput
    auditItems?: AuditItemCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutProductInput = {
    id?: string
    storeId?: string | null
    warehouseId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutProductInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput>
  }

  export type InventoryItemCreateManyProductInputEnvelope = {
    data: InventoryItemCreateManyProductInput | InventoryItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SaleItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sale: SaleCreateNestedOneWithoutItemsInput
    inventoryItem: InventoryItemCreateNestedOneWithoutSaleItemsInput
    returnItems?: ReturnItemCreateNestedManyWithoutSaleItemInput
  }

  export type SaleItemUncheckedCreateWithoutProductInput = {
    id?: string
    saleId: string
    inventoryItemId: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    returnItems?: ReturnItemUncheckedCreateNestedManyWithoutSaleItemInput
  }

  export type SaleItemCreateOrConnectWithoutProductInput = {
    where: SaleItemWhereUniqueInput
    create: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput>
  }

  export type SaleItemCreateManyProductInputEnvelope = {
    data: SaleItemCreateManyProductInput | SaleItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type TransferItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    sourceCostPrice: number
    sourceRetailPrice: number
    targetCostPrice: number
    targetRetailPrice: number
    condition?: $Enums.ProductCondition
    adjustmentReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transfer: TransferCreateNestedOneWithoutItemsInput
  }

  export type TransferItemUncheckedCreateWithoutProductInput = {
    id?: string
    transferId: string
    quantity: number
    sourceCostPrice: number
    sourceRetailPrice: number
    targetCostPrice: number
    targetRetailPrice: number
    condition?: $Enums.ProductCondition
    adjustmentReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateOrConnectWithoutProductInput = {
    where: TransferItemWhereUniqueInput
    create: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput>
  }

  export type TransferItemCreateManyProductInputEnvelope = {
    data: TransferItemCreateManyProductInput | TransferItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type AuditItemCreateWithoutProductInput = {
    id?: string
    expectedQuantity: number
    countedQuantity?: number | null
    discrepancy?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    countedById?: string | null
    countedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutItemsInput
    inventoryItem: InventoryItemCreateNestedOneWithoutAuditItemsInput
  }

  export type AuditItemUncheckedCreateWithoutProductInput = {
    id?: string
    auditId: string
    inventoryItemId: string
    expectedQuantity: number
    countedQuantity?: number | null
    discrepancy?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    countedById?: string | null
    countedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemCreateOrConnectWithoutProductInput = {
    where: AuditItemWhereUniqueInput
    create: XOR<AuditItemCreateWithoutProductInput, AuditItemUncheckedCreateWithoutProductInput>
  }

  export type AuditItemCreateManyProductInputEnvelope = {
    data: AuditItemCreateManyProductInput | AuditItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceRules?: CategoryPriceRuleUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priceRules?: CategoryPriceRuleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type SupplierUpsertWithoutProductsInput = {
    update: XOR<SupplierUpdateWithoutProductsInput, SupplierUncheckedUpdateWithoutProductsInput>
    create: XOR<SupplierCreateWithoutProductsInput, SupplierUncheckedCreateWithoutProductsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutProductsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutProductsInput, SupplierUncheckedUpdateWithoutProductsInput>
  }

  export type SupplierUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: SupplierContractUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    performanceMetrics?: SupplierPerformanceMetricUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: SupplierContractUncheckedUpdateManyWithoutSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    performanceMetrics?: SupplierPerformanceMetricUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutProductInput, PurchaseOrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseOrderItemCreateWithoutProductInput, PurchaseOrderItemUncheckedCreateWithoutProductInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutProductInput, PurchaseOrderItemUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type QualityControlItemUpsertWithWhereUniqueWithoutProductInput = {
    where: QualityControlItemWhereUniqueInput
    update: XOR<QualityControlItemUpdateWithoutProductInput, QualityControlItemUncheckedUpdateWithoutProductInput>
    create: XOR<QualityControlItemCreateWithoutProductInput, QualityControlItemUncheckedCreateWithoutProductInput>
  }

  export type QualityControlItemUpdateWithWhereUniqueWithoutProductInput = {
    where: QualityControlItemWhereUniqueInput
    data: XOR<QualityControlItemUpdateWithoutProductInput, QualityControlItemUncheckedUpdateWithoutProductInput>
  }

  export type QualityControlItemUpdateManyWithWhereWithoutProductInput = {
    where: QualityControlItemScalarWhereInput
    data: XOR<QualityControlItemUpdateManyMutationInput, QualityControlItemUncheckedUpdateManyWithoutProductInput>
  }

  export type QualityControlItemScalarWhereInput = {
    AND?: QualityControlItemScalarWhereInput | QualityControlItemScalarWhereInput[]
    OR?: QualityControlItemScalarWhereInput[]
    NOT?: QualityControlItemScalarWhereInput | QualityControlItemScalarWhereInput[]
    id?: StringFilter<"QualityControlItem"> | string
    qualityControlId?: StringFilter<"QualityControlItem"> | string
    productId?: StringFilter<"QualityControlItem"> | string
    quantity?: IntFilter<"QualityControlItem"> | number
    passedQuantity?: IntFilter<"QualityControlItem"> | number
    failedQuantity?: IntFilter<"QualityControlItem"> | number
    pendingQuantity?: IntFilter<"QualityControlItem"> | number
    status?: EnumQCItemStatusFilter<"QualityControlItem"> | $Enums.QCItemStatus
    reason?: StringNullableFilter<"QualityControlItem"> | string | null
    action?: EnumQCActionNullableFilter<"QualityControlItem"> | $Enums.QCAction | null
    notes?: StringNullableFilter<"QualityControlItem"> | string | null
    createdAt?: DateTimeFilter<"QualityControlItem"> | Date | string
    updatedAt?: DateTimeFilter<"QualityControlItem"> | Date | string
  }

  export type ReturnItemUpsertWithWhereUniqueWithoutProductInput = {
    where: ReturnItemWhereUniqueInput
    update: XOR<ReturnItemUpdateWithoutProductInput, ReturnItemUncheckedUpdateWithoutProductInput>
    create: XOR<ReturnItemCreateWithoutProductInput, ReturnItemUncheckedCreateWithoutProductInput>
  }

  export type ReturnItemUpdateWithWhereUniqueWithoutProductInput = {
    where: ReturnItemWhereUniqueInput
    data: XOR<ReturnItemUpdateWithoutProductInput, ReturnItemUncheckedUpdateWithoutProductInput>
  }

  export type ReturnItemUpdateManyWithWhereWithoutProductInput = {
    where: ReturnItemScalarWhereInput
    data: XOR<ReturnItemUpdateManyMutationInput, ReturnItemUncheckedUpdateManyWithoutProductInput>
  }

  export type ReturnItemScalarWhereInput = {
    AND?: ReturnItemScalarWhereInput | ReturnItemScalarWhereInput[]
    OR?: ReturnItemScalarWhereInput[]
    NOT?: ReturnItemScalarWhereInput | ReturnItemScalarWhereInput[]
    id?: StringFilter<"ReturnItem"> | string
    returnId?: StringFilter<"ReturnItem"> | string
    productId?: StringFilter<"ReturnItem"> | string
    saleItemId?: StringNullableFilter<"ReturnItem"> | string | null
    quantity?: IntFilter<"ReturnItem"> | number
    unitPrice?: FloatFilter<"ReturnItem"> | number
    totalPrice?: FloatFilter<"ReturnItem"> | number
    reason?: EnumReturnReasonFilter<"ReturnItem"> | $Enums.ReturnReason
    condition?: EnumItemConditionFilter<"ReturnItem"> | $Enums.ItemCondition
    notes?: StringNullableFilter<"ReturnItem"> | string | null
    createdAt?: DateTimeFilter<"ReturnItem"> | Date | string
    updatedAt?: DateTimeFilter<"ReturnItem"> | Date | string
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutProductInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutProductInput, InventoryItemUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutProductInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutProductInput, InventoryItemUncheckedUpdateWithoutProductInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutProductInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutProductInput>
  }

  export type SaleItemUpsertWithWhereUniqueWithoutProductInput = {
    where: SaleItemWhereUniqueInput
    update: XOR<SaleItemUpdateWithoutProductInput, SaleItemUncheckedUpdateWithoutProductInput>
    create: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput>
  }

  export type SaleItemUpdateWithWhereUniqueWithoutProductInput = {
    where: SaleItemWhereUniqueInput
    data: XOR<SaleItemUpdateWithoutProductInput, SaleItemUncheckedUpdateWithoutProductInput>
  }

  export type SaleItemUpdateManyWithWhereWithoutProductInput = {
    where: SaleItemScalarWhereInput
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyWithoutProductInput>
  }

  export type SaleItemScalarWhereInput = {
    AND?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
    OR?: SaleItemScalarWhereInput[]
    NOT?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
    id?: StringFilter<"SaleItem"> | string
    saleId?: StringFilter<"SaleItem"> | string
    productId?: StringFilter<"SaleItem"> | string
    inventoryItemId?: StringFilter<"SaleItem"> | string
    quantity?: IntFilter<"SaleItem"> | number
    unitPrice?: FloatFilter<"SaleItem"> | number
    discountAmount?: FloatFilter<"SaleItem"> | number
    taxAmount?: FloatFilter<"SaleItem"> | number
    totalPrice?: FloatFilter<"SaleItem"> | number
    createdAt?: DateTimeFilter<"SaleItem"> | Date | string
    updatedAt?: DateTimeFilter<"SaleItem"> | Date | string
  }

  export type TransferItemUpsertWithWhereUniqueWithoutProductInput = {
    where: TransferItemWhereUniqueInput
    update: XOR<TransferItemUpdateWithoutProductInput, TransferItemUncheckedUpdateWithoutProductInput>
    create: XOR<TransferItemCreateWithoutProductInput, TransferItemUncheckedCreateWithoutProductInput>
  }

  export type TransferItemUpdateWithWhereUniqueWithoutProductInput = {
    where: TransferItemWhereUniqueInput
    data: XOR<TransferItemUpdateWithoutProductInput, TransferItemUncheckedUpdateWithoutProductInput>
  }

  export type TransferItemUpdateManyWithWhereWithoutProductInput = {
    where: TransferItemScalarWhereInput
    data: XOR<TransferItemUpdateManyMutationInput, TransferItemUncheckedUpdateManyWithoutProductInput>
  }

  export type TransferItemScalarWhereInput = {
    AND?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
    OR?: TransferItemScalarWhereInput[]
    NOT?: TransferItemScalarWhereInput | TransferItemScalarWhereInput[]
    id?: StringFilter<"TransferItem"> | string
    transferId?: StringFilter<"TransferItem"> | string
    productId?: StringFilter<"TransferItem"> | string
    quantity?: IntFilter<"TransferItem"> | number
    sourceCostPrice?: FloatFilter<"TransferItem"> | number
    sourceRetailPrice?: FloatFilter<"TransferItem"> | number
    targetCostPrice?: FloatFilter<"TransferItem"> | number
    targetRetailPrice?: FloatFilter<"TransferItem"> | number
    condition?: EnumProductConditionFilter<"TransferItem"> | $Enums.ProductCondition
    adjustmentReason?: StringNullableFilter<"TransferItem"> | string | null
    notes?: StringNullableFilter<"TransferItem"> | string | null
    createdAt?: DateTimeFilter<"TransferItem"> | Date | string
    updatedAt?: DateTimeFilter<"TransferItem"> | Date | string
  }

  export type AuditItemUpsertWithWhereUniqueWithoutProductInput = {
    where: AuditItemWhereUniqueInput
    update: XOR<AuditItemUpdateWithoutProductInput, AuditItemUncheckedUpdateWithoutProductInput>
    create: XOR<AuditItemCreateWithoutProductInput, AuditItemUncheckedCreateWithoutProductInput>
  }

  export type AuditItemUpdateWithWhereUniqueWithoutProductInput = {
    where: AuditItemWhereUniqueInput
    data: XOR<AuditItemUpdateWithoutProductInput, AuditItemUncheckedUpdateWithoutProductInput>
  }

  export type AuditItemUpdateManyWithWhereWithoutProductInput = {
    where: AuditItemScalarWhereInput
    data: XOR<AuditItemUpdateManyMutationInput, AuditItemUncheckedUpdateManyWithoutProductInput>
  }

  export type AuditItemScalarWhereInput = {
    AND?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
    OR?: AuditItemScalarWhereInput[]
    NOT?: AuditItemScalarWhereInput | AuditItemScalarWhereInput[]
    id?: StringFilter<"AuditItem"> | string
    auditId?: StringFilter<"AuditItem"> | string
    productId?: StringFilter<"AuditItem"> | string
    inventoryItemId?: StringFilter<"AuditItem"> | string
    expectedQuantity?: IntFilter<"AuditItem"> | number
    countedQuantity?: IntNullableFilter<"AuditItem"> | number | null
    discrepancy?: IntNullableFilter<"AuditItem"> | number | null
    notes?: StringNullableFilter<"AuditItem"> | string | null
    status?: EnumAuditItemStatusFilter<"AuditItem"> | $Enums.AuditItemStatus
    countedById?: StringNullableFilter<"AuditItem"> | string | null
    countedAt?: DateTimeNullableFilter<"AuditItem"> | Date | string | null
    createdAt?: DateTimeFilter<"AuditItem"> | Date | string
    updatedAt?: DateTimeFilter<"AuditItem"> | Date | string
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    supplierId?: string | null
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemUncheckedCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryPriceRuleCreateWithoutCategoryInput = {
    id?: string
    adjustmentType: string
    adjustmentValue: number
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryPriceRuleUncheckedCreateWithoutCategoryInput = {
    id?: string
    adjustmentType: string
    adjustmentValue: number
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryPriceRuleCreateOrConnectWithoutCategoryInput = {
    where: CategoryPriceRuleWhereUniqueInput
    create: XOR<CategoryPriceRuleCreateWithoutCategoryInput, CategoryPriceRuleUncheckedCreateWithoutCategoryInput>
  }

  export type CategoryPriceRuleCreateManyCategoryInputEnvelope = {
    data: CategoryPriceRuleCreateManyCategoryInput | CategoryPriceRuleCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CategoryPriceRuleUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CategoryPriceRuleWhereUniqueInput
    update: XOR<CategoryPriceRuleUpdateWithoutCategoryInput, CategoryPriceRuleUncheckedUpdateWithoutCategoryInput>
    create: XOR<CategoryPriceRuleCreateWithoutCategoryInput, CategoryPriceRuleUncheckedCreateWithoutCategoryInput>
  }

  export type CategoryPriceRuleUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CategoryPriceRuleWhereUniqueInput
    data: XOR<CategoryPriceRuleUpdateWithoutCategoryInput, CategoryPriceRuleUncheckedUpdateWithoutCategoryInput>
  }

  export type CategoryPriceRuleUpdateManyWithWhereWithoutCategoryInput = {
    where: CategoryPriceRuleScalarWhereInput
    data: XOR<CategoryPriceRuleUpdateManyMutationInput, CategoryPriceRuleUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CategoryPriceRuleScalarWhereInput = {
    AND?: CategoryPriceRuleScalarWhereInput | CategoryPriceRuleScalarWhereInput[]
    OR?: CategoryPriceRuleScalarWhereInput[]
    NOT?: CategoryPriceRuleScalarWhereInput | CategoryPriceRuleScalarWhereInput[]
    id?: StringFilter<"CategoryPriceRule"> | string
    categoryId?: StringFilter<"CategoryPriceRule"> | string
    adjustmentType?: StringFilter<"CategoryPriceRule"> | string
    adjustmentValue?: FloatFilter<"CategoryPriceRule"> | number
    isDefault?: BoolFilter<"CategoryPriceRule"> | boolean
    createdAt?: DateTimeFilter<"CategoryPriceRule"> | Date | string
    updatedAt?: DateTimeFilter<"CategoryPriceRule"> | Date | string
  }

  export type CategoryCreateWithoutPriceRulesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutPriceRulesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutPriceRulesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutPriceRulesInput, CategoryUncheckedCreateWithoutPriceRulesInput>
  }

  export type CategoryUpsertWithoutPriceRulesInput = {
    update: XOR<CategoryUpdateWithoutPriceRulesInput, CategoryUncheckedUpdateWithoutPriceRulesInput>
    create: XOR<CategoryCreateWithoutPriceRulesInput, CategoryUncheckedCreateWithoutPriceRulesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutPriceRulesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutPriceRulesInput, CategoryUncheckedUpdateWithoutPriceRulesInput>
  }

  export type CategoryUpdateWithoutPriceRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutPriceRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCreateWithoutInventoryItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemUncheckedCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInventoryItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
  }

  export type StoreCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleCreateNestedManyWithoutStoreInput
    returns?: ReturnCreateNestedManyWithoutStoreInput
    staff?: StoreStaffCreateNestedManyWithoutStoreInput
    transfersFrom?: TransferCreateNestedManyWithoutFromStoreInput
    transfersTo?: TransferCreateNestedManyWithoutToStoreInput
  }

  export type StoreUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    returns?: ReturnUncheckedCreateNestedManyWithoutStoreInput
    staff?: StoreStaffUncheckedCreateNestedManyWithoutStoreInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromStoreInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToStoreInput
  }

  export type StoreCreateOrConnectWithoutInventoryItemsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutInventoryItemsInput, StoreUncheckedCreateWithoutInventoryItemsInput>
  }

  export type WarehouseCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
    qualityControls?: QualityControlCreateNestedManyWithoutWarehouseInput
    audits?: AuditCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutWarehouseInput
    audits?: AuditUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutInventoryItemsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
  }

  export type WarehouseBinCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    code: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shelf: WarehouseShelfCreateNestedOneWithoutBinsInput
  }

  export type WarehouseBinUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    code: string
    shelfId: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseBinCreateOrConnectWithoutInventoryItemsInput = {
    where: WarehouseBinWhereUniqueInput
    create: XOR<WarehouseBinCreateWithoutInventoryItemsInput, WarehouseBinUncheckedCreateWithoutInventoryItemsInput>
  }

  export type SaleItemCreateWithoutInventoryItemInput = {
    id?: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sale: SaleCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutSaleItemsInput
    returnItems?: ReturnItemCreateNestedManyWithoutSaleItemInput
  }

  export type SaleItemUncheckedCreateWithoutInventoryItemInput = {
    id?: string
    saleId: string
    productId: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    returnItems?: ReturnItemUncheckedCreateNestedManyWithoutSaleItemInput
  }

  export type SaleItemCreateOrConnectWithoutInventoryItemInput = {
    where: SaleItemWhereUniqueInput
    create: XOR<SaleItemCreateWithoutInventoryItemInput, SaleItemUncheckedCreateWithoutInventoryItemInput>
  }

  export type SaleItemCreateManyInventoryItemInputEnvelope = {
    data: SaleItemCreateManyInventoryItemInput | SaleItemCreateManyInventoryItemInput[]
    skipDuplicates?: boolean
  }

  export type AuditItemCreateWithoutInventoryItemInput = {
    id?: string
    expectedQuantity: number
    countedQuantity?: number | null
    discrepancy?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    countedById?: string | null
    countedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audit: AuditCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutAuditItemsInput
  }

  export type AuditItemUncheckedCreateWithoutInventoryItemInput = {
    id?: string
    auditId: string
    productId: string
    expectedQuantity: number
    countedQuantity?: number | null
    discrepancy?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    countedById?: string | null
    countedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemCreateOrConnectWithoutInventoryItemInput = {
    where: AuditItemWhereUniqueInput
    create: XOR<AuditItemCreateWithoutInventoryItemInput, AuditItemUncheckedCreateWithoutInventoryItemInput>
  }

  export type AuditItemCreateManyInventoryItemInputEnvelope = {
    data: AuditItemCreateManyInventoryItemInput | AuditItemCreateManyInventoryItemInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutInventoryItemsInput = {
    update: XOR<ProductUpdateWithoutInventoryItemsInput, ProductUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInventoryItemsInput, ProductUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type ProductUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutProductsNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUncheckedUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StoreUpsertWithoutInventoryItemsInput = {
    update: XOR<StoreUpdateWithoutInventoryItemsInput, StoreUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<StoreCreateWithoutInventoryItemsInput, StoreUncheckedCreateWithoutInventoryItemsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutInventoryItemsInput, StoreUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type StoreUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUpdateManyWithoutStoreNestedInput
    returns?: ReturnUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUpdateManyWithoutStoreNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromStoreNestedInput
    transfersTo?: TransferUpdateManyWithoutToStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    returns?: ReturnUncheckedUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUncheckedUpdateManyWithoutStoreNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromStoreNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToStoreNestedInput
  }

  export type WarehouseUpsertWithoutInventoryItemsInput = {
    update: XOR<WarehouseUpdateWithoutInventoryItemsInput, WarehouseUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutInventoryItemsInput, WarehouseUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type WarehouseUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
    qualityControls?: QualityControlUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseBinUpsertWithoutInventoryItemsInput = {
    update: XOR<WarehouseBinUpdateWithoutInventoryItemsInput, WarehouseBinUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<WarehouseBinCreateWithoutInventoryItemsInput, WarehouseBinUncheckedCreateWithoutInventoryItemsInput>
    where?: WarehouseBinWhereInput
  }

  export type WarehouseBinUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: WarehouseBinWhereInput
    data: XOR<WarehouseBinUpdateWithoutInventoryItemsInput, WarehouseBinUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type WarehouseBinUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shelf?: WarehouseShelfUpdateOneRequiredWithoutBinsNestedInput
  }

  export type WarehouseBinUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    shelfId?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUpsertWithWhereUniqueWithoutInventoryItemInput = {
    where: SaleItemWhereUniqueInput
    update: XOR<SaleItemUpdateWithoutInventoryItemInput, SaleItemUncheckedUpdateWithoutInventoryItemInput>
    create: XOR<SaleItemCreateWithoutInventoryItemInput, SaleItemUncheckedCreateWithoutInventoryItemInput>
  }

  export type SaleItemUpdateWithWhereUniqueWithoutInventoryItemInput = {
    where: SaleItemWhereUniqueInput
    data: XOR<SaleItemUpdateWithoutInventoryItemInput, SaleItemUncheckedUpdateWithoutInventoryItemInput>
  }

  export type SaleItemUpdateManyWithWhereWithoutInventoryItemInput = {
    where: SaleItemScalarWhereInput
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyWithoutInventoryItemInput>
  }

  export type AuditItemUpsertWithWhereUniqueWithoutInventoryItemInput = {
    where: AuditItemWhereUniqueInput
    update: XOR<AuditItemUpdateWithoutInventoryItemInput, AuditItemUncheckedUpdateWithoutInventoryItemInput>
    create: XOR<AuditItemCreateWithoutInventoryItemInput, AuditItemUncheckedCreateWithoutInventoryItemInput>
  }

  export type AuditItemUpdateWithWhereUniqueWithoutInventoryItemInput = {
    where: AuditItemWhereUniqueInput
    data: XOR<AuditItemUpdateWithoutInventoryItemInput, AuditItemUncheckedUpdateWithoutInventoryItemInput>
  }

  export type AuditItemUpdateManyWithWhereWithoutInventoryItemInput = {
    where: AuditItemScalarWhereInput
    data: XOR<AuditItemUpdateManyMutationInput, AuditItemUncheckedUpdateManyWithoutInventoryItemInput>
  }

  export type StoreCreateWithoutSalesInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutStoreInput
    returns?: ReturnCreateNestedManyWithoutStoreInput
    staff?: StoreStaffCreateNestedManyWithoutStoreInput
    transfersFrom?: TransferCreateNestedManyWithoutFromStoreInput
    transfersTo?: TransferCreateNestedManyWithoutToStoreInput
  }

  export type StoreUncheckedCreateWithoutSalesInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutStoreInput
    returns?: ReturnUncheckedCreateNestedManyWithoutStoreInput
    staff?: StoreStaffUncheckedCreateNestedManyWithoutStoreInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromStoreInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToStoreInput
  }

  export type StoreCreateOrConnectWithoutSalesInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutSalesInput, StoreUncheckedCreateWithoutSalesInput>
  }

  export type CustomerCreateWithoutSalesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    returns?: ReturnCreateNestedManyWithoutCustomerInput
    addresses?: AddressCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSalesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    returns?: ReturnUncheckedCreateNestedManyWithoutCustomerInput
    addresses?: AddressUncheckedCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSalesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
  }

  export type UserCreateWithoutCreatedSalesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    processedReturns?: ReturnCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedSalesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    processedReturns?: ReturnUncheckedCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlUncheckedCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedSalesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedSalesInput, UserUncheckedCreateWithoutCreatedSalesInput>
  }

  export type SaleItemCreateWithoutSaleInput = {
    id?: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutSaleItemsInput
    inventoryItem: InventoryItemCreateNestedOneWithoutSaleItemsInput
    returnItems?: ReturnItemCreateNestedManyWithoutSaleItemInput
  }

  export type SaleItemUncheckedCreateWithoutSaleInput = {
    id?: string
    productId: string
    inventoryItemId: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    returnItems?: ReturnItemUncheckedCreateNestedManyWithoutSaleItemInput
  }

  export type SaleItemCreateOrConnectWithoutSaleInput = {
    where: SaleItemWhereUniqueInput
    create: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput>
  }

  export type SaleItemCreateManySaleInputEnvelope = {
    data: SaleItemCreateManySaleInput | SaleItemCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutSaleInput = {
    id?: string
    amount: number
    paymentMethod: $Enums.PaymentMethod
    referenceNumber?: string | null
    notes?: string | null
    processedById: string
    processedByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutSaleInput = {
    id?: string
    amount: number
    paymentMethod: $Enums.PaymentMethod
    referenceNumber?: string | null
    notes?: string | null
    processedById: string
    processedByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutSaleInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutSaleInput, PaymentUncheckedCreateWithoutSaleInput>
  }

  export type PaymentCreateManySaleInputEnvelope = {
    data: PaymentCreateManySaleInput | PaymentCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type ReturnCreateWithoutSaleInput = {
    id?: string
    returnNumber: string
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutReturnsInput
    customer?: CustomerCreateNestedOneWithoutReturnsInput
    processedBy: UserCreateNestedOneWithoutProcessedReturnsInput
    items?: ReturnItemCreateNestedManyWithoutReturnInput
    qualityControls?: QualityControlCreateNestedManyWithoutReturnInput
  }

  export type ReturnUncheckedCreateWithoutSaleInput = {
    id?: string
    returnNumber: string
    storeId: string
    customerId?: string | null
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    processedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ReturnItemUncheckedCreateNestedManyWithoutReturnInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutReturnInput
  }

  export type ReturnCreateOrConnectWithoutSaleInput = {
    where: ReturnWhereUniqueInput
    create: XOR<ReturnCreateWithoutSaleInput, ReturnUncheckedCreateWithoutSaleInput>
  }

  export type ReturnCreateManySaleInputEnvelope = {
    data: ReturnCreateManySaleInput | ReturnCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutSalesInput = {
    update: XOR<StoreUpdateWithoutSalesInput, StoreUncheckedUpdateWithoutSalesInput>
    create: XOR<StoreCreateWithoutSalesInput, StoreUncheckedCreateWithoutSalesInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutSalesInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutSalesInput, StoreUncheckedUpdateWithoutSalesInput>
  }

  export type StoreUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutStoreNestedInput
    returns?: ReturnUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUpdateManyWithoutStoreNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromStoreNestedInput
    transfersTo?: TransferUpdateManyWithoutToStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutStoreNestedInput
    returns?: ReturnUncheckedUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUncheckedUpdateManyWithoutStoreNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromStoreNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToStoreNestedInput
  }

  export type CustomerUpsertWithoutSalesInput = {
    update: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSalesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type CustomerUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returns?: ReturnUpdateManyWithoutCustomerNestedInput
    addresses?: AddressUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returns?: ReturnUncheckedUpdateManyWithoutCustomerNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutCreatedSalesInput = {
    update: XOR<UserUpdateWithoutCreatedSalesInput, UserUncheckedUpdateWithoutCreatedSalesInput>
    create: XOR<UserCreateWithoutCreatedSalesInput, UserUncheckedCreateWithoutCreatedSalesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedSalesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedSalesInput, UserUncheckedUpdateWithoutCreatedSalesInput>
  }

  export type UserUpdateWithoutCreatedSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    processedReturns?: ReturnUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    processedReturns?: ReturnUncheckedUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUncheckedUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SaleItemUpsertWithWhereUniqueWithoutSaleInput = {
    where: SaleItemWhereUniqueInput
    update: XOR<SaleItemUpdateWithoutSaleInput, SaleItemUncheckedUpdateWithoutSaleInput>
    create: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput>
  }

  export type SaleItemUpdateWithWhereUniqueWithoutSaleInput = {
    where: SaleItemWhereUniqueInput
    data: XOR<SaleItemUpdateWithoutSaleInput, SaleItemUncheckedUpdateWithoutSaleInput>
  }

  export type SaleItemUpdateManyWithWhereWithoutSaleInput = {
    where: SaleItemScalarWhereInput
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyWithoutSaleInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutSaleInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutSaleInput, PaymentUncheckedUpdateWithoutSaleInput>
    create: XOR<PaymentCreateWithoutSaleInput, PaymentUncheckedCreateWithoutSaleInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutSaleInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutSaleInput, PaymentUncheckedUpdateWithoutSaleInput>
  }

  export type PaymentUpdateManyWithWhereWithoutSaleInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutSaleInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    saleId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    processedById?: StringFilter<"Payment"> | string
    processedByName?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type ReturnUpsertWithWhereUniqueWithoutSaleInput = {
    where: ReturnWhereUniqueInput
    update: XOR<ReturnUpdateWithoutSaleInput, ReturnUncheckedUpdateWithoutSaleInput>
    create: XOR<ReturnCreateWithoutSaleInput, ReturnUncheckedCreateWithoutSaleInput>
  }

  export type ReturnUpdateWithWhereUniqueWithoutSaleInput = {
    where: ReturnWhereUniqueInput
    data: XOR<ReturnUpdateWithoutSaleInput, ReturnUncheckedUpdateWithoutSaleInput>
  }

  export type ReturnUpdateManyWithWhereWithoutSaleInput = {
    where: ReturnScalarWhereInput
    data: XOR<ReturnUpdateManyMutationInput, ReturnUncheckedUpdateManyWithoutSaleInput>
  }

  export type SaleCreateWithoutItemsInput = {
    id?: string
    receiptNumber: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    createdBy: UserCreateNestedOneWithoutCreatedSalesInput
    payments?: PaymentCreateNestedManyWithoutSaleInput
    returns?: ReturnCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutItemsInput = {
    id?: string
    receiptNumber: string
    storeId: string
    customerId?: string | null
    createdById: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSaleInput
    returns?: ReturnUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutItemsInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutSaleItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSaleItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemUncheckedCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSaleItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSaleItemsInput, ProductUncheckedCreateWithoutSaleItemsInput>
  }

  export type InventoryItemCreateWithoutSaleItemsInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    store?: StoreCreateNestedOneWithoutInventoryItemsInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryItemsInput
    bin?: WarehouseBinCreateNestedOneWithoutInventoryItemsInput
    auditItems?: AuditItemCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutSaleItemsInput = {
    id?: string
    productId: string
    storeId?: string | null
    warehouseId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutSaleItemsInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutSaleItemsInput, InventoryItemUncheckedCreateWithoutSaleItemsInput>
  }

  export type ReturnItemCreateWithoutSaleItemInput = {
    id?: string
    quantity: number
    unitPrice: number
    totalPrice: number
    reason: $Enums.ReturnReason
    condition?: $Enums.ItemCondition
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    return: ReturnCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutReturnItemsInput
  }

  export type ReturnItemUncheckedCreateWithoutSaleItemInput = {
    id?: string
    returnId: string
    productId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    reason: $Enums.ReturnReason
    condition?: $Enums.ItemCondition
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnItemCreateOrConnectWithoutSaleItemInput = {
    where: ReturnItemWhereUniqueInput
    create: XOR<ReturnItemCreateWithoutSaleItemInput, ReturnItemUncheckedCreateWithoutSaleItemInput>
  }

  export type ReturnItemCreateManySaleItemInputEnvelope = {
    data: ReturnItemCreateManySaleItemInput | ReturnItemCreateManySaleItemInput[]
    skipDuplicates?: boolean
  }

  export type SaleUpsertWithoutItemsInput = {
    update: XOR<SaleUpdateWithoutItemsInput, SaleUncheckedUpdateWithoutItemsInput>
    create: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutItemsInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutItemsInput, SaleUncheckedUpdateWithoutItemsInput>
  }

  export type SaleUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedSalesNestedInput
    payments?: PaymentUpdateManyWithoutSaleNestedInput
    returns?: ReturnUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSaleNestedInput
    returns?: ReturnUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type ProductUpsertWithoutSaleItemsInput = {
    update: XOR<ProductUpdateWithoutSaleItemsInput, ProductUncheckedUpdateWithoutSaleItemsInput>
    create: XOR<ProductCreateWithoutSaleItemsInput, ProductUncheckedCreateWithoutSaleItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSaleItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSaleItemsInput, ProductUncheckedUpdateWithoutSaleItemsInput>
  }

  export type ProductUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutProductsNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUncheckedUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type InventoryItemUpsertWithoutSaleItemsInput = {
    update: XOR<InventoryItemUpdateWithoutSaleItemsInput, InventoryItemUncheckedUpdateWithoutSaleItemsInput>
    create: XOR<InventoryItemCreateWithoutSaleItemsInput, InventoryItemUncheckedCreateWithoutSaleItemsInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutSaleItemsInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutSaleItemsInput, InventoryItemUncheckedUpdateWithoutSaleItemsInput>
  }

  export type InventoryItemUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    store?: StoreUpdateOneWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryItemsNestedInput
    bin?: WarehouseBinUpdateOneWithoutInventoryItemsNestedInput
    auditItems?: AuditItemUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditItems?: AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type ReturnItemUpsertWithWhereUniqueWithoutSaleItemInput = {
    where: ReturnItemWhereUniqueInput
    update: XOR<ReturnItemUpdateWithoutSaleItemInput, ReturnItemUncheckedUpdateWithoutSaleItemInput>
    create: XOR<ReturnItemCreateWithoutSaleItemInput, ReturnItemUncheckedCreateWithoutSaleItemInput>
  }

  export type ReturnItemUpdateWithWhereUniqueWithoutSaleItemInput = {
    where: ReturnItemWhereUniqueInput
    data: XOR<ReturnItemUpdateWithoutSaleItemInput, ReturnItemUncheckedUpdateWithoutSaleItemInput>
  }

  export type ReturnItemUpdateManyWithWhereWithoutSaleItemInput = {
    where: ReturnItemScalarWhereInput
    data: XOR<ReturnItemUpdateManyMutationInput, ReturnItemUncheckedUpdateManyWithoutSaleItemInput>
  }

  export type SaleCreateWithoutPaymentsInput = {
    id?: string
    receiptNumber: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    createdBy: UserCreateNestedOneWithoutCreatedSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
    returns?: ReturnCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutPaymentsInput = {
    id?: string
    receiptNumber: string
    storeId: string
    customerId?: string | null
    createdById: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
    returns?: ReturnUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutPaymentsInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutPaymentsInput, SaleUncheckedCreateWithoutPaymentsInput>
  }

  export type SaleUpsertWithoutPaymentsInput = {
    update: XOR<SaleUpdateWithoutPaymentsInput, SaleUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SaleCreateWithoutPaymentsInput, SaleUncheckedCreateWithoutPaymentsInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutPaymentsInput, SaleUncheckedUpdateWithoutPaymentsInput>
  }

  export type SaleUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
    returns?: ReturnUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
    returns?: ReturnUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleCreateWithoutReturnsInput = {
    id?: string
    receiptNumber: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSalesInput
    customer?: CustomerCreateNestedOneWithoutSalesInput
    createdBy: UserCreateNestedOneWithoutCreatedSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
    payments?: PaymentCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutReturnsInput = {
    id?: string
    receiptNumber: string
    storeId: string
    customerId?: string | null
    createdById: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: PaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutReturnsInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutReturnsInput, SaleUncheckedCreateWithoutReturnsInput>
  }

  export type StoreCreateWithoutReturnsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    staff?: StoreStaffCreateNestedManyWithoutStoreInput
    transfersFrom?: TransferCreateNestedManyWithoutFromStoreInput
    transfersTo?: TransferCreateNestedManyWithoutToStoreInput
  }

  export type StoreUncheckedCreateWithoutReturnsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    staff?: StoreStaffUncheckedCreateNestedManyWithoutStoreInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromStoreInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToStoreInput
  }

  export type StoreCreateOrConnectWithoutReturnsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutReturnsInput, StoreUncheckedCreateWithoutReturnsInput>
  }

  export type CustomerCreateWithoutReturnsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleCreateNestedManyWithoutCustomerInput
    addresses?: AddressCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutReturnsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
    addresses?: AddressUncheckedCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutReturnsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutReturnsInput, CustomerUncheckedCreateWithoutReturnsInput>
  }

  export type UserCreateWithoutProcessedReturnsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    inspectedQCs?: QualityControlCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProcessedReturnsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    inspectedQCs?: QualityControlUncheckedCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProcessedReturnsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessedReturnsInput, UserUncheckedCreateWithoutProcessedReturnsInput>
  }

  export type ReturnItemCreateWithoutReturnInput = {
    id?: string
    quantity: number
    unitPrice: number
    totalPrice: number
    reason: $Enums.ReturnReason
    condition?: $Enums.ItemCondition
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutReturnItemsInput
    saleItem?: SaleItemCreateNestedOneWithoutReturnItemsInput
  }

  export type ReturnItemUncheckedCreateWithoutReturnInput = {
    id?: string
    productId: string
    saleItemId?: string | null
    quantity: number
    unitPrice: number
    totalPrice: number
    reason: $Enums.ReturnReason
    condition?: $Enums.ItemCondition
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnItemCreateOrConnectWithoutReturnInput = {
    where: ReturnItemWhereUniqueInput
    create: XOR<ReturnItemCreateWithoutReturnInput, ReturnItemUncheckedCreateWithoutReturnInput>
  }

  export type ReturnItemCreateManyReturnInputEnvelope = {
    data: ReturnItemCreateManyReturnInput | ReturnItemCreateManyReturnInput[]
    skipDuplicates?: boolean
  }

  export type QualityControlCreateWithoutReturnInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutQualityControlsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutQualityControlsInput
    inspectedBy: UserCreateNestedOneWithoutInspectedQCsInput
    items?: QualityControlItemCreateNestedManyWithoutQualityControlInput
  }

  export type QualityControlUncheckedCreateWithoutReturnInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    warehouseId: string
    purchaseOrderId?: string | null
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    inspectedById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QualityControlItemUncheckedCreateNestedManyWithoutQualityControlInput
  }

  export type QualityControlCreateOrConnectWithoutReturnInput = {
    where: QualityControlWhereUniqueInput
    create: XOR<QualityControlCreateWithoutReturnInput, QualityControlUncheckedCreateWithoutReturnInput>
  }

  export type QualityControlCreateManyReturnInputEnvelope = {
    data: QualityControlCreateManyReturnInput | QualityControlCreateManyReturnInput[]
    skipDuplicates?: boolean
  }

  export type SaleUpsertWithoutReturnsInput = {
    update: XOR<SaleUpdateWithoutReturnsInput, SaleUncheckedUpdateWithoutReturnsInput>
    create: XOR<SaleCreateWithoutReturnsInput, SaleUncheckedCreateWithoutReturnsInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutReturnsInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutReturnsInput, SaleUncheckedUpdateWithoutReturnsInput>
  }

  export type SaleUpdateWithoutReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
    payments?: PaymentUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type StoreUpsertWithoutReturnsInput = {
    update: XOR<StoreUpdateWithoutReturnsInput, StoreUncheckedUpdateWithoutReturnsInput>
    create: XOR<StoreCreateWithoutReturnsInput, StoreUncheckedCreateWithoutReturnsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutReturnsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutReturnsInput, StoreUncheckedUpdateWithoutReturnsInput>
  }

  export type StoreUpdateWithoutReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUpdateManyWithoutStoreNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromStoreNestedInput
    transfersTo?: TransferUpdateManyWithoutToStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUncheckedUpdateManyWithoutStoreNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromStoreNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToStoreNestedInput
  }

  export type CustomerUpsertWithoutReturnsInput = {
    update: XOR<CustomerUpdateWithoutReturnsInput, CustomerUncheckedUpdateWithoutReturnsInput>
    create: XOR<CustomerCreateWithoutReturnsInput, CustomerUncheckedCreateWithoutReturnsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutReturnsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutReturnsInput, CustomerUncheckedUpdateWithoutReturnsInput>
  }

  export type CustomerUpdateWithoutReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUpdateManyWithoutCustomerNestedInput
    addresses?: AddressUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutProcessedReturnsInput = {
    update: XOR<UserUpdateWithoutProcessedReturnsInput, UserUncheckedUpdateWithoutProcessedReturnsInput>
    create: XOR<UserCreateWithoutProcessedReturnsInput, UserUncheckedCreateWithoutProcessedReturnsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessedReturnsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessedReturnsInput, UserUncheckedUpdateWithoutProcessedReturnsInput>
  }

  export type UserUpdateWithoutProcessedReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    inspectedQCs?: QualityControlUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessedReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    inspectedQCs?: QualityControlUncheckedUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReturnItemUpsertWithWhereUniqueWithoutReturnInput = {
    where: ReturnItemWhereUniqueInput
    update: XOR<ReturnItemUpdateWithoutReturnInput, ReturnItemUncheckedUpdateWithoutReturnInput>
    create: XOR<ReturnItemCreateWithoutReturnInput, ReturnItemUncheckedCreateWithoutReturnInput>
  }

  export type ReturnItemUpdateWithWhereUniqueWithoutReturnInput = {
    where: ReturnItemWhereUniqueInput
    data: XOR<ReturnItemUpdateWithoutReturnInput, ReturnItemUncheckedUpdateWithoutReturnInput>
  }

  export type ReturnItemUpdateManyWithWhereWithoutReturnInput = {
    where: ReturnItemScalarWhereInput
    data: XOR<ReturnItemUpdateManyMutationInput, ReturnItemUncheckedUpdateManyWithoutReturnInput>
  }

  export type QualityControlUpsertWithWhereUniqueWithoutReturnInput = {
    where: QualityControlWhereUniqueInput
    update: XOR<QualityControlUpdateWithoutReturnInput, QualityControlUncheckedUpdateWithoutReturnInput>
    create: XOR<QualityControlCreateWithoutReturnInput, QualityControlUncheckedCreateWithoutReturnInput>
  }

  export type QualityControlUpdateWithWhereUniqueWithoutReturnInput = {
    where: QualityControlWhereUniqueInput
    data: XOR<QualityControlUpdateWithoutReturnInput, QualityControlUncheckedUpdateWithoutReturnInput>
  }

  export type QualityControlUpdateManyWithWhereWithoutReturnInput = {
    where: QualityControlScalarWhereInput
    data: XOR<QualityControlUpdateManyMutationInput, QualityControlUncheckedUpdateManyWithoutReturnInput>
  }

  export type ReturnCreateWithoutItemsInput = {
    id?: string
    returnNumber: string
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sale?: SaleCreateNestedOneWithoutReturnsInput
    store: StoreCreateNestedOneWithoutReturnsInput
    customer?: CustomerCreateNestedOneWithoutReturnsInput
    processedBy: UserCreateNestedOneWithoutProcessedReturnsInput
    qualityControls?: QualityControlCreateNestedManyWithoutReturnInput
  }

  export type ReturnUncheckedCreateWithoutItemsInput = {
    id?: string
    returnNumber: string
    saleId?: string | null
    storeId: string
    customerId?: string | null
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    processedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutReturnInput
  }

  export type ReturnCreateOrConnectWithoutItemsInput = {
    where: ReturnWhereUniqueInput
    create: XOR<ReturnCreateWithoutItemsInput, ReturnUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutReturnItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutReturnItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutReturnItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutReturnItemsInput, ProductUncheckedCreateWithoutReturnItemsInput>
  }

  export type SaleItemCreateWithoutReturnItemsInput = {
    id?: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sale: SaleCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutSaleItemsInput
    inventoryItem: InventoryItemCreateNestedOneWithoutSaleItemsInput
  }

  export type SaleItemUncheckedCreateWithoutReturnItemsInput = {
    id?: string
    saleId: string
    productId: string
    inventoryItemId: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleItemCreateOrConnectWithoutReturnItemsInput = {
    where: SaleItemWhereUniqueInput
    create: XOR<SaleItemCreateWithoutReturnItemsInput, SaleItemUncheckedCreateWithoutReturnItemsInput>
  }

  export type ReturnUpsertWithoutItemsInput = {
    update: XOR<ReturnUpdateWithoutItemsInput, ReturnUncheckedUpdateWithoutItemsInput>
    create: XOR<ReturnCreateWithoutItemsInput, ReturnUncheckedCreateWithoutItemsInput>
    where?: ReturnWhereInput
  }

  export type ReturnUpdateToOneWithWhereWithoutItemsInput = {
    where?: ReturnWhereInput
    data: XOR<ReturnUpdateWithoutItemsInput, ReturnUncheckedUpdateWithoutItemsInput>
  }

  export type ReturnUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneWithoutReturnsNestedInput
    store?: StoreUpdateOneRequiredWithoutReturnsNestedInput
    customer?: CustomerUpdateOneWithoutReturnsNestedInput
    processedBy?: UserUpdateOneRequiredWithoutProcessedReturnsNestedInput
    qualityControls?: QualityControlUpdateManyWithoutReturnNestedInput
  }

  export type ReturnUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qualityControls?: QualityControlUncheckedUpdateManyWithoutReturnNestedInput
  }

  export type ProductUpsertWithoutReturnItemsInput = {
    update: XOR<ProductUpdateWithoutReturnItemsInput, ProductUncheckedUpdateWithoutReturnItemsInput>
    create: XOR<ProductCreateWithoutReturnItemsInput, ProductUncheckedCreateWithoutReturnItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutReturnItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutReturnItemsInput, ProductUncheckedUpdateWithoutReturnItemsInput>
  }

  export type ProductUpdateWithoutReturnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutProductsNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutReturnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SaleItemUpsertWithoutReturnItemsInput = {
    update: XOR<SaleItemUpdateWithoutReturnItemsInput, SaleItemUncheckedUpdateWithoutReturnItemsInput>
    create: XOR<SaleItemCreateWithoutReturnItemsInput, SaleItemUncheckedCreateWithoutReturnItemsInput>
    where?: SaleItemWhereInput
  }

  export type SaleItemUpdateToOneWithWhereWithoutReturnItemsInput = {
    where?: SaleItemWhereInput
    data: XOR<SaleItemUpdateWithoutReturnItemsInput, SaleItemUncheckedUpdateWithoutReturnItemsInput>
  }

  export type SaleItemUpdateWithoutReturnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSaleItemsNestedInput
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutSaleItemsNestedInput
  }

  export type SaleItemUncheckedUpdateWithoutReturnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseCreateWithoutQualityControlsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
    audits?: AuditCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutQualityControlsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
    audits?: AuditUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutQualityControlsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutQualityControlsInput, WarehouseUncheckedCreateWithoutQualityControlsInput>
  }

  export type PurchaseOrderCreateWithoutQualityControlsInput = {
    id?: string
    orderNumber: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    status?: $Enums.PurchaseOrderStatus
    subtotal?: number
    taxAmount?: number
    totalAmount?: number
    notes?: string | null
    createdById?: string | null
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
    warehouse: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutQualityControlsInput = {
    id?: string
    orderNumber: string
    supplierId: string
    warehouseId: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    status?: $Enums.PurchaseOrderStatus
    subtotal?: number
    taxAmount?: number
    totalAmount?: number
    notes?: string | null
    createdById?: string | null
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutQualityControlsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutQualityControlsInput, PurchaseOrderUncheckedCreateWithoutQualityControlsInput>
  }

  export type ReturnCreateWithoutQualityControlsInput = {
    id?: string
    returnNumber: string
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sale?: SaleCreateNestedOneWithoutReturnsInput
    store: StoreCreateNestedOneWithoutReturnsInput
    customer?: CustomerCreateNestedOneWithoutReturnsInput
    processedBy: UserCreateNestedOneWithoutProcessedReturnsInput
    items?: ReturnItemCreateNestedManyWithoutReturnInput
  }

  export type ReturnUncheckedCreateWithoutQualityControlsInput = {
    id?: string
    returnNumber: string
    saleId?: string | null
    storeId: string
    customerId?: string | null
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    processedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ReturnItemUncheckedCreateNestedManyWithoutReturnInput
  }

  export type ReturnCreateOrConnectWithoutQualityControlsInput = {
    where: ReturnWhereUniqueInput
    create: XOR<ReturnCreateWithoutQualityControlsInput, ReturnUncheckedCreateWithoutQualityControlsInput>
  }

  export type UserCreateWithoutInspectedQCsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnCreateNestedManyWithoutProcessedByInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInspectedQCsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnUncheckedCreateNestedManyWithoutProcessedByInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInspectedQCsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInspectedQCsInput, UserUncheckedCreateWithoutInspectedQCsInput>
  }

  export type QualityControlItemCreateWithoutQualityControlInput = {
    id?: string
    quantity: number
    passedQuantity?: number
    failedQuantity?: number
    pendingQuantity?: number
    status?: $Enums.QCItemStatus
    reason?: string | null
    action?: $Enums.QCAction | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutQualityControlItemsInput
  }

  export type QualityControlItemUncheckedCreateWithoutQualityControlInput = {
    id?: string
    productId: string
    quantity: number
    passedQuantity?: number
    failedQuantity?: number
    pendingQuantity?: number
    status?: $Enums.QCItemStatus
    reason?: string | null
    action?: $Enums.QCAction | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualityControlItemCreateOrConnectWithoutQualityControlInput = {
    where: QualityControlItemWhereUniqueInput
    create: XOR<QualityControlItemCreateWithoutQualityControlInput, QualityControlItemUncheckedCreateWithoutQualityControlInput>
  }

  export type QualityControlItemCreateManyQualityControlInputEnvelope = {
    data: QualityControlItemCreateManyQualityControlInput | QualityControlItemCreateManyQualityControlInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseUpsertWithoutQualityControlsInput = {
    update: XOR<WarehouseUpdateWithoutQualityControlsInput, WarehouseUncheckedUpdateWithoutQualityControlsInput>
    create: XOR<WarehouseCreateWithoutQualityControlsInput, WarehouseUncheckedCreateWithoutQualityControlsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutQualityControlsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutQualityControlsInput, WarehouseUncheckedUpdateWithoutQualityControlsInput>
  }

  export type WarehouseUpdateWithoutQualityControlsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutQualityControlsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type PurchaseOrderUpsertWithoutQualityControlsInput = {
    update: XOR<PurchaseOrderUpdateWithoutQualityControlsInput, PurchaseOrderUncheckedUpdateWithoutQualityControlsInput>
    create: XOR<PurchaseOrderCreateWithoutQualityControlsInput, PurchaseOrderUncheckedCreateWithoutQualityControlsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutQualityControlsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutQualityControlsInput, PurchaseOrderUncheckedUpdateWithoutQualityControlsInput>
  }

  export type PurchaseOrderUpdateWithoutQualityControlsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutQualityControlsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type ReturnUpsertWithoutQualityControlsInput = {
    update: XOR<ReturnUpdateWithoutQualityControlsInput, ReturnUncheckedUpdateWithoutQualityControlsInput>
    create: XOR<ReturnCreateWithoutQualityControlsInput, ReturnUncheckedCreateWithoutQualityControlsInput>
    where?: ReturnWhereInput
  }

  export type ReturnUpdateToOneWithWhereWithoutQualityControlsInput = {
    where?: ReturnWhereInput
    data: XOR<ReturnUpdateWithoutQualityControlsInput, ReturnUncheckedUpdateWithoutQualityControlsInput>
  }

  export type ReturnUpdateWithoutQualityControlsInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneWithoutReturnsNestedInput
    store?: StoreUpdateOneRequiredWithoutReturnsNestedInput
    customer?: CustomerUpdateOneWithoutReturnsNestedInput
    processedBy?: UserUpdateOneRequiredWithoutProcessedReturnsNestedInput
    items?: ReturnItemUpdateManyWithoutReturnNestedInput
  }

  export type ReturnUncheckedUpdateWithoutQualityControlsInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ReturnItemUncheckedUpdateManyWithoutReturnNestedInput
  }

  export type UserUpsertWithoutInspectedQCsInput = {
    update: XOR<UserUpdateWithoutInspectedQCsInput, UserUncheckedUpdateWithoutInspectedQCsInput>
    create: XOR<UserCreateWithoutInspectedQCsInput, UserUncheckedCreateWithoutInspectedQCsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInspectedQCsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInspectedQCsInput, UserUncheckedUpdateWithoutInspectedQCsInput>
  }

  export type UserUpdateWithoutInspectedQCsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUpdateManyWithoutProcessedByNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInspectedQCsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUncheckedUpdateManyWithoutProcessedByNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QualityControlItemUpsertWithWhereUniqueWithoutQualityControlInput = {
    where: QualityControlItemWhereUniqueInput
    update: XOR<QualityControlItemUpdateWithoutQualityControlInput, QualityControlItemUncheckedUpdateWithoutQualityControlInput>
    create: XOR<QualityControlItemCreateWithoutQualityControlInput, QualityControlItemUncheckedCreateWithoutQualityControlInput>
  }

  export type QualityControlItemUpdateWithWhereUniqueWithoutQualityControlInput = {
    where: QualityControlItemWhereUniqueInput
    data: XOR<QualityControlItemUpdateWithoutQualityControlInput, QualityControlItemUncheckedUpdateWithoutQualityControlInput>
  }

  export type QualityControlItemUpdateManyWithWhereWithoutQualityControlInput = {
    where: QualityControlItemScalarWhereInput
    data: XOR<QualityControlItemUpdateManyMutationInput, QualityControlItemUncheckedUpdateManyWithoutQualityControlInput>
  }

  export type QualityControlCreateWithoutItemsInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutQualityControlsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutQualityControlsInput
    return?: ReturnCreateNestedOneWithoutQualityControlsInput
    inspectedBy: UserCreateNestedOneWithoutInspectedQCsInput
  }

  export type QualityControlUncheckedCreateWithoutItemsInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    warehouseId: string
    purchaseOrderId?: string | null
    returnId?: string | null
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    inspectedById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualityControlCreateOrConnectWithoutItemsInput = {
    where: QualityControlWhereUniqueInput
    create: XOR<QualityControlCreateWithoutItemsInput, QualityControlUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutQualityControlItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutQualityControlItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutQualityControlItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutQualityControlItemsInput, ProductUncheckedCreateWithoutQualityControlItemsInput>
  }

  export type QualityControlUpsertWithoutItemsInput = {
    update: XOR<QualityControlUpdateWithoutItemsInput, QualityControlUncheckedUpdateWithoutItemsInput>
    create: XOR<QualityControlCreateWithoutItemsInput, QualityControlUncheckedCreateWithoutItemsInput>
    where?: QualityControlWhereInput
  }

  export type QualityControlUpdateToOneWithWhereWithoutItemsInput = {
    where?: QualityControlWhereInput
    data: XOR<QualityControlUpdateWithoutItemsInput, QualityControlUncheckedUpdateWithoutItemsInput>
  }

  export type QualityControlUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutQualityControlsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutQualityControlsNestedInput
    return?: ReturnUpdateOneWithoutQualityControlsNestedInput
    inspectedBy?: UserUpdateOneRequiredWithoutInspectedQCsNestedInput
  }

  export type QualityControlUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    returnId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectedById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutQualityControlItemsInput = {
    update: XOR<ProductUpdateWithoutQualityControlItemsInput, ProductUncheckedUpdateWithoutQualityControlItemsInput>
    create: XOR<ProductCreateWithoutQualityControlItemsInput, ProductUncheckedCreateWithoutQualityControlItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutQualityControlItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutQualityControlItemsInput, ProductUncheckedUpdateWithoutQualityControlItemsInput>
  }

  export type ProductUpdateWithoutQualityControlItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutProductsNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutQualityControlItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WarehouseCreateWithoutTransfersFromInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffCreateNestedManyWithoutWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
    qualityControls?: QualityControlCreateNestedManyWithoutWarehouseInput
    audits?: AuditCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutTransfersFromInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutWarehouseInput
    audits?: AuditUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutTransfersFromInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutTransfersFromInput, WarehouseUncheckedCreateWithoutTransfersFromInput>
  }

  export type StoreCreateWithoutTransfersFromInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    returns?: ReturnCreateNestedManyWithoutStoreInput
    staff?: StoreStaffCreateNestedManyWithoutStoreInput
    transfersTo?: TransferCreateNestedManyWithoutToStoreInput
  }

  export type StoreUncheckedCreateWithoutTransfersFromInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    returns?: ReturnUncheckedCreateNestedManyWithoutStoreInput
    staff?: StoreStaffUncheckedCreateNestedManyWithoutStoreInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToStoreInput
  }

  export type StoreCreateOrConnectWithoutTransfersFromInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutTransfersFromInput, StoreUncheckedCreateWithoutTransfersFromInput>
  }

  export type WarehouseCreateWithoutTransfersToInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
    qualityControls?: QualityControlCreateNestedManyWithoutWarehouseInput
    audits?: AuditCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutTransfersToInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutWarehouseInput
    audits?: AuditUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutTransfersToInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutTransfersToInput, WarehouseUncheckedCreateWithoutTransfersToInput>
  }

  export type StoreCreateWithoutTransfersToInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    returns?: ReturnCreateNestedManyWithoutStoreInput
    staff?: StoreStaffCreateNestedManyWithoutStoreInput
    transfersFrom?: TransferCreateNestedManyWithoutFromStoreInput
  }

  export type StoreUncheckedCreateWithoutTransfersToInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    returns?: ReturnUncheckedCreateNestedManyWithoutStoreInput
    staff?: StoreStaffUncheckedCreateNestedManyWithoutStoreInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromStoreInput
  }

  export type StoreCreateOrConnectWithoutTransfersToInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutTransfersToInput, StoreUncheckedCreateWithoutTransfersToInput>
  }

  export type TransferItemCreateWithoutTransferInput = {
    id?: string
    quantity: number
    sourceCostPrice: number
    sourceRetailPrice: number
    targetCostPrice: number
    targetRetailPrice: number
    condition?: $Enums.ProductCondition
    adjustmentReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutTransferItemsInput
  }

  export type TransferItemUncheckedCreateWithoutTransferInput = {
    id?: string
    productId: string
    quantity: number
    sourceCostPrice: number
    sourceRetailPrice: number
    targetCostPrice: number
    targetRetailPrice: number
    condition?: $Enums.ProductCondition
    adjustmentReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateOrConnectWithoutTransferInput = {
    where: TransferItemWhereUniqueInput
    create: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput>
  }

  export type TransferItemCreateManyTransferInputEnvelope = {
    data: TransferItemCreateManyTransferInput | TransferItemCreateManyTransferInput[]
    skipDuplicates?: boolean
  }

  export type TransferDocumentCreateWithoutTransferInput = {
    id?: string
    name: string
    type: string
    url: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferDocumentUncheckedCreateWithoutTransferInput = {
    id?: string
    name: string
    type: string
    url: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferDocumentCreateOrConnectWithoutTransferInput = {
    where: TransferDocumentWhereUniqueInput
    create: XOR<TransferDocumentCreateWithoutTransferInput, TransferDocumentUncheckedCreateWithoutTransferInput>
  }

  export type TransferDocumentCreateManyTransferInputEnvelope = {
    data: TransferDocumentCreateManyTransferInput | TransferDocumentCreateManyTransferInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseUpsertWithoutTransfersFromInput = {
    update: XOR<WarehouseUpdateWithoutTransfersFromInput, WarehouseUncheckedUpdateWithoutTransfersFromInput>
    create: XOR<WarehouseCreateWithoutTransfersFromInput, WarehouseUncheckedCreateWithoutTransfersFromInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutTransfersFromInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutTransfersFromInput, WarehouseUncheckedUpdateWithoutTransfersFromInput>
  }

  export type WarehouseUpdateWithoutTransfersFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUpdateManyWithoutWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
    qualityControls?: QualityControlUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutTransfersFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type StoreUpsertWithoutTransfersFromInput = {
    update: XOR<StoreUpdateWithoutTransfersFromInput, StoreUncheckedUpdateWithoutTransfersFromInput>
    create: XOR<StoreCreateWithoutTransfersFromInput, StoreUncheckedCreateWithoutTransfersFromInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutTransfersFromInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutTransfersFromInput, StoreUncheckedUpdateWithoutTransfersFromInput>
  }

  export type StoreUpdateWithoutTransfersFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    returns?: ReturnUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUpdateManyWithoutStoreNestedInput
    transfersTo?: TransferUpdateManyWithoutToStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutTransfersFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    returns?: ReturnUncheckedUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUncheckedUpdateManyWithoutStoreNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToStoreNestedInput
  }

  export type WarehouseUpsertWithoutTransfersToInput = {
    update: XOR<WarehouseUpdateWithoutTransfersToInput, WarehouseUncheckedUpdateWithoutTransfersToInput>
    create: XOR<WarehouseCreateWithoutTransfersToInput, WarehouseUncheckedCreateWithoutTransfersToInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutTransfersToInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutTransfersToInput, WarehouseUncheckedUpdateWithoutTransfersToInput>
  }

  export type WarehouseUpdateWithoutTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
    qualityControls?: QualityControlUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutWarehouseNestedInput
    audits?: AuditUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type StoreUpsertWithoutTransfersToInput = {
    update: XOR<StoreUpdateWithoutTransfersToInput, StoreUncheckedUpdateWithoutTransfersToInput>
    create: XOR<StoreCreateWithoutTransfersToInput, StoreUncheckedCreateWithoutTransfersToInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutTransfersToInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutTransfersToInput, StoreUncheckedUpdateWithoutTransfersToInput>
  }

  export type StoreUpdateWithoutTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    returns?: ReturnUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUpdateManyWithoutStoreNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    returns?: ReturnUncheckedUpdateManyWithoutStoreNestedInput
    staff?: StoreStaffUncheckedUpdateManyWithoutStoreNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromStoreNestedInput
  }

  export type TransferItemUpsertWithWhereUniqueWithoutTransferInput = {
    where: TransferItemWhereUniqueInput
    update: XOR<TransferItemUpdateWithoutTransferInput, TransferItemUncheckedUpdateWithoutTransferInput>
    create: XOR<TransferItemCreateWithoutTransferInput, TransferItemUncheckedCreateWithoutTransferInput>
  }

  export type TransferItemUpdateWithWhereUniqueWithoutTransferInput = {
    where: TransferItemWhereUniqueInput
    data: XOR<TransferItemUpdateWithoutTransferInput, TransferItemUncheckedUpdateWithoutTransferInput>
  }

  export type TransferItemUpdateManyWithWhereWithoutTransferInput = {
    where: TransferItemScalarWhereInput
    data: XOR<TransferItemUpdateManyMutationInput, TransferItemUncheckedUpdateManyWithoutTransferInput>
  }

  export type TransferDocumentUpsertWithWhereUniqueWithoutTransferInput = {
    where: TransferDocumentWhereUniqueInput
    update: XOR<TransferDocumentUpdateWithoutTransferInput, TransferDocumentUncheckedUpdateWithoutTransferInput>
    create: XOR<TransferDocumentCreateWithoutTransferInput, TransferDocumentUncheckedCreateWithoutTransferInput>
  }

  export type TransferDocumentUpdateWithWhereUniqueWithoutTransferInput = {
    where: TransferDocumentWhereUniqueInput
    data: XOR<TransferDocumentUpdateWithoutTransferInput, TransferDocumentUncheckedUpdateWithoutTransferInput>
  }

  export type TransferDocumentUpdateManyWithWhereWithoutTransferInput = {
    where: TransferDocumentScalarWhereInput
    data: XOR<TransferDocumentUpdateManyMutationInput, TransferDocumentUncheckedUpdateManyWithoutTransferInput>
  }

  export type TransferDocumentScalarWhereInput = {
    AND?: TransferDocumentScalarWhereInput | TransferDocumentScalarWhereInput[]
    OR?: TransferDocumentScalarWhereInput[]
    NOT?: TransferDocumentScalarWhereInput | TransferDocumentScalarWhereInput[]
    id?: StringFilter<"TransferDocument"> | string
    transferId?: StringFilter<"TransferDocument"> | string
    name?: StringFilter<"TransferDocument"> | string
    type?: StringFilter<"TransferDocument"> | string
    url?: StringFilter<"TransferDocument"> | string
    createdById?: StringNullableFilter<"TransferDocument"> | string | null
    createdAt?: DateTimeFilter<"TransferDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TransferDocument"> | Date | string
  }

  export type TransferCreateWithoutDocumentsInput = {
    id?: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromWarehouse?: WarehouseCreateNestedOneWithoutTransfersFromInput
    fromStore?: StoreCreateNestedOneWithoutTransfersFromInput
    toWarehouse?: WarehouseCreateNestedOneWithoutTransfersToInput
    toStore?: StoreCreateNestedOneWithoutTransfersToInput
    items?: TransferItemCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutDocumentsInput = {
    id?: string
    transferNumber: string
    fromWarehouseId?: string | null
    fromStoreId?: string | null
    toWarehouseId?: string | null
    toStoreId?: string | null
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferItemUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutDocumentsInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutDocumentsInput, TransferUncheckedCreateWithoutDocumentsInput>
  }

  export type TransferUpsertWithoutDocumentsInput = {
    update: XOR<TransferUpdateWithoutDocumentsInput, TransferUncheckedUpdateWithoutDocumentsInput>
    create: XOR<TransferCreateWithoutDocumentsInput, TransferUncheckedCreateWithoutDocumentsInput>
    where?: TransferWhereInput
  }

  export type TransferUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: TransferWhereInput
    data: XOR<TransferUpdateWithoutDocumentsInput, TransferUncheckedUpdateWithoutDocumentsInput>
  }

  export type TransferUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromWarehouse?: WarehouseUpdateOneWithoutTransfersFromNestedInput
    fromStore?: StoreUpdateOneWithoutTransfersFromNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutTransfersToNestedInput
    toStore?: StoreUpdateOneWithoutTransfersToNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    fromStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferCreateWithoutItemsInput = {
    id?: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromWarehouse?: WarehouseCreateNestedOneWithoutTransfersFromInput
    fromStore?: StoreCreateNestedOneWithoutTransfersFromInput
    toWarehouse?: WarehouseCreateNestedOneWithoutTransfersToInput
    toStore?: StoreCreateNestedOneWithoutTransfersToInput
    documents?: TransferDocumentCreateNestedManyWithoutTransferInput
  }

  export type TransferUncheckedCreateWithoutItemsInput = {
    id?: string
    transferNumber: string
    fromWarehouseId?: string | null
    fromStoreId?: string | null
    toWarehouseId?: string | null
    toStoreId?: string | null
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: TransferDocumentUncheckedCreateNestedManyWithoutTransferInput
  }

  export type TransferCreateOrConnectWithoutItemsInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutItemsInput, TransferUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutTransferItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    auditItems?: AuditItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTransferItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemUncheckedCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    auditItems?: AuditItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTransferItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTransferItemsInput, ProductUncheckedCreateWithoutTransferItemsInput>
  }

  export type TransferUpsertWithoutItemsInput = {
    update: XOR<TransferUpdateWithoutItemsInput, TransferUncheckedUpdateWithoutItemsInput>
    create: XOR<TransferCreateWithoutItemsInput, TransferUncheckedCreateWithoutItemsInput>
    where?: TransferWhereInput
  }

  export type TransferUpdateToOneWithWhereWithoutItemsInput = {
    where?: TransferWhereInput
    data: XOR<TransferUpdateWithoutItemsInput, TransferUncheckedUpdateWithoutItemsInput>
  }

  export type TransferUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromWarehouse?: WarehouseUpdateOneWithoutTransfersFromNestedInput
    fromStore?: StoreUpdateOneWithoutTransfersFromNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutTransfersToNestedInput
    toStore?: StoreUpdateOneWithoutTransfersToNestedInput
    documents?: TransferDocumentUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    fromStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: TransferDocumentUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type ProductUpsertWithoutTransferItemsInput = {
    update: XOR<ProductUpdateWithoutTransferItemsInput, ProductUncheckedUpdateWithoutTransferItemsInput>
    create: XOR<ProductCreateWithoutTransferItemsInput, ProductUncheckedCreateWithoutTransferItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTransferItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTransferItemsInput, ProductUncheckedUpdateWithoutTransferItemsInput>
  }

  export type ProductUpdateWithoutTransferItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutProductsNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTransferItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUncheckedUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SaleCreateWithoutCustomerInput = {
    id?: string
    receiptNumber: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSalesInput
    createdBy: UserCreateNestedOneWithoutCreatedSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
    payments?: PaymentCreateNestedManyWithoutSaleInput
    returns?: ReturnCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutCustomerInput = {
    id?: string
    receiptNumber: string
    storeId: string
    createdById: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: PaymentUncheckedCreateNestedManyWithoutSaleInput
    returns?: ReturnUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput>
  }

  export type SaleCreateManyCustomerInputEnvelope = {
    data: SaleCreateManyCustomerInput | SaleCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ReturnCreateWithoutCustomerInput = {
    id?: string
    returnNumber: string
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sale?: SaleCreateNestedOneWithoutReturnsInput
    store: StoreCreateNestedOneWithoutReturnsInput
    processedBy: UserCreateNestedOneWithoutProcessedReturnsInput
    items?: ReturnItemCreateNestedManyWithoutReturnInput
    qualityControls?: QualityControlCreateNestedManyWithoutReturnInput
  }

  export type ReturnUncheckedCreateWithoutCustomerInput = {
    id?: string
    returnNumber: string
    saleId?: string | null
    storeId: string
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    processedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ReturnItemUncheckedCreateNestedManyWithoutReturnInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutReturnInput
  }

  export type ReturnCreateOrConnectWithoutCustomerInput = {
    where: ReturnWhereUniqueInput
    create: XOR<ReturnCreateWithoutCustomerInput, ReturnUncheckedCreateWithoutCustomerInput>
  }

  export type ReturnCreateManyCustomerInputEnvelope = {
    data: ReturnCreateManyCustomerInput | ReturnCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutCustomerInput = {
    id?: string
    type?: string
    street: string
    city: string
    state?: string | null
    postalCode: string
    country: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateWithoutCustomerInput = {
    id?: string
    type?: string
    street: string
    city: string
    state?: string | null
    postalCode: string
    country: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutCustomerInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCustomerInput, AddressUncheckedCreateWithoutCustomerInput>
  }

  export type AddressCreateManyCustomerInputEnvelope = {
    data: AddressCreateManyCustomerInput | AddressCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type LoyaltyTransactionCreateWithoutCustomerInput = {
    id?: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    program: LoyaltyProgramCreateNestedOneWithoutTransactionsInput
  }

  export type LoyaltyTransactionUncheckedCreateWithoutCustomerInput = {
    id?: string
    programId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyTransactionCreateOrConnectWithoutCustomerInput = {
    where: LoyaltyTransactionWhereUniqueInput
    create: XOR<LoyaltyTransactionCreateWithoutCustomerInput, LoyaltyTransactionUncheckedCreateWithoutCustomerInput>
  }

  export type LoyaltyTransactionCreateManyCustomerInputEnvelope = {
    data: LoyaltyTransactionCreateManyCustomerInput | LoyaltyTransactionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SaleUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutCustomerInput, SaleUncheckedUpdateWithoutCustomerInput>
    create: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutCustomerInput, SaleUncheckedUpdateWithoutCustomerInput>
  }

  export type SaleUpdateManyWithWhereWithoutCustomerInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ReturnUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ReturnWhereUniqueInput
    update: XOR<ReturnUpdateWithoutCustomerInput, ReturnUncheckedUpdateWithoutCustomerInput>
    create: XOR<ReturnCreateWithoutCustomerInput, ReturnUncheckedCreateWithoutCustomerInput>
  }

  export type ReturnUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ReturnWhereUniqueInput
    data: XOR<ReturnUpdateWithoutCustomerInput, ReturnUncheckedUpdateWithoutCustomerInput>
  }

  export type ReturnUpdateManyWithWhereWithoutCustomerInput = {
    where: ReturnScalarWhereInput
    data: XOR<ReturnUpdateManyMutationInput, ReturnUncheckedUpdateManyWithoutCustomerInput>
  }

  export type AddressUpsertWithWhereUniqueWithoutCustomerInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutCustomerInput, AddressUncheckedUpdateWithoutCustomerInput>
    create: XOR<AddressCreateWithoutCustomerInput, AddressUncheckedCreateWithoutCustomerInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutCustomerInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutCustomerInput, AddressUncheckedUpdateWithoutCustomerInput>
  }

  export type AddressUpdateManyWithWhereWithoutCustomerInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutCustomerInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: StringFilter<"Address"> | string
    customerId?: StringFilter<"Address"> | string
    type?: StringFilter<"Address"> | string
    street?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringNullableFilter<"Address"> | string | null
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    isDefault?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
  }

  export type LoyaltyTransactionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: LoyaltyTransactionWhereUniqueInput
    update: XOR<LoyaltyTransactionUpdateWithoutCustomerInput, LoyaltyTransactionUncheckedUpdateWithoutCustomerInput>
    create: XOR<LoyaltyTransactionCreateWithoutCustomerInput, LoyaltyTransactionUncheckedCreateWithoutCustomerInput>
  }

  export type LoyaltyTransactionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: LoyaltyTransactionWhereUniqueInput
    data: XOR<LoyaltyTransactionUpdateWithoutCustomerInput, LoyaltyTransactionUncheckedUpdateWithoutCustomerInput>
  }

  export type LoyaltyTransactionUpdateManyWithWhereWithoutCustomerInput = {
    where: LoyaltyTransactionScalarWhereInput
    data: XOR<LoyaltyTransactionUpdateManyMutationInput, LoyaltyTransactionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type LoyaltyTransactionScalarWhereInput = {
    AND?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
    OR?: LoyaltyTransactionScalarWhereInput[]
    NOT?: LoyaltyTransactionScalarWhereInput | LoyaltyTransactionScalarWhereInput[]
    id?: StringFilter<"LoyaltyTransaction"> | string
    customerId?: StringFilter<"LoyaltyTransaction"> | string
    programId?: StringFilter<"LoyaltyTransaction"> | string
    points?: IntFilter<"LoyaltyTransaction"> | number
    type?: EnumLoyaltyTransactionTypeFilter<"LoyaltyTransaction"> | $Enums.LoyaltyTransactionType
    description?: StringNullableFilter<"LoyaltyTransaction"> | string | null
    referenceId?: StringNullableFilter<"LoyaltyTransaction"> | string | null
    createdAt?: DateTimeFilter<"LoyaltyTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyTransaction"> | Date | string
  }

  export type CustomerCreateWithoutAddressesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleCreateNestedManyWithoutCustomerInput
    returns?: ReturnCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAddressesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
    returns?: ReturnUncheckedCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAddressesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
  }

  export type CustomerUpsertWithoutAddressesInput = {
    update: XOR<CustomerUpdateWithoutAddressesInput, CustomerUncheckedUpdateWithoutAddressesInput>
    create: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutAddressesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutAddressesInput, CustomerUncheckedUpdateWithoutAddressesInput>
  }

  export type CustomerUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUpdateManyWithoutCustomerNestedInput
    returns?: ReturnUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
    returns?: ReturnUncheckedUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: LoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type LoyaltyProgramTierCreateWithoutProgramInput = {
    id?: string
    name: string
    description?: string | null
    requiredPoints: number
    pointsMultiplier?: number
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyProgramTierUncheckedCreateWithoutProgramInput = {
    id?: string
    name: string
    description?: string | null
    requiredPoints: number
    pointsMultiplier?: number
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyProgramTierCreateOrConnectWithoutProgramInput = {
    where: LoyaltyProgramTierWhereUniqueInput
    create: XOR<LoyaltyProgramTierCreateWithoutProgramInput, LoyaltyProgramTierUncheckedCreateWithoutProgramInput>
  }

  export type LoyaltyProgramTierCreateManyProgramInputEnvelope = {
    data: LoyaltyProgramTierCreateManyProgramInput | LoyaltyProgramTierCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type LoyaltyTransactionCreateWithoutProgramInput = {
    id?: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutLoyaltyTransactionsInput
  }

  export type LoyaltyTransactionUncheckedCreateWithoutProgramInput = {
    id?: string
    customerId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyTransactionCreateOrConnectWithoutProgramInput = {
    where: LoyaltyTransactionWhereUniqueInput
    create: XOR<LoyaltyTransactionCreateWithoutProgramInput, LoyaltyTransactionUncheckedCreateWithoutProgramInput>
  }

  export type LoyaltyTransactionCreateManyProgramInputEnvelope = {
    data: LoyaltyTransactionCreateManyProgramInput | LoyaltyTransactionCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type LoyaltyProgramTierUpsertWithWhereUniqueWithoutProgramInput = {
    where: LoyaltyProgramTierWhereUniqueInput
    update: XOR<LoyaltyProgramTierUpdateWithoutProgramInput, LoyaltyProgramTierUncheckedUpdateWithoutProgramInput>
    create: XOR<LoyaltyProgramTierCreateWithoutProgramInput, LoyaltyProgramTierUncheckedCreateWithoutProgramInput>
  }

  export type LoyaltyProgramTierUpdateWithWhereUniqueWithoutProgramInput = {
    where: LoyaltyProgramTierWhereUniqueInput
    data: XOR<LoyaltyProgramTierUpdateWithoutProgramInput, LoyaltyProgramTierUncheckedUpdateWithoutProgramInput>
  }

  export type LoyaltyProgramTierUpdateManyWithWhereWithoutProgramInput = {
    where: LoyaltyProgramTierScalarWhereInput
    data: XOR<LoyaltyProgramTierUpdateManyMutationInput, LoyaltyProgramTierUncheckedUpdateManyWithoutProgramInput>
  }

  export type LoyaltyProgramTierScalarWhereInput = {
    AND?: LoyaltyProgramTierScalarWhereInput | LoyaltyProgramTierScalarWhereInput[]
    OR?: LoyaltyProgramTierScalarWhereInput[]
    NOT?: LoyaltyProgramTierScalarWhereInput | LoyaltyProgramTierScalarWhereInput[]
    id?: StringFilter<"LoyaltyProgramTier"> | string
    programId?: StringFilter<"LoyaltyProgramTier"> | string
    name?: StringFilter<"LoyaltyProgramTier"> | string
    description?: StringNullableFilter<"LoyaltyProgramTier"> | string | null
    requiredPoints?: IntFilter<"LoyaltyProgramTier"> | number
    pointsMultiplier?: FloatFilter<"LoyaltyProgramTier"> | number
    benefits?: StringNullableFilter<"LoyaltyProgramTier"> | string | null
    createdAt?: DateTimeFilter<"LoyaltyProgramTier"> | Date | string
    updatedAt?: DateTimeFilter<"LoyaltyProgramTier"> | Date | string
  }

  export type LoyaltyTransactionUpsertWithWhereUniqueWithoutProgramInput = {
    where: LoyaltyTransactionWhereUniqueInput
    update: XOR<LoyaltyTransactionUpdateWithoutProgramInput, LoyaltyTransactionUncheckedUpdateWithoutProgramInput>
    create: XOR<LoyaltyTransactionCreateWithoutProgramInput, LoyaltyTransactionUncheckedCreateWithoutProgramInput>
  }

  export type LoyaltyTransactionUpdateWithWhereUniqueWithoutProgramInput = {
    where: LoyaltyTransactionWhereUniqueInput
    data: XOR<LoyaltyTransactionUpdateWithoutProgramInput, LoyaltyTransactionUncheckedUpdateWithoutProgramInput>
  }

  export type LoyaltyTransactionUpdateManyWithWhereWithoutProgramInput = {
    where: LoyaltyTransactionScalarWhereInput
    data: XOR<LoyaltyTransactionUpdateManyMutationInput, LoyaltyTransactionUncheckedUpdateManyWithoutProgramInput>
  }

  export type LoyaltyProgramCreateWithoutTiersInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerDollar?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: LoyaltyTransactionCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramUncheckedCreateWithoutTiersInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerDollar?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: LoyaltyTransactionUncheckedCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramCreateOrConnectWithoutTiersInput = {
    where: LoyaltyProgramWhereUniqueInput
    create: XOR<LoyaltyProgramCreateWithoutTiersInput, LoyaltyProgramUncheckedCreateWithoutTiersInput>
  }

  export type LoyaltyProgramUpsertWithoutTiersInput = {
    update: XOR<LoyaltyProgramUpdateWithoutTiersInput, LoyaltyProgramUncheckedUpdateWithoutTiersInput>
    create: XOR<LoyaltyProgramCreateWithoutTiersInput, LoyaltyProgramUncheckedCreateWithoutTiersInput>
    where?: LoyaltyProgramWhereInput
  }

  export type LoyaltyProgramUpdateToOneWithWhereWithoutTiersInput = {
    where?: LoyaltyProgramWhereInput
    data: XOR<LoyaltyProgramUpdateWithoutTiersInput, LoyaltyProgramUncheckedUpdateWithoutTiersInput>
  }

  export type LoyaltyProgramUpdateWithoutTiersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerDollar?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: LoyaltyTransactionUpdateManyWithoutProgramNestedInput
  }

  export type LoyaltyProgramUncheckedUpdateWithoutTiersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerDollar?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: LoyaltyTransactionUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type CustomerCreateWithoutLoyaltyTransactionsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleCreateNestedManyWithoutCustomerInput
    returns?: ReturnCreateNestedManyWithoutCustomerInput
    addresses?: AddressCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutLoyaltyTransactionsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
    returns?: ReturnUncheckedCreateNestedManyWithoutCustomerInput
    addresses?: AddressUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutLoyaltyTransactionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutLoyaltyTransactionsInput, CustomerUncheckedCreateWithoutLoyaltyTransactionsInput>
  }

  export type LoyaltyProgramCreateWithoutTransactionsInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerDollar?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tiers?: LoyaltyProgramTierCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    description?: string | null
    pointsPerDollar?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tiers?: LoyaltyProgramTierUncheckedCreateNestedManyWithoutProgramInput
  }

  export type LoyaltyProgramCreateOrConnectWithoutTransactionsInput = {
    where: LoyaltyProgramWhereUniqueInput
    create: XOR<LoyaltyProgramCreateWithoutTransactionsInput, LoyaltyProgramUncheckedCreateWithoutTransactionsInput>
  }

  export type CustomerUpsertWithoutLoyaltyTransactionsInput = {
    update: XOR<CustomerUpdateWithoutLoyaltyTransactionsInput, CustomerUncheckedUpdateWithoutLoyaltyTransactionsInput>
    create: XOR<CustomerCreateWithoutLoyaltyTransactionsInput, CustomerUncheckedCreateWithoutLoyaltyTransactionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutLoyaltyTransactionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutLoyaltyTransactionsInput, CustomerUncheckedUpdateWithoutLoyaltyTransactionsInput>
  }

  export type CustomerUpdateWithoutLoyaltyTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUpdateManyWithoutCustomerNestedInput
    returns?: ReturnUpdateManyWithoutCustomerNestedInput
    addresses?: AddressUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutLoyaltyTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
    returns?: ReturnUncheckedUpdateManyWithoutCustomerNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type LoyaltyProgramUpsertWithoutTransactionsInput = {
    update: XOR<LoyaltyProgramUpdateWithoutTransactionsInput, LoyaltyProgramUncheckedUpdateWithoutTransactionsInput>
    create: XOR<LoyaltyProgramCreateWithoutTransactionsInput, LoyaltyProgramUncheckedCreateWithoutTransactionsInput>
    where?: LoyaltyProgramWhereInput
  }

  export type LoyaltyProgramUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: LoyaltyProgramWhereInput
    data: XOR<LoyaltyProgramUpdateWithoutTransactionsInput, LoyaltyProgramUncheckedUpdateWithoutTransactionsInput>
  }

  export type LoyaltyProgramUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerDollar?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tiers?: LoyaltyProgramTierUpdateManyWithoutProgramNestedInput
  }

  export type LoyaltyProgramUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointsPerDollar?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tiers?: LoyaltyProgramTierUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type WarehouseCreateWithoutAuditsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferCreateNestedManyWithoutToWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
    qualityControls?: QualityControlCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutAuditsInput = {
    id?: string
    name: string
    code: string
    address?: string | null
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    zones?: WarehouseZoneUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    staff?: WarehouseStaffUncheckedCreateNestedManyWithoutWarehouseInput
    transfersFrom?: TransferUncheckedCreateNestedManyWithoutFromWarehouseInput
    transfersTo?: TransferUncheckedCreateNestedManyWithoutToWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
    qualityControls?: QualityControlUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutAuditsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutAuditsInput, WarehouseUncheckedCreateWithoutAuditsInput>
  }

  export type UserCreateWithoutCreatedAuditsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    auditAssignments?: AuditAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedAuditsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnUncheckedCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlUncheckedCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    auditAssignments?: AuditAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedAuditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedAuditsInput, UserUncheckedCreateWithoutCreatedAuditsInput>
  }

  export type AuditItemCreateWithoutAuditInput = {
    id?: string
    expectedQuantity: number
    countedQuantity?: number | null
    discrepancy?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    countedById?: string | null
    countedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutAuditItemsInput
    inventoryItem: InventoryItemCreateNestedOneWithoutAuditItemsInput
  }

  export type AuditItemUncheckedCreateWithoutAuditInput = {
    id?: string
    productId: string
    inventoryItemId: string
    expectedQuantity: number
    countedQuantity?: number | null
    discrepancy?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    countedById?: string | null
    countedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemCreateOrConnectWithoutAuditInput = {
    where: AuditItemWhereUniqueInput
    create: XOR<AuditItemCreateWithoutAuditInput, AuditItemUncheckedCreateWithoutAuditInput>
  }

  export type AuditItemCreateManyAuditInputEnvelope = {
    data: AuditItemCreateManyAuditInput | AuditItemCreateManyAuditInput[]
    skipDuplicates?: boolean
  }

  export type AuditAssignmentCreateWithoutAuditInput = {
    id?: string
    assignedZones?: string | null
    status?: $Enums.AssignmentStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAuditAssignmentsInput
  }

  export type AuditAssignmentUncheckedCreateWithoutAuditInput = {
    id?: string
    userId: string
    assignedZones?: string | null
    status?: $Enums.AssignmentStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditAssignmentCreateOrConnectWithoutAuditInput = {
    where: AuditAssignmentWhereUniqueInput
    create: XOR<AuditAssignmentCreateWithoutAuditInput, AuditAssignmentUncheckedCreateWithoutAuditInput>
  }

  export type AuditAssignmentCreateManyAuditInputEnvelope = {
    data: AuditAssignmentCreateManyAuditInput | AuditAssignmentCreateManyAuditInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseUpsertWithoutAuditsInput = {
    update: XOR<WarehouseUpdateWithoutAuditsInput, WarehouseUncheckedUpdateWithoutAuditsInput>
    create: XOR<WarehouseCreateWithoutAuditsInput, WarehouseUncheckedCreateWithoutAuditsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutAuditsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutAuditsInput, WarehouseUncheckedUpdateWithoutAuditsInput>
  }

  export type WarehouseUpdateWithoutAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUpdateManyWithoutToWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
    qualityControls?: QualityControlUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: WarehouseZoneUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    staff?: WarehouseStaffUncheckedUpdateManyWithoutWarehouseNestedInput
    transfersFrom?: TransferUncheckedUpdateManyWithoutFromWarehouseNestedInput
    transfersTo?: TransferUncheckedUpdateManyWithoutToWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type UserUpsertWithoutCreatedAuditsInput = {
    update: XOR<UserUpdateWithoutCreatedAuditsInput, UserUncheckedUpdateWithoutCreatedAuditsInput>
    create: XOR<UserCreateWithoutCreatedAuditsInput, UserUncheckedCreateWithoutCreatedAuditsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedAuditsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedAuditsInput, UserUncheckedUpdateWithoutCreatedAuditsInput>
  }

  export type UserUpdateWithoutCreatedAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    auditAssignments?: AuditAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUncheckedUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUncheckedUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    auditAssignments?: AuditAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AuditItemUpsertWithWhereUniqueWithoutAuditInput = {
    where: AuditItemWhereUniqueInput
    update: XOR<AuditItemUpdateWithoutAuditInput, AuditItemUncheckedUpdateWithoutAuditInput>
    create: XOR<AuditItemCreateWithoutAuditInput, AuditItemUncheckedCreateWithoutAuditInput>
  }

  export type AuditItemUpdateWithWhereUniqueWithoutAuditInput = {
    where: AuditItemWhereUniqueInput
    data: XOR<AuditItemUpdateWithoutAuditInput, AuditItemUncheckedUpdateWithoutAuditInput>
  }

  export type AuditItemUpdateManyWithWhereWithoutAuditInput = {
    where: AuditItemScalarWhereInput
    data: XOR<AuditItemUpdateManyMutationInput, AuditItemUncheckedUpdateManyWithoutAuditInput>
  }

  export type AuditAssignmentUpsertWithWhereUniqueWithoutAuditInput = {
    where: AuditAssignmentWhereUniqueInput
    update: XOR<AuditAssignmentUpdateWithoutAuditInput, AuditAssignmentUncheckedUpdateWithoutAuditInput>
    create: XOR<AuditAssignmentCreateWithoutAuditInput, AuditAssignmentUncheckedCreateWithoutAuditInput>
  }

  export type AuditAssignmentUpdateWithWhereUniqueWithoutAuditInput = {
    where: AuditAssignmentWhereUniqueInput
    data: XOR<AuditAssignmentUpdateWithoutAuditInput, AuditAssignmentUncheckedUpdateWithoutAuditInput>
  }

  export type AuditAssignmentUpdateManyWithWhereWithoutAuditInput = {
    where: AuditAssignmentScalarWhereInput
    data: XOR<AuditAssignmentUpdateManyMutationInput, AuditAssignmentUncheckedUpdateManyWithoutAuditInput>
  }

  export type AuditCreateWithoutItemsInput = {
    id?: string
    referenceNumber: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutAuditsInput
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    assignments?: AuditAssignmentCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutItemsInput = {
    id?: string
    referenceNumber: string
    warehouseId: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    completedDate?: Date | string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AuditAssignmentUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutItemsInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutItemsInput, AuditUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutAuditItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    supplier?: SupplierCreateNestedOneWithoutProductsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    transferItems?: TransferItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAuditItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    categoryId?: string | null
    supplierId?: string | null
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutProductInput
    qualityControlItems?: QualityControlItemUncheckedCreateNestedManyWithoutProductInput
    returnItems?: ReturnItemUncheckedCreateNestedManyWithoutProductInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    transferItems?: TransferItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutAuditItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAuditItemsInput, ProductUncheckedCreateWithoutAuditItemsInput>
  }

  export type InventoryItemCreateWithoutAuditItemsInput = {
    id?: string
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    store?: StoreCreateNestedOneWithoutInventoryItemsInput
    warehouse?: WarehouseCreateNestedOneWithoutInventoryItemsInput
    bin?: WarehouseBinCreateNestedOneWithoutInventoryItemsInput
    saleItems?: SaleItemCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutAuditItemsInput = {
    id?: string
    productId: string
    storeId?: string | null
    warehouseId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutAuditItemsInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutAuditItemsInput, InventoryItemUncheckedCreateWithoutAuditItemsInput>
  }

  export type AuditUpsertWithoutItemsInput = {
    update: XOR<AuditUpdateWithoutItemsInput, AuditUncheckedUpdateWithoutItemsInput>
    create: XOR<AuditCreateWithoutItemsInput, AuditUncheckedCreateWithoutItemsInput>
    where?: AuditWhereInput
  }

  export type AuditUpdateToOneWithWhereWithoutItemsInput = {
    where?: AuditWhereInput
    data: XOR<AuditUpdateWithoutItemsInput, AuditUncheckedUpdateWithoutItemsInput>
  }

  export type AuditUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutAuditsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    assignments?: AuditAssignmentUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AuditAssignmentUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type ProductUpsertWithoutAuditItemsInput = {
    update: XOR<ProductUpdateWithoutAuditItemsInput, ProductUncheckedUpdateWithoutAuditItemsInput>
    create: XOR<ProductCreateWithoutAuditItemsInput, ProductUncheckedCreateWithoutAuditItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutAuditItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutAuditItemsInput, ProductUncheckedUpdateWithoutAuditItemsInput>
  }

  export type ProductUpdateWithoutAuditItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutProductsNestedInput
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutAuditItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUncheckedUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type InventoryItemUpsertWithoutAuditItemsInput = {
    update: XOR<InventoryItemUpdateWithoutAuditItemsInput, InventoryItemUncheckedUpdateWithoutAuditItemsInput>
    create: XOR<InventoryItemCreateWithoutAuditItemsInput, InventoryItemUncheckedCreateWithoutAuditItemsInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutAuditItemsInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutAuditItemsInput, InventoryItemUncheckedUpdateWithoutAuditItemsInput>
  }

  export type InventoryItemUpdateWithoutAuditItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    store?: StoreUpdateOneWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryItemsNestedInput
    bin?: WarehouseBinUpdateOneWithoutInventoryItemsNestedInput
    saleItems?: SaleItemUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutAuditItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type AuditCreateWithoutAssignmentsInput = {
    id?: string
    referenceNumber: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutAuditsInput
    createdBy: UserCreateNestedOneWithoutCreatedAuditsInput
    items?: AuditItemCreateNestedManyWithoutAuditInput
  }

  export type AuditUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    referenceNumber: string
    warehouseId: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    completedDate?: Date | string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: AuditItemUncheckedCreateNestedManyWithoutAuditInput
  }

  export type AuditCreateOrConnectWithoutAssignmentsInput = {
    where: AuditWhereUniqueInput
    create: XOR<AuditCreateWithoutAssignmentsInput, AuditUncheckedCreateWithoutAssignmentsInput>
  }

  export type UserCreateWithoutAuditAssignmentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    createdSales?: SaleCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffCreateNestedOneWithoutUserInput
    createdAudits?: AuditCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAuditAssignmentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    createdSales?: SaleUncheckedCreateNestedManyWithoutCreatedByInput
    processedReturns?: ReturnUncheckedCreateNestedManyWithoutProcessedByInput
    inspectedQCs?: QualityControlUncheckedCreateNestedManyWithoutInspectedByInput
    warehouseStaff?: WarehouseStaffUncheckedCreateNestedOneWithoutUserInput
    storeStaff?: StoreStaffUncheckedCreateNestedOneWithoutUserInput
    createdAudits?: AuditUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAuditAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditAssignmentsInput, UserUncheckedCreateWithoutAuditAssignmentsInput>
  }

  export type AuditUpsertWithoutAssignmentsInput = {
    update: XOR<AuditUpdateWithoutAssignmentsInput, AuditUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<AuditCreateWithoutAssignmentsInput, AuditUncheckedCreateWithoutAssignmentsInput>
    where?: AuditWhereInput
  }

  export type AuditUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: AuditWhereInput
    data: XOR<AuditUpdateWithoutAssignmentsInput, AuditUncheckedUpdateWithoutAssignmentsInput>
  }

  export type AuditUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutAuditsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    items?: AuditItemUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: AuditItemUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type UserUpsertWithoutAuditAssignmentsInput = {
    update: XOR<UserUpdateWithoutAuditAssignmentsInput, UserUncheckedUpdateWithoutAuditAssignmentsInput>
    create: XOR<UserCreateWithoutAuditAssignmentsInput, UserUncheckedCreateWithoutAuditAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditAssignmentsInput, UserUncheckedUpdateWithoutAuditAssignmentsInput>
  }

  export type UserUpdateWithoutAuditAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    createdSales?: SaleUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    createdSales?: SaleUncheckedUpdateManyWithoutCreatedByNestedInput
    processedReturns?: ReturnUncheckedUpdateManyWithoutProcessedByNestedInput
    inspectedQCs?: QualityControlUncheckedUpdateManyWithoutInspectedByNestedInput
    warehouseStaff?: WarehouseStaffUncheckedUpdateOneWithoutUserNestedInput
    storeStaff?: StoreStaffUncheckedUpdateOneWithoutUserNestedInput
    createdAudits?: AuditUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SaleCreateManyCreatedByInput = {
    id?: string
    receiptNumber: string
    storeId: string
    customerId?: string | null
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnCreateManyProcessedByInput = {
    id?: string
    returnNumber: string
    saleId?: string | null
    storeId: string
    customerId?: string | null
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualityControlCreateManyInspectedByInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    warehouseId: string
    purchaseOrderId?: string | null
    returnId?: string | null
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditCreateManyCreatedByInput = {
    id?: string
    referenceNumber: string
    warehouseId: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditAssignmentCreateManyUserInput = {
    id?: string
    auditId: string
    assignedZones?: string | null
    status?: $Enums.AssignmentStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
    payments?: PaymentUpdateManyWithoutSaleNestedInput
    returns?: ReturnUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutSaleNestedInput
    returns?: ReturnUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneWithoutReturnsNestedInput
    store?: StoreUpdateOneRequiredWithoutReturnsNestedInput
    customer?: CustomerUpdateOneWithoutReturnsNestedInput
    items?: ReturnItemUpdateManyWithoutReturnNestedInput
    qualityControls?: QualityControlUpdateManyWithoutReturnNestedInput
  }

  export type ReturnUncheckedUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ReturnItemUncheckedUpdateManyWithoutReturnNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutReturnNestedInput
  }

  export type ReturnUncheckedUpdateManyWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityControlUpdateWithoutInspectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutQualityControlsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutQualityControlsNestedInput
    return?: ReturnUpdateOneWithoutQualityControlsNestedInput
    items?: QualityControlItemUpdateManyWithoutQualityControlNestedInput
  }

  export type QualityControlUncheckedUpdateWithoutInspectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    returnId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QualityControlItemUncheckedUpdateManyWithoutQualityControlNestedInput
  }

  export type QualityControlUncheckedUpdateManyWithoutInspectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    returnId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutAuditsNestedInput
    items?: AuditItemUpdateManyWithoutAuditNestedInput
    assignments?: AuditAssignmentUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: AuditItemUncheckedUpdateManyWithoutAuditNestedInput
    assignments?: AuditAssignmentUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAssignmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AuditAssignmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAssignmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseZoneCreateManyWarehouseInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemCreateManyWarehouseInput = {
    id?: string
    productId: string
    storeId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseStaffCreateManyWarehouseInput = {
    id?: string
    userId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyFromWarehouseInput = {
    id?: string
    transferNumber: string
    fromStoreId?: string | null
    toWarehouseId?: string | null
    toStoreId?: string | null
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyToWarehouseInput = {
    id?: string
    transferNumber: string
    fromWarehouseId?: string | null
    fromStoreId?: string | null
    toStoreId?: string | null
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManyWarehouseInput = {
    id?: string
    orderNumber: string
    supplierId: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    status?: $Enums.PurchaseOrderStatus
    subtotal?: number
    taxAmount?: number
    totalAmount?: number
    notes?: string | null
    createdById?: string | null
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualityControlCreateManyWarehouseInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    purchaseOrderId?: string | null
    returnId?: string | null
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    inspectedById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditCreateManyWarehouseInput = {
    id?: string
    referenceNumber: string
    status?: $Enums.AuditStatus
    startDate: Date | string
    endDate?: Date | string | null
    completedDate?: Date | string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseZoneUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aisles?: WarehouseAisleUpdateManyWithoutZoneNestedInput
  }

  export type WarehouseZoneUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aisles?: WarehouseAisleUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type WarehouseZoneUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    store?: StoreUpdateOneWithoutInventoryItemsNestedInput
    bin?: WarehouseBinUpdateOneWithoutInventoryItemsNestedInput
    saleItems?: SaleItemUpdateManyWithoutInventoryItemNestedInput
    auditItems?: AuditItemUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    auditItems?: AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseStaffUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWarehouseStaffNestedInput
  }

  export type WarehouseStaffUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseStaffUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutFromWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromStore?: StoreUpdateOneWithoutTransfersFromNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutTransfersToNestedInput
    toStore?: StoreUpdateOneWithoutTransfersToNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
    documents?: TransferDocumentUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutFromWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    fromStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
    documents?: TransferDocumentUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutFromWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    fromStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromWarehouse?: WarehouseUpdateOneWithoutTransfersFromNestedInput
    fromStore?: StoreUpdateOneWithoutTransfersFromNestedInput
    toStore?: StoreUpdateOneWithoutTransfersToNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
    documents?: TransferDocumentUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    fromStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    toStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
    documents?: TransferDocumentUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    fromStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    toStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    qualityControls?: QualityControlUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityControlUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneWithoutQualityControlsNestedInput
    return?: ReturnUpdateOneWithoutQualityControlsNestedInput
    inspectedBy?: UserUpdateOneRequiredWithoutInspectedQCsNestedInput
    items?: QualityControlItemUpdateManyWithoutQualityControlNestedInput
  }

  export type QualityControlUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    returnId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectedById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QualityControlItemUncheckedUpdateManyWithoutQualityControlNestedInput
  }

  export type QualityControlUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    returnId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectedById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedAuditsNestedInput
    items?: AuditItemUpdateManyWithoutAuditNestedInput
    assignments?: AuditAssignmentUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: AuditItemUncheckedUpdateManyWithoutAuditNestedInput
    assignments?: AuditAssignmentUncheckedUpdateManyWithoutAuditNestedInput
  }

  export type AuditUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumAuditStatusFieldUpdateOperationsInput | $Enums.AuditStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseAisleCreateManyZoneInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseAisleUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shelves?: WarehouseShelfUpdateManyWithoutAisleNestedInput
  }

  export type WarehouseAisleUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shelves?: WarehouseShelfUncheckedUpdateManyWithoutAisleNestedInput
  }

  export type WarehouseAisleUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseShelfCreateManyAisleInput = {
    id?: string
    name: string
    code: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseShelfUpdateWithoutAisleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bins?: WarehouseBinUpdateManyWithoutShelfNestedInput
  }

  export type WarehouseShelfUncheckedUpdateWithoutAisleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bins?: WarehouseBinUncheckedUpdateManyWithoutShelfNestedInput
  }

  export type WarehouseShelfUncheckedUpdateManyWithoutAisleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseBinCreateManyShelfInput = {
    id?: string
    name: string
    code: string
    capacity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseBinUpdateWithoutShelfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutBinNestedInput
  }

  export type WarehouseBinUncheckedUpdateWithoutShelfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutBinNestedInput
  }

  export type WarehouseBinUncheckedUpdateManyWithoutShelfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyBinInput = {
    id?: string
    productId: string
    storeId?: string | null
    warehouseId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateWithoutBinInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    store?: StoreUpdateOneWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryItemsNestedInput
    saleItems?: SaleItemUpdateManyWithoutInventoryItemNestedInput
    auditItems?: AuditItemUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutBinInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    auditItems?: AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutBinInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyStoreInput = {
    id?: string
    productId: string
    warehouseId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleCreateManyStoreInput = {
    id?: string
    receiptNumber: string
    customerId?: string | null
    createdById: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnCreateManyStoreInput = {
    id?: string
    returnNumber: string
    saleId?: string | null
    customerId?: string | null
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    processedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreStaffCreateManyStoreInput = {
    id?: string
    userId: string
    position?: string | null
    isManager?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyFromStoreInput = {
    id?: string
    transferNumber: string
    fromWarehouseId?: string | null
    toWarehouseId?: string | null
    toStoreId?: string | null
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyToStoreInput = {
    id?: string
    transferNumber: string
    fromWarehouseId?: string | null
    fromStoreId?: string | null
    toWarehouseId?: string | null
    status?: $Enums.TransferStatus
    transferType: $Enums.TransferType
    priority?: $Enums.TransferPriority
    requestedById?: string | null
    approvedById?: string | null
    rejectedById?: string | null
    completedById?: string | null
    requestedDate?: Date | string | null
    approvedDate?: Date | string | null
    rejectedDate?: Date | string | null
    completedDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualDeliveryDate?: Date | string | null
    shippingMethod?: string | null
    trackingNumber?: string | null
    totalItems?: number
    totalCost?: number
    totalRetail?: number
    rejectionReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryItemsNestedInput
    bin?: WarehouseBinUpdateOneWithoutInventoryItemsNestedInput
    saleItems?: SaleItemUpdateManyWithoutInventoryItemNestedInput
    auditItems?: AuditItemUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    auditItems?: AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutSalesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
    payments?: PaymentUpdateManyWithoutSaleNestedInput
    returns?: ReturnUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutSaleNestedInput
    returns?: ReturnUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneWithoutReturnsNestedInput
    customer?: CustomerUpdateOneWithoutReturnsNestedInput
    processedBy?: UserUpdateOneRequiredWithoutProcessedReturnsNestedInput
    items?: ReturnItemUpdateManyWithoutReturnNestedInput
    qualityControls?: QualityControlUpdateManyWithoutReturnNestedInput
  }

  export type ReturnUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ReturnItemUncheckedUpdateManyWithoutReturnNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutReturnNestedInput
  }

  export type ReturnUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStaffUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStoreStaffNestedInput
  }

  export type StoreStaffUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreStaffUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    isManager?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutFromStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromWarehouse?: WarehouseUpdateOneWithoutTransfersFromNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutTransfersToNestedInput
    toStore?: StoreUpdateOneWithoutTransfersToNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
    documents?: TransferDocumentUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutFromStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
    documents?: TransferDocumentUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutFromStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromWarehouse?: WarehouseUpdateOneWithoutTransfersFromNestedInput
    fromStore?: StoreUpdateOneWithoutTransfersFromNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutTransfersToNestedInput
    items?: TransferItemUpdateManyWithoutTransferNestedInput
    documents?: TransferDocumentUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateWithoutToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    fromStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferItemUncheckedUpdateManyWithoutTransferNestedInput
    documents?: TransferDocumentUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type TransferUncheckedUpdateManyWithoutToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    fromStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    priority?: EnumTransferPriorityFieldUpdateOperationsInput | $Enums.TransferPriority
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedById?: NullableStringFieldUpdateOperationsInput | string | null
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    totalRetail?: FloatFieldUpdateOperationsInput | number
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManySupplierInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    categoryId?: string | null
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierContractCreateManySupplierInput = {
    id?: string
    contractNumber: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    renewalDate?: Date | string | null
    value?: number | null
    terms?: string | null
    paymentTerms?: string | null
    status?: $Enums.ContractStatus
    documentUrl?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManySupplierInput = {
    id?: string
    orderNumber: string
    warehouseId: string
    orderDate?: Date | string
    expectedDeliveryDate?: Date | string | null
    status?: $Enums.PurchaseOrderStatus
    subtotal?: number
    taxAmount?: number
    totalAmount?: number
    notes?: string | null
    createdById?: string | null
    approvedById?: string | null
    receivedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierPerformanceMetricCreateManySupplierInput = {
    id?: string
    metricType: $Enums.PerformanceMetricType
    date: Date | string
    value: number
    notes?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutProductsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUncheckedUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierContractUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierContractUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierContractUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    qualityControls?: QualityControlUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPerformanceMetricUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: EnumPerformanceMetricTypeFieldUpdateOperationsInput | $Enums.PerformanceMetricType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPerformanceMetricUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: EnumPerformanceMetricTypeFieldUpdateOperationsInput | $Enums.PerformanceMetricType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPerformanceMetricUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: EnumPerformanceMetricTypeFieldUpdateOperationsInput | $Enums.PerformanceMetricType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateManyPurchaseOrderInput = {
    id?: string
    productId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualityControlCreateManyPurchaseOrderInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    warehouseId: string
    returnId?: string | null
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    inspectedById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityControlUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutQualityControlsNestedInput
    return?: ReturnUpdateOneWithoutQualityControlsNestedInput
    inspectedBy?: UserUpdateOneRequiredWithoutInspectedQCsNestedInput
    items?: QualityControlItemUpdateManyWithoutQualityControlNestedInput
  }

  export type QualityControlUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    returnId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectedById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QualityControlItemUncheckedUpdateManyWithoutQualityControlNestedInput
  }

  export type QualityControlUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    returnId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectedById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateManyProductInput = {
    id?: string
    purchaseOrderId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    receivedQuantity?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualityControlItemCreateManyProductInput = {
    id?: string
    qualityControlId: string
    quantity: number
    passedQuantity?: number
    failedQuantity?: number
    pendingQuantity?: number
    status?: $Enums.QCItemStatus
    reason?: string | null
    action?: $Enums.QCAction | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnItemCreateManyProductInput = {
    id?: string
    returnId: string
    saleItemId?: string | null
    quantity: number
    unitPrice: number
    totalPrice: number
    reason: $Enums.ReturnReason
    condition?: $Enums.ItemCondition
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemCreateManyProductInput = {
    id?: string
    storeId?: string | null
    warehouseId?: string | null
    binId?: string | null
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    manufacturingDate?: Date | string | null
    quantity?: number
    reservedQuantity?: number
    costPrice?: number
    retailPrice?: number
    status?: $Enums.InventoryStatus
    condition?: $Enums.ProductCondition
    inventoryMethod?: $Enums.InventoryMethod | null
    receivedDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleItemCreateManyProductInput = {
    id?: string
    saleId: string
    inventoryItemId: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemCreateManyProductInput = {
    id?: string
    transferId: string
    quantity: number
    sourceCostPrice: number
    sourceRetailPrice: number
    targetCostPrice: number
    targetRetailPrice: number
    condition?: $Enums.ProductCondition
    adjustmentReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemCreateManyProductInput = {
    id?: string
    auditId: string
    inventoryItemId: string
    expectedQuantity: number
    countedQuantity?: number | null
    discrepancy?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    countedById?: string | null
    countedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    receivedQuantity?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityControlItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    passedQuantity?: IntFieldUpdateOperationsInput | number
    failedQuantity?: IntFieldUpdateOperationsInput | number
    pendingQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumQCItemStatusFieldUpdateOperationsInput | $Enums.QCItemStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableEnumQCActionFieldUpdateOperationsInput | $Enums.QCAction | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qualityControl?: QualityControlUpdateOneRequiredWithoutItemsNestedInput
  }

  export type QualityControlItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualityControlId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    passedQuantity?: IntFieldUpdateOperationsInput | number
    failedQuantity?: IntFieldUpdateOperationsInput | number
    pendingQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumQCItemStatusFieldUpdateOperationsInput | $Enums.QCItemStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableEnumQCActionFieldUpdateOperationsInput | $Enums.QCAction | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityControlItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    qualityControlId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    passedQuantity?: IntFieldUpdateOperationsInput | number
    failedQuantity?: IntFieldUpdateOperationsInput | number
    pendingQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumQCItemStatusFieldUpdateOperationsInput | $Enums.QCItemStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableEnumQCActionFieldUpdateOperationsInput | $Enums.QCAction | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    reason?: EnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason
    condition?: EnumItemConditionFieldUpdateOperationsInput | $Enums.ItemCondition
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    return?: ReturnUpdateOneRequiredWithoutItemsNestedInput
    saleItem?: SaleItemUpdateOneWithoutReturnItemsNestedInput
  }

  export type ReturnItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    saleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    reason?: EnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason
    condition?: EnumItemConditionFieldUpdateOperationsInput | $Enums.ItemCondition
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    saleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    reason?: EnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason
    condition?: EnumItemConditionFieldUpdateOperationsInput | $Enums.ItemCondition
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneWithoutInventoryItemsNestedInput
    bin?: WarehouseBinUpdateOneWithoutInventoryItemsNestedInput
    saleItems?: SaleItemUpdateManyWithoutInventoryItemNestedInput
    auditItems?: AuditItemUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutInventoryItemNestedInput
    auditItems?: AuditItemUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manufacturingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQuantity?: IntFieldUpdateOperationsInput | number
    costPrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumInventoryStatusFieldUpdateOperationsInput | $Enums.InventoryStatus
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    inventoryMethod?: NullableEnumInventoryMethodFieldUpdateOperationsInput | $Enums.InventoryMethod | null
    receivedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutItemsNestedInput
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutSaleItemsNestedInput
    returnItems?: ReturnItemUpdateManyWithoutSaleItemNestedInput
  }

  export type SaleItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnItems?: ReturnItemUncheckedUpdateManyWithoutSaleItemNestedInput
  }

  export type SaleItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sourceCostPrice?: FloatFieldUpdateOperationsInput | number
    sourceRetailPrice?: FloatFieldUpdateOperationsInput | number
    targetCostPrice?: FloatFieldUpdateOperationsInput | number
    targetRetailPrice?: FloatFieldUpdateOperationsInput | number
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    adjustmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transfer?: TransferUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TransferItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sourceCostPrice?: FloatFieldUpdateOperationsInput | number
    sourceRetailPrice?: FloatFieldUpdateOperationsInput | number
    targetCostPrice?: FloatFieldUpdateOperationsInput | number
    targetRetailPrice?: FloatFieldUpdateOperationsInput | number
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    adjustmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sourceCostPrice?: FloatFieldUpdateOperationsInput | number
    sourceRetailPrice?: FloatFieldUpdateOperationsInput | number
    targetCostPrice?: FloatFieldUpdateOperationsInput | number
    targetRetailPrice?: FloatFieldUpdateOperationsInput | number
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    adjustmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    discrepancy?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    countedById?: NullableStringFieldUpdateOperationsInput | string | null
    countedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutItemsNestedInput
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutAuditItemsNestedInput
  }

  export type AuditItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    discrepancy?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    countedById?: NullableStringFieldUpdateOperationsInput | string | null
    countedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    discrepancy?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    countedById?: NullableStringFieldUpdateOperationsInput | string | null
    countedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyCategoryInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit?: string
    supplierId?: string | null
    costPrice?: number
    wholesalePrice?: number
    retailPrice?: number
    minStockLevel?: number
    reorderPoint?: number
    leadTime?: number | null
    condition?: $Enums.ProductCondition
    createdById?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryPriceRuleCreateManyCategoryInput = {
    id?: string
    adjustmentType: string
    adjustmentValue: number
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneWithoutProductsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutProductNestedInput
    qualityControlItems?: QualityControlItemUncheckedUpdateManyWithoutProductNestedInput
    returnItems?: ReturnItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    transferItems?: TransferItemUncheckedUpdateManyWithoutProductNestedInput
    auditItems?: AuditItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryPriceRuleUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: StringFieldUpdateOperationsInput | string
    adjustmentValue?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryPriceRuleUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: StringFieldUpdateOperationsInput | string
    adjustmentValue?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryPriceRuleUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: StringFieldUpdateOperationsInput | string
    adjustmentValue?: FloatFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemCreateManyInventoryItemInput = {
    id?: string
    saleId: string
    productId: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemCreateManyInventoryItemInput = {
    id?: string
    auditId: string
    productId: string
    expectedQuantity: number
    countedQuantity?: number | null
    discrepancy?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    countedById?: string | null
    countedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleItemUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutSaleItemsNestedInput
    returnItems?: ReturnItemUpdateManyWithoutSaleItemNestedInput
  }

  export type SaleItemUncheckedUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnItems?: ReturnItemUncheckedUpdateManyWithoutSaleItemNestedInput
  }

  export type SaleItemUncheckedUpdateManyWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    discrepancy?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    countedById?: NullableStringFieldUpdateOperationsInput | string | null
    countedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audit?: AuditUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutAuditItemsNestedInput
  }

  export type AuditItemUncheckedUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    discrepancy?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    countedById?: NullableStringFieldUpdateOperationsInput | string | null
    countedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemUncheckedUpdateManyWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    auditId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    discrepancy?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    countedById?: NullableStringFieldUpdateOperationsInput | string | null
    countedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemCreateManySaleInput = {
    id?: string
    productId: string
    inventoryItemId: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    totalPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManySaleInput = {
    id?: string
    amount: number
    paymentMethod: $Enums.PaymentMethod
    referenceNumber?: string | null
    notes?: string | null
    processedById: string
    processedByName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnCreateManySaleInput = {
    id?: string
    returnNumber: string
    storeId: string
    customerId?: string | null
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    processedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleItemUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSaleItemsNestedInput
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutSaleItemsNestedInput
    returnItems?: ReturnItemUpdateManyWithoutSaleItemNestedInput
  }

  export type SaleItemUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnItems?: ReturnItemUncheckedUpdateManyWithoutSaleItemNestedInput
  }

  export type SaleItemUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    processedByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    processedByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    processedByName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutReturnsNestedInput
    customer?: CustomerUpdateOneWithoutReturnsNestedInput
    processedBy?: UserUpdateOneRequiredWithoutProcessedReturnsNestedInput
    items?: ReturnItemUpdateManyWithoutReturnNestedInput
    qualityControls?: QualityControlUpdateManyWithoutReturnNestedInput
  }

  export type ReturnUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ReturnItemUncheckedUpdateManyWithoutReturnNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutReturnNestedInput
  }

  export type ReturnUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnItemCreateManySaleItemInput = {
    id?: string
    returnId: string
    productId: string
    quantity: number
    unitPrice: number
    totalPrice: number
    reason: $Enums.ReturnReason
    condition?: $Enums.ItemCondition
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnItemUpdateWithoutSaleItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    reason?: EnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason
    condition?: EnumItemConditionFieldUpdateOperationsInput | $Enums.ItemCondition
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    return?: ReturnUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutReturnItemsNestedInput
  }

  export type ReturnItemUncheckedUpdateWithoutSaleItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    reason?: EnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason
    condition?: EnumItemConditionFieldUpdateOperationsInput | $Enums.ItemCondition
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnItemUncheckedUpdateManyWithoutSaleItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    reason?: EnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason
    condition?: EnumItemConditionFieldUpdateOperationsInput | $Enums.ItemCondition
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnItemCreateManyReturnInput = {
    id?: string
    productId: string
    saleItemId?: string | null
    quantity: number
    unitPrice: number
    totalPrice: number
    reason: $Enums.ReturnReason
    condition?: $Enums.ItemCondition
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualityControlCreateManyReturnInput = {
    id?: string
    referenceNumber: string
    type: $Enums.QCType
    status?: $Enums.QCStatus
    warehouseId: string
    purchaseOrderId?: string | null
    inspectionDate?: Date | string
    completedDate?: Date | string | null
    inspectedById: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnItemUpdateWithoutReturnInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    reason?: EnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason
    condition?: EnumItemConditionFieldUpdateOperationsInput | $Enums.ItemCondition
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutReturnItemsNestedInput
    saleItem?: SaleItemUpdateOneWithoutReturnItemsNestedInput
  }

  export type ReturnItemUncheckedUpdateWithoutReturnInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    saleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    reason?: EnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason
    condition?: EnumItemConditionFieldUpdateOperationsInput | $Enums.ItemCondition
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnItemUncheckedUpdateManyWithoutReturnInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    saleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    reason?: EnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason
    condition?: EnumItemConditionFieldUpdateOperationsInput | $Enums.ItemCondition
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityControlUpdateWithoutReturnInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutQualityControlsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutQualityControlsNestedInput
    inspectedBy?: UserUpdateOneRequiredWithoutInspectedQCsNestedInput
    items?: QualityControlItemUpdateManyWithoutQualityControlNestedInput
  }

  export type QualityControlUncheckedUpdateWithoutReturnInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectedById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QualityControlItemUncheckedUpdateManyWithoutQualityControlNestedInput
  }

  export type QualityControlUncheckedUpdateManyWithoutReturnInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumQCTypeFieldUpdateOperationsInput | $Enums.QCType
    status?: EnumQCStatusFieldUpdateOperationsInput | $Enums.QCStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    inspectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectedById?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityControlItemCreateManyQualityControlInput = {
    id?: string
    productId: string
    quantity: number
    passedQuantity?: number
    failedQuantity?: number
    pendingQuantity?: number
    status?: $Enums.QCItemStatus
    reason?: string | null
    action?: $Enums.QCAction | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QualityControlItemUpdateWithoutQualityControlInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    passedQuantity?: IntFieldUpdateOperationsInput | number
    failedQuantity?: IntFieldUpdateOperationsInput | number
    pendingQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumQCItemStatusFieldUpdateOperationsInput | $Enums.QCItemStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableEnumQCActionFieldUpdateOperationsInput | $Enums.QCAction | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutQualityControlItemsNestedInput
  }

  export type QualityControlItemUncheckedUpdateWithoutQualityControlInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    passedQuantity?: IntFieldUpdateOperationsInput | number
    failedQuantity?: IntFieldUpdateOperationsInput | number
    pendingQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumQCItemStatusFieldUpdateOperationsInput | $Enums.QCItemStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableEnumQCActionFieldUpdateOperationsInput | $Enums.QCAction | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityControlItemUncheckedUpdateManyWithoutQualityControlInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    passedQuantity?: IntFieldUpdateOperationsInput | number
    failedQuantity?: IntFieldUpdateOperationsInput | number
    pendingQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumQCItemStatusFieldUpdateOperationsInput | $Enums.QCItemStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableEnumQCActionFieldUpdateOperationsInput | $Enums.QCAction | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemCreateManyTransferInput = {
    id?: string
    productId: string
    quantity: number
    sourceCostPrice: number
    sourceRetailPrice: number
    targetCostPrice: number
    targetRetailPrice: number
    condition?: $Enums.ProductCondition
    adjustmentReason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferDocumentCreateManyTransferInput = {
    id?: string
    name: string
    type: string
    url: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferItemUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sourceCostPrice?: FloatFieldUpdateOperationsInput | number
    sourceRetailPrice?: FloatFieldUpdateOperationsInput | number
    targetCostPrice?: FloatFieldUpdateOperationsInput | number
    targetRetailPrice?: FloatFieldUpdateOperationsInput | number
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    adjustmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutTransferItemsNestedInput
  }

  export type TransferItemUncheckedUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sourceCostPrice?: FloatFieldUpdateOperationsInput | number
    sourceRetailPrice?: FloatFieldUpdateOperationsInput | number
    targetCostPrice?: FloatFieldUpdateOperationsInput | number
    targetRetailPrice?: FloatFieldUpdateOperationsInput | number
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    adjustmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferItemUncheckedUpdateManyWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sourceCostPrice?: FloatFieldUpdateOperationsInput | number
    sourceRetailPrice?: FloatFieldUpdateOperationsInput | number
    targetCostPrice?: FloatFieldUpdateOperationsInput | number
    targetRetailPrice?: FloatFieldUpdateOperationsInput | number
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    adjustmentReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferDocumentUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferDocumentUncheckedUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferDocumentUncheckedUpdateManyWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateManyCustomerInput = {
    id?: string
    receiptNumber: string
    storeId: string
    createdById: string
    saleDate?: Date | string
    subtotal: number
    taxAmount: number
    discountAmount?: number
    totalAmount: number
    paymentMethod: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnCreateManyCustomerInput = {
    id?: string
    returnNumber: string
    saleId?: string | null
    storeId: string
    returnDate?: Date | string
    status?: $Enums.ReturnStatus
    subtotal: number
    taxAmount: number
    totalAmount: number
    refundMethod?: $Enums.RefundMethod | null
    refundStatus?: $Enums.RefundStatus
    reason?: string | null
    notes?: string | null
    processedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateManyCustomerInput = {
    id?: string
    type?: string
    street: string
    city: string
    state?: string | null
    postalCode: string
    country: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyTransactionCreateManyCustomerInput = {
    id?: string
    programId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
    payments?: PaymentUpdateManyWithoutSaleNestedInput
    returns?: ReturnUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutSaleNestedInput
    returns?: ReturnUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNumber?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneWithoutReturnsNestedInput
    store?: StoreUpdateOneRequiredWithoutReturnsNestedInput
    processedBy?: UserUpdateOneRequiredWithoutProcessedReturnsNestedInput
    items?: ReturnItemUpdateManyWithoutReturnNestedInput
    qualityControls?: QualityControlUpdateManyWithoutReturnNestedInput
  }

  export type ReturnUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ReturnItemUncheckedUpdateManyWithoutReturnNestedInput
    qualityControls?: QualityControlUncheckedUpdateManyWithoutReturnNestedInput
  }

  export type ReturnUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: StringFieldUpdateOperationsInput | string
    returnDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundStatus?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: LoyaltyProgramUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type LoyaltyTransactionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramTierCreateManyProgramInput = {
    id?: string
    name: string
    description?: string | null
    requiredPoints: number
    pointsMultiplier?: number
    benefits?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyTransactionCreateManyProgramInput = {
    id?: string
    customerId: string
    points: number
    type: $Enums.LoyaltyTransactionType
    description?: string | null
    referenceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoyaltyProgramTierUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredPoints?: IntFieldUpdateOperationsInput | number
    pointsMultiplier?: FloatFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramTierUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredPoints?: IntFieldUpdateOperationsInput | number
    pointsMultiplier?: FloatFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyProgramTierUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requiredPoints?: IntFieldUpdateOperationsInput | number
    pointsMultiplier?: FloatFieldUpdateOperationsInput | number
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutLoyaltyTransactionsNestedInput
  }

  export type LoyaltyTransactionUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoyaltyTransactionUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemCreateManyAuditInput = {
    id?: string
    productId: string
    inventoryItemId: string
    expectedQuantity: number
    countedQuantity?: number | null
    discrepancy?: number | null
    notes?: string | null
    status?: $Enums.AuditItemStatus
    countedById?: string | null
    countedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditAssignmentCreateManyAuditInput = {
    id?: string
    userId: string
    assignedZones?: string | null
    status?: $Enums.AssignmentStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditItemUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    discrepancy?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    countedById?: NullableStringFieldUpdateOperationsInput | string | null
    countedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutAuditItemsNestedInput
    inventoryItem?: InventoryItemUpdateOneRequiredWithoutAuditItemsNestedInput
  }

  export type AuditItemUncheckedUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    discrepancy?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    countedById?: NullableStringFieldUpdateOperationsInput | string | null
    countedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditItemUncheckedUpdateManyWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: StringFieldUpdateOperationsInput | string
    expectedQuantity?: IntFieldUpdateOperationsInput | number
    countedQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    discrepancy?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAuditItemStatusFieldUpdateOperationsInput | $Enums.AuditItemStatus
    countedById?: NullableStringFieldUpdateOperationsInput | string | null
    countedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAssignmentUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditAssignmentsNestedInput
  }

  export type AuditAssignmentUncheckedUpdateWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAssignmentUncheckedUpdateManyWithoutAuditInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedZones?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}